<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ST4IVisionCoreNet</name>
    </assembly>
    <members>
        <member name="T:ST4IVisionCoreNet.Sv">
            <summary>
            Smart Vision (OpenCV) Functions of C++ I/F (cv::xxx) 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Sv.PI">
            <summary>
            The ratio of a circle's circumference to its diameter
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Sv.LOG2">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Sv.FILLED">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ToPtr(ST4IVisionCoreNet.ICvPtrHolder)">
            <summary>
            引数がnullの時はIntPtr.Zeroに変換する
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rodrigues(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            converts rotation vector to rotation matrix or vice versa using Rodrigues transformation
            </summary>
            <param name="src">Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</param>
            <param name="dst">Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial derivatives of the output array components with respect to the input array components.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rodrigues(System.Double[],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            converts rotation vector to rotation matrix using Rodrigues transformation
            </summary>
            <param name="vector">Input rotation vector (3x1).</param>
            <param name="matrix">Output rotation matrix (3x3).</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9, which is a matrix of partial derivatives of the output array components with respect to the input array components.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rodrigues(System.Double[0:,0:],System.Double[]@,System.Double[0:,0:]@)">
            <summary>
            converts rotation matrix to rotation vector using Rodrigues transformation
            </summary>
            <param name="matrix">Input rotation matrix (3x3).</param>
            <param name="vector">Output rotation vector (3x1).</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9, which is a matrix of partial derivatives of the output array components with respect to the input array components.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindHomography(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.HomographyMethods,System.Double,ST4IVisionCoreNet.OutputArray,System.Int32,System.Double)">
            <summary>
            computes the best-fit perspective transformation mapping srcPoints to dstPoints.
            </summary>
            <param name="srcPoints">Coordinates of the points in the original plane, a matrix of the type CV_32FC2</param>
            <param name="dstPoints">Coordinates of the points in the target plane, a matrix of the type CV_32FC2</param>
            <param name="method">Method used to computed a homography matrix.</param>
            <param name="ransacReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (used in the RANSAC method only)</param>
            <param name="mask"> Optional output mask set by a robust method ( CV_RANSAC or CV_LMEDS ). Note that the input mask values are ignored.</param>
            <param name="maxIters">The maximum number of RANSAC iterations.</param>
            <param name="confidence">Confidence level, between 0 and 1.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindHomography(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},ST4IVisionCoreNet.HomographyMethods,System.Double,ST4IVisionCoreNet.OutputArray,System.Int32,System.Double)">
            <summary>
            computes the best-fit perspective transformation mapping srcPoints to dstPoints.
            </summary>
            <param name="srcPoints">Coordinates of the points in the original plane</param>
            <param name="dstPoints">Coordinates of the points in the target plane</param>
            <param name="method">Method used to computed a homography matrix.</param>
            <param name="ransacReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (used in the RANSAC method only)</param>
            <param name="mask"> Optional output mask set by a robust method ( CV_RANSAC or CV_LMEDS ). Note that the input mask values are ignored.</param>
            <param name="maxIters">The maximum number of RANSAC iterations.</param>
            <param name="confidence">Confidence level, between 0 and 1.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindHomography(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.UsacParams)">
            <summary>
            computes the best-fit perspective transformation mapping srcPoints to dstPoints.
            </summary>
            <param name="srcPoints">Coordinates of the points in the original plane, a matrix of the type CV_32FC2</param>
            <param name="dstPoints">Coordinates of the points in the target plane, a matrix of the type CV_32FC2</param>
            <param name="mask"> Optional output mask set by a robust method ( CV_RANSAC or CV_LMEDS ). Note that the input mask values are ignored.</param>
            <param name="params"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RQDecomp3x3(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Computes RQ decomposition of 3x3 matrix
            </summary>
            <param name="src">3x3 input matrix.</param>
            <param name="mtxR">Output 3x3 upper-triangular matrix.</param>
            <param name="mtxQ"> Output 3x3 orthogonal matrix.</param>
            <param name="qx">Optional output 3x3 rotation matrix around x-axis.</param>
            <param name="qy">Optional output 3x3 rotation matrix around y-axis.</param>
            <param name="qz">Optional output 3x3 rotation matrix around z-axis.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RQDecomp3x3(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            Computes RQ decomposition of 3x3 matrix
            </summary>
            <param name="src">3x3 input matrix.</param>
            <param name="mtxR">Output 3x3 upper-triangular matrix.</param>
            <param name="mtxQ"> Output 3x3 orthogonal matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RQDecomp3x3(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            Computes RQ decomposition of 3x3 matrix
            </summary>
            <param name="src">3x3 input matrix.</param>
            <param name="mtxR">Output 3x3 upper-triangular matrix.</param>
            <param name="mtxQ"> Output 3x3 orthogonal matrix.</param>
            <param name="qx">Optional output 3x3 rotation matrix around x-axis.</param>
            <param name="qy">Optional output 3x3 rotation matrix around y-axis.</param>
            <param name="qz">Optional output 3x3 rotation matrix around z-axis.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DecomposeProjectionMatrix(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Decomposes the projection matrix into camera matrix and the rotation martix and the translation vector
            </summary>
            <param name="projMatrix">3x4 input projection matrix P.</param>
            <param name="cameraMatrix">Output 3x3 camera matrix K.</param>
            <param name="rotMatrix">Output 3x3 external rotation matrix R.</param>
            <param name="transVect">Output 4x1 translation vector T.</param>
            <param name="rotMatrixX">Optional 3x3 rotation matrix around x-axis.</param>
            <param name="rotMatrixY">Optional 3x3 rotation matrix around y-axis.</param>
            <param name="rotMatrixZ">Optional 3x3 rotation matrix around z-axis.</param>
            <param name="eulerAngles">ptional three-element vector containing three Euler angles of rotation in degrees.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DecomposeProjectionMatrix(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[]@)">
            <summary>
            Decomposes the projection matrix into camera matrix and the rotation martix and the translation vector
            </summary>
            <param name="projMatrix">3x4 input projection matrix P.</param>
            <param name="cameraMatrix">Output 3x3 camera matrix K.</param>
            <param name="rotMatrix">Output 3x3 external rotation matrix R.</param>
            <param name="transVect">Output 4x1 translation vector T.</param>
            <param name="rotMatrixX">Optional 3x3 rotation matrix around x-axis.</param>
            <param name="rotMatrixY">Optional 3x3 rotation matrix around y-axis.</param>
            <param name="rotMatrixZ">Optional 3x3 rotation matrix around z-axis.</param>
            <param name="eulerAngles">ptional three-element vector containing three Euler angles of rotation in degrees.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DecomposeProjectionMatrix(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[]@)">
            <summary>
            Decomposes the projection matrix into camera matrix and the rotation martix and the translation vector
            </summary>
            <param name="projMatrix">3x4 input projection matrix P.</param>
            <param name="cameraMatrix">Output 3x3 camera matrix K.</param>
            <param name="rotMatrix">Output 3x3 external rotation matrix R.</param>
            <param name="transVect">Output 4x1 translation vector T.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MatMulDeriv(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            computes derivatives of the matrix product w.r.t each of the multiplied matrix coefficients
            </summary>
            <param name="a">First multiplied matrix.</param>
            <param name="b">Second multiplied matrix.</param>
            <param name="dABdA">First output derivative matrix d(A*B)/dA of size A.rows*B.cols X A.rows*A.cols .</param>
            <param name="dABdB">Second output derivative matrix d(A*B)/dB of size A.rows*B.cols X B.rows*B.cols .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ComposeRT(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            composes 2 [R|t] transformations together. Also computes the derivatives of the result w.r.t the arguments
            </summary>
            <param name="rvec1">First rotation vector.</param>
            <param name="tvec1">First translation vector.</param>
            <param name="rvec2">Second rotation vector.</param>
            <param name="tvec2">Second translation vector.</param>
            <param name="rvec3">Output rotation vector of the superposition.</param>
            <param name="tvec3">Output translation vector of the superposition.</param>
            <param name="dr3dr1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dt1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dr2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dt2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dr1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dt1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dr2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dt2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ComposeRT(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[]@,System.Double[]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            composes 2 [R|t] transformations together. Also computes the derivatives of the result w.r.t the arguments
            </summary>
            <param name="rvec1">First rotation vector.</param>
            <param name="tvec1">First translation vector.</param>
            <param name="rvec2">Second rotation vector.</param>
            <param name="tvec2">Second translation vector.</param>
            <param name="rvec3">Output rotation vector of the superposition.</param>
            <param name="tvec3">Output translation vector of the superposition.</param>
            <param name="dr3dr1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dt1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dr2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dt2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dr1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dt1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dr2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dt2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ComposeRT(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[]@,System.Double[]@)">
            <summary>
            composes 2 [R|t] transformations together. Also computes the derivatives of the result w.r.t the arguments
            </summary>
            <param name="rvec1">First rotation vector.</param>
            <param name="tvec1">First translation vector.</param>
            <param name="rvec2">Second rotation vector.</param>
            <param name="tvec2">Second translation vector.</param>
            <param name="rvec3">Output rotation vector of the superposition.</param>
            <param name="tvec3">Output translation vector of the superposition.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ProjectPoints(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Double)">
            <summary>
            projects points from the model coordinate space to the image coordinates. 
            Also computes derivatives of the image coordinates w.r.t the intrinsic 
            and extrinsic camera parameters
            </summary>
            <param name="objectPoints">Array of object points, 3xN/Nx3 1-channel or 
            1xN/Nx1 3-channel, where N is the number of points in the view.</param>
            <param name="rvec">Rotation vector (3x1).</param>
            <param name="tvec">Translation vector (3x1).</param>
            <param name="cameraMatrix">Camera matrix (3x3)</param>
            <param name="distCoeffs">Input vector of distortion coefficients 
            (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="imagePoints">Output array of image points, 2xN/Nx2 1-channel 
            or 1xN/Nx1 2-channel</param>
            <param name="jacobian">Optional output 2Nx(10 + numDistCoeffs) jacobian matrix 
            of derivatives of image points with respect to components of the rotation vector, 
            translation vector, focal lengths, coordinates of the principal point and 
            the distortion coefficients. In the old interface different components of 
            the jacobian are returned via different output parameters.</param>
            <param name="aspectRatio">Optional “fixed aspect ratio” parameter. 
            If the parameter is not 0, the function assumes that the aspect ratio (fx/fy) 
            is fixed and correspondingly adjusts the jacobian matrix.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ProjectPoints(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f},System.Double[],System.Double[],System.Double[0:,0:],System.Double[],ST4IVisionCoreNet.Point2f[]@,System.Double[0:,0:]@,System.Double)">
            <summary>
            projects points from the model coordinate space to the image coordinates. 
            Also computes derivatives of the image coordinates w.r.t the intrinsic 
            and extrinsic camera parameters
            </summary>
            <param name="objectPoints">Array of object points, 3xN/Nx3 1-channel or 
            1xN/Nx1 3-channel, where N is the number of points in the view.</param>
            <param name="rvec">Rotation vector (3x1).</param>
            <param name="tvec">Translation vector (3x1).</param>
            <param name="cameraMatrix">Camera matrix (3x3)</param>
            <param name="distCoeffs">Input vector of distortion coefficients 
            (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="imagePoints">Output array of image points, 2xN/Nx2 1-channel 
            or 1xN/Nx1 2-channel</param>
            <param name="jacobian">Optional output 2Nx(10 + numDistCoeffs) jacobian matrix 
            of derivatives of image points with respect to components of the rotation vector, 
            translation vector, focal lengths, coordinates of the principal point and 
            the distortion coefficients. In the old interface different components of 
            the jacobian are returned via different output parameters.</param>
            <param name="aspectRatio">Optional “fixed aspect ratio” parameter. 
            If the parameter is not 0, the function assumes that the aspect ratio (fx/fy) 
            is fixed and correspondingly adjusts the jacobian matrix.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SolvePnP(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Boolean,ST4IVisionCoreNet.SolvePnPFlags)">
            <summary>
            Finds an object pose from 3D-2D point correspondences.
            </summary>
            <param name="objectPoints"> Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. vector&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, 
            where N is the number of points. vector&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system to the 
            camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations of 
            the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="flags">Method for solving a PnP problem:</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SolvePnP(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Double[0:,0:],System.Collections.Generic.IEnumerable{System.Double},System.Double[]@,System.Double[]@,System.Boolean,ST4IVisionCoreNet.SolvePnPFlags)">
            <summary>
            Finds an object pose from 3D-2D point correspondences.
            </summary>
            <param name="objectPoints"> Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. vector&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, 
            where N is the number of points. vector&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system to the 
            camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations of 
            the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="flags">Method for solving a PnP problem</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SolvePnPRansac(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Boolean,System.Int32,System.Single,System.Double,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.SolvePnPFlags)">
            <summary>
            computes the camera pose from a few 3D points and the corresponding projections. The outliers are possible.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. List&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. 
            List&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input 3x3 camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system 
            to the camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations 
            of the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="iterationsCount">Number of iterations.</param>
            <param name="reprojectionError">Inlier threshold value used by the RANSAC procedure. 
            The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier.</param>
            <param name="confidence">The probability that the algorithm produces a useful result.</param>
            <param name="inliers">Output vector that contains indices of inliers in objectPoints and imagePoints .</param>
            <param name="flags">Method for solving a PnP problem</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SolvePnPRansac(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Double[0:,0:],System.Collections.Generic.IEnumerable{System.Double},System.Double[]@,System.Double[]@)">
            <summary>
            computes the camera pose from a few 3D points and the corresponding projections. The outliers are possible.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. List&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. 
            List&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input 3x3 camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system 
            to the camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SolvePnPRansac(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Double[0:,0:],System.Collections.Generic.IEnumerable{System.Double},System.Double[]@,System.Double[]@,System.Int32[]@,System.Boolean,System.Int32,System.Single,System.Double,ST4IVisionCoreNet.SolvePnPFlags)">
            <summary>
            computes the camera pose from a few 3D points and the corresponding projections. The outliers are possible.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. List&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. 
            List&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input 3x3 camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system 
            to the camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations 
            of the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="iterationsCount">Number of iterations.</param>
            <param name="reprojectionError">Inlier threshold value used by the RANSAC procedure. 
            The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier.</param>
            <param name="confidence">The probability that the algorithm produces a useful result.</param>
            <param name="inliers">Output vector that contains indices of inliers in objectPoints and imagePoints .</param>
            <param name="flags">Method for solving a PnP problem</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InitCameraMatrix2D(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.Size,System.Double)">
            <summary>
            initializes camera matrix from a few 3D points and the corresponding projections.
            </summary>
            <param name="objectPoints">Vector of vectors (vector&lt;vector&lt;Point3d&gt;&gt;) of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-view vectors are concatenated.</param>
            <param name="imagePoints">Vector of vectors (vector&lt;vector&lt;Point2d&gt;&gt;) of the projections of the calibration pattern points. In the old interface all the per-view vectors are concatenated.</param>
            <param name="imageSize">Image size in pixels used to initialize the principal point.</param>
            <param name="aspectRatio">If it is zero or negative, both f_x and f_y are estimated independently. Otherwise, f_x = f_y * aspectRatio .</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InitCameraMatrix2D(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f}},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f}},ST4IVisionCoreNet.Size,System.Double)">
            <summary>
            initializes camera matrix from a few 3D points and the corresponding projections.
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-view vectors are concatenated.</param>
            <param name="imagePoints">Vector of vectors of the projections of the calibration pattern points. In the old interface all the per-view vectors are concatenated.</param>
            <param name="imageSize">Image size in pixels used to initialize the principal point.</param>
            <param name="aspectRatio">If it is zero or negative, both f_x and f_y are estimated independently. Otherwise, f_x = f_y * aspectRatio .</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindChessboardCorners(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ChessboardFlags)">
            <summary>
            Finds the positions of internal corners of the chessboard.
            </summary>
            <param name="image">Source chessboard view. It must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column 
            ( patternSize = Size(points_per_row,points_per_colum) = Size(columns, rows) ).</param>
            <param name="corners">Output array of detected corners.</param>
            <param name="flags">Various operation flags that can be zero or a combination of the ChessboardFlag values</param>
            <returns>The function returns true if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). 
            Otherwise, if the function fails to find all the corners or reorder them, it returns false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindChessboardCorners(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Point2f[]@,ST4IVisionCoreNet.ChessboardFlags)">
            <summary>
            Finds the positions of internal corners of the chessboard.
            </summary>
            <param name="image">Source chessboard view. It must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column 
            ( patternSize = Size(points_per_row,points_per_colum) = Size(columns, rows) ).</param>
            <param name="corners">Output array of detected corners.</param>
            <param name="flags">Various operation flags that can be zero or a combination of the ChessboardFlag values</param>
            <returns>The function returns true if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). 
            Otherwise, if the function fails to find all the corners or reorder them, it returns false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CheckChessboard(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size)">
            <summary>
            Checks whether the image contains chessboard of the specific size or not.
            </summary>
            <param name="img"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindChessboardCornersSB(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ChessboardFlags)">
            <summary>
            Finds the positions of internal corners of the chessboard using a sector based approach.
            </summary>
            <param name="image">image Source chessboard view. It must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column
            (patternSize = Size(points_per_row, points_per_column) = Size(columns, rows) ).</param>
            <param name="corners">Output array of detected corners.</param>
            <param name="flags">flags Various operation flags that can be zero or a combination of the ChessboardFlags values.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindChessboardCornersSB(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Point2f[]@,ST4IVisionCoreNet.ChessboardFlags)">
            <summary>
            Finds the positions of internal corners of the chessboard using a sector based approach.
            </summary>
            <param name="image">image Source chessboard view. It must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column
            (patternSize = Size(points_per_row, points_per_column) = Size(columns, rows) ).</param>
            <param name="corners">Output array of detected corners.</param>
            <param name="flags">flags Various operation flags that can be zero or a combination of the ChessboardFlags values.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Find4QuadCornerSubpix(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Size)">
            <summary>
            finds subpixel-accurate positions of the chessboard corners
            </summary>
            <param name="img"></param>
            <param name="corners"></param>
            <param name="regionSize"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Find4QuadCornerSubpix(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[],ST4IVisionCoreNet.Size)">
            <summary>
            finds subpixel-accurate positions of the chessboard corners
            </summary>
            <param name="img"></param>
            <param name="corners"></param>
            <param name="regionSize"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawChessboardCorners(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            Renders the detected chessboard corners.
            </summary>
            <param name="image">Destination image. It must be an 8-bit color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column (patternSize = cv::Size(points_per_row,points_per_column)).</param>
            <param name="corners">Array of detected corners, the output of findChessboardCorners.</param>
            <param name="patternWasFound">Parameter indicating whether the complete board was found or not. The return value of findChessboardCorners() should be passed here.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawChessboardCorners(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Size,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Boolean)">
            <summary>
            Renders the detected chessboard corners.
            </summary>
            <param name="image">Destination image. It must be an 8-bit color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column (patternSize = cv::Size(points_per_row,points_per_column)).</param>
            <param name="corners">Array of detected corners, the output of findChessboardCorners.</param>
            <param name="patternWasFound">Parameter indicating whether the complete board was found or not. The return value of findChessboardCorners() should be passed here.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawFrameAxes(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Single,System.Int32)">
            <summary>
            Draw axes of the world/object coordinate system from pose estimation.
            </summary>
            <param name="image">Input/output image. It must have 1 or 3 channels. The number of channels is not altered.</param>
            <param name="cameraMatrix">Input 3x3 floating-point matrix of camera intrinsic parameters.</param>
            <param name="distCoeffs">Input vector of distortion coefficients
            \f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\f$ of
            4, 5, 8, 12 or 14 elements.If the vector is empty, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Rotation vector (see @ref Rodrigues ) that, together with tvec , brings points from
            the model coordinate system to the camera coordinate system.</param>
            <param name="tvec">Translation vector.</param>
            <param name="length">Length of the painted axes in the same unit than tvec (usually in meters).</param>
            <param name="thickness">Line thickness of the painted axes.</param>
            <remarks>This function draws the axes of the world/object coordinate system w.r.t. to the camera frame.
            OX is drawn in red, OY in green and OZ in blue.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindCirclesGrid(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.FindCirclesGridFlags,ST4IVisionCoreNet.Feature2D)">
            <summary>
            Finds centers in the grid of circles.
            </summary>
            <param name="image">grid view of input circles; it must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">number of circles per row and column ( patternSize = Size(points_per_row, points_per_colum) ).</param>
            <param name="centers">output array of detected centers.</param>
            <param name="flags">various operation flags that can be one of the FindCirclesGridFlag values</param>
            <param name="blobDetector">feature detector that finds blobs like dark circles on light background.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindCirclesGrid(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Point2f[]@,ST4IVisionCoreNet.FindCirclesGridFlags,ST4IVisionCoreNet.Feature2D)">
            <summary>
            Finds centers in the grid of circles.
            </summary>
            <param name="image">grid view of input circles; it must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">number of circles per row and column ( patternSize = Size(points_per_row, points_per_colum) ).</param>
            <param name="centers">output array of detected centers.</param>
            <param name="flags">various operation flags that can be one of the FindCirclesGridFlag values</param>
            <param name="blobDetector">feature detector that finds blobs like dark circles on light background.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalibrateCamera(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Mat[]@,ST4IVisionCoreNet.Mat[]@,ST4IVisionCoreNet.CalibrationFlags,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            finds intrinsic and extrinsic camera parameters from several fews of a known calibration pattern.
            </summary>
            <param name="objectPoints">In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space. 
            The outer vector contains as many elements as the number of the pattern views. If the same calibration pattern is shown in each view and 
            it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns, or even different patterns 
            in different views. Then, the vectors will be different. The points are 3D, but since they are in a pattern coordinate system, then, 
            if the rig is planar, it may make sense to put the model to a XY coordinate plane so that Z-coordinate of each input object point is 0.
            In the old interface all the vectors of object points from different views are concatenated together.</param>
            <param name="imagePoints">In the new interface it is a vector of vectors of the projections of calibration pattern points. 
            imagePoints.Count() and objectPoints.Count() and imagePoints[i].Count() must be equal to objectPoints[i].Count() for each i.</param>
            <param name="imageSize">Size of the image used only to initialize the intrinsic camera matrix.</param>
            <param name="cameraMatrix">Output 3x3 floating-point camera matrix. 
            If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be 
            initialized before calling the function.</param>
            <param name="distCoeffs">Output vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements.</param>
            <param name="rvecs">Output vector of rotation vectors (see Rodrigues() ) estimated for each pattern view. That is, each k-th rotation vector 
            together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern 
            from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the 
            calibration pattern in the k-th pattern view (k=0.. M -1)</param>
            <param name="tvecs">Output vector of translation vectors estimated for each pattern view.</param>
            <param name="flags">Different flags that may be zero or a combination of the CalibrationFlag values</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalibrateCamera(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f}},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f}},ST4IVisionCoreNet.Size,System.Double[0:,0:],System.Double[],ST4IVisionCoreNet.Vec3d[]@,ST4IVisionCoreNet.Vec3d[]@,ST4IVisionCoreNet.CalibrationFlags,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            finds intrinsic and extrinsic camera parameters from several fews of a known calibration pattern.
            </summary>
            <param name="objectPoints">In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space. 
            The outer vector contains as many elements as the number of the pattern views. If the same calibration pattern is shown in each view and 
            it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns, or even different patterns 
            in different views. Then, the vectors will be different. The points are 3D, but since they are in a pattern coordinate system, then, 
            if the rig is planar, it may make sense to put the model to a XY coordinate plane so that Z-coordinate of each input object point is 0.
            In the old interface all the vectors of object points from different views are concatenated together.</param>
            <param name="imagePoints">In the new interface it is a vector of vectors of the projections of calibration pattern points. 
            imagePoints.Count() and objectPoints.Count() and imagePoints[i].Count() must be equal to objectPoints[i].Count() for each i.</param>
            <param name="imageSize">Size of the image used only to initialize the intrinsic camera matrix.</param>
            <param name="cameraMatrix">Output 3x3 floating-point camera matrix. 
            If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be 
            initialized before calling the function.</param>
            <param name="distCoeffs">Output vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements.</param>
            <param name="rvecs">Output vector of rotation vectors (see Rodrigues() ) estimated for each pattern view. That is, each k-th rotation vector 
            together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern 
            from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the 
            calibration pattern in the k-th pattern view (k=0.. M -1)</param>
            <param name="tvecs">Output vector of translation vectors estimated for each pattern view.</param>
            <param name="flags">Different flags that may be zero or a combination of the CalibrationFlag values</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalibrationMatrixValues(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,System.Double,System.Double,System.Double@,System.Double@,System.Double@,ST4IVisionCoreNet.Point2d@,System.Double@)">
            <summary>
            computes several useful camera characteristics from the camera matrix, camera frame resolution and the physical sensor size.
            </summary>
            <param name="cameraMatrix">Input camera matrix that can be estimated by calibrateCamera() or stereoCalibrate() .</param>
            <param name="imageSize">Input image size in pixels.</param>
            <param name="apertureWidth">Physical width of the sensor.</param>
            <param name="apertureHeight">Physical height of the sensor.</param>
            <param name="fovx">Output field of view in degrees along the horizontal sensor axis.</param>
            <param name="fovy">Output field of view in degrees along the vertical sensor axis.</param>
            <param name="focalLength">Focal length of the lens in mm.</param>
            <param name="principalPoint">Principal point in pixels.</param>
            <param name="aspectRatio">fy / fx</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalibrationMatrixValues(System.Double[0:,0:],ST4IVisionCoreNet.Size,System.Double,System.Double,System.Double@,System.Double@,System.Double@,ST4IVisionCoreNet.Point2d@,System.Double@)">
            <summary>
            computes several useful camera characteristics from the camera matrix, camera frame resolution and the physical sensor size.
            </summary>
            <param name="cameraMatrix">Input camera matrix that can be estimated by calibrateCamera() or stereoCalibrate() .</param>
            <param name="imageSize">Input image size in pixels.</param>
            <param name="apertureWidth">Physical width of the sensor.</param>
            <param name="apertureHeight">Physical height of the sensor.</param>
            <param name="fovx">Output field of view in degrees along the horizontal sensor axis.</param>
            <param name="fovy">Output field of view in degrees along the vertical sensor axis.</param>
            <param name="focalLength">Focal length of the lens in mm.</param>
            <param name="principalPoint">Principal point in pixels.</param>
            <param name="aspectRatio">fy / fx</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StereoCalibrate(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.InputArray},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.InputArray},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.InputArray},ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.CalibrationFlags,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            finds intrinsic and extrinsic parameters of a stereo camera
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points.</param>
            <param name="imagePoints1">Vector of vectors of the projections of the calibration pattern points, observed by the first camera.</param>
            <param name="imagePoints2">Vector of vectors of the projections of the calibration pattern points, observed by the second camera.</param>
            <param name="cameraMatrix1">Input/output first camera matrix</param>
            <param name="distCoeffs1">Input/output vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            The output vector length depends on the flags.</param>
            <param name="cameraMatrix2"> Input/output second camera matrix. The parameter is similar to cameraMatrix1 .</param>
            <param name="distCoeffs2">Input/output lens distortion coefficients for the second camera. The parameter is similar to distCoeffs1 .</param>
            <param name="imageSize">Size of the image used only to initialize intrinsic camera matrix.</param>
            <param name="R">Output rotation matrix between the 1st and the 2nd camera coordinate systems.</param>
            <param name="T">Output translation vector between the coordinate systems of the cameras.</param>
            <param name="E">Output essential matrix.</param>
            <param name="F">Output fundamental matrix.</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <param name="flags">Different flags that may be zero or a combination of the CalibrationFlag values</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StereoCalibrate(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f}},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f}},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f}},System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Double[],ST4IVisionCoreNet.Size,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.CalibrationFlags,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            finds intrinsic and extrinsic parameters of a stereo camera
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points.</param>
            <param name="imagePoints1">Vector of vectors of the projections of the calibration pattern points, observed by the first camera.</param>
            <param name="imagePoints2">Vector of vectors of the projections of the calibration pattern points, observed by the second camera.</param>
            <param name="cameraMatrix1">Input/output first camera matrix</param>
            <param name="distCoeffs1">Input/output vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            The output vector length depends on the flags.</param>
            <param name="cameraMatrix2"> Input/output second camera matrix. The parameter is similar to cameraMatrix1 .</param>
            <param name="distCoeffs2">Input/output lens distortion coefficients for the second camera. The parameter is similar to distCoeffs1 .</param>
            <param name="imageSize">Size of the image used only to initialize intrinsic camera matrix.</param>
            <param name="R">Output rotation matrix between the 1st and the 2nd camera coordinate systems.</param>
            <param name="T">Output translation vector between the coordinate systems of the cameras.</param>
            <param name="E">Output essential matrix.</param>
            <param name="F">Output fundamental matrix.</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <param name="flags">Different flags that may be zero or a combination of the CalibrationFlag values</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StereoRectify(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.StereoRectificationFlags,System.Double,System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            computes the rectification transformation for a stereo camera from its intrinsic and extrinsic parameters
            </summary>
            <param name="cameraMatrix1">First camera matrix.</param>
            <param name="distCoeffs1">First camera distortion parameters.</param>
            <param name="cameraMatrix2">Second camera matrix.</param>
            <param name="distCoeffs2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="T">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2"> Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D() ).</param>
            <param name="flags">Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY. 
            If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="alpha">Free scaling parameter. 
            If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. 
            alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). 
            alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained 
            in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap(). When (0,0) is passed (default), it is set to the original imageSize . 
            Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StereoRectify(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.StereoRectificationFlags,System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Rect@,ST4IVisionCoreNet.Rect@)">
            <summary>
            computes the rectification transformation for a stereo camera from its intrinsic and extrinsic parameters
            </summary>
            <param name="cameraMatrix1">First camera matrix.</param>
            <param name="distCoeffs1">First camera distortion parameters.</param>
            <param name="cameraMatrix2">Second camera matrix.</param>
            <param name="distCoeffs2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="T">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2"> Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D() ).</param>
            <param name="flags">Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY. 
            If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="alpha">Free scaling parameter. 
            If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. 
            alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). 
            alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained 
            in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap(). When (0,0) is passed (default), it is set to the original imageSize . 
            Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
            <param name="validPixROI1">Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. 
            Otherwise, they are likely to be smaller.</param>
            <param name="validPixROI2">Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. 
            Otherwise, they are likely to be smaller.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StereoRectify(System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Double[],ST4IVisionCoreNet.Size,System.Double[0:,0:],System.Double[],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,ST4IVisionCoreNet.StereoRectificationFlags,System.Double,System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            computes the rectification transformation for a stereo camera from its intrinsic and extrinsic parameters
            </summary>
            <param name="cameraMatrix1">First camera matrix.</param>
            <param name="distCoeffs1">First camera distortion parameters.</param>
            <param name="cameraMatrix2">Second camera matrix.</param>
            <param name="distCoeffs2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="T">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2"> Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D() ).</param>
            <param name="flags">Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY. 
            If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="alpha">Free scaling parameter. 
            If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. 
            alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). 
            alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained 
            in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap(). When (0,0) is passed (default), it is set to the original imageSize . 
            Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StereoRectify(System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Double[],ST4IVisionCoreNet.Size,System.Double[0:,0:],System.Double[],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,ST4IVisionCoreNet.StereoRectificationFlags,System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Rect@,ST4IVisionCoreNet.Rect@)">
            <summary>
            computes the rectification transformation for a stereo camera from its intrinsic and extrinsic parameters
            </summary>
            <param name="cameraMatrix1">First camera matrix.</param>
            <param name="distCoeffs1">First camera distortion parameters.</param>
            <param name="cameraMatrix2">Second camera matrix.</param>
            <param name="distCoeffs2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="T">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2"> Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D() ).</param>
            <param name="flags">Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY. 
            If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="alpha">Free scaling parameter. 
            If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. 
            alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). 
            alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained 
            in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap(). When (0,0) is passed (default), it is set to the original imageSize . 
            Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
            <param name="validPixROI1">Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. 
            Otherwise, they are likely to be smaller.</param>
            <param name="validPixROI2">Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. 
            Otherwise, they are likely to be smaller.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StereoRectifyUncalibrated(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Double)">
            <summary>
            computes the rectification transformation for an uncalibrated stereo camera (zero distortion is assumed)
            </summary>
            <param name="points1">Array of feature points in the first image.</param>
            <param name="points2">The corresponding points in the second image. 
            The same formats as in findFundamentalMat() are supported.</param>
            <param name="F">Input fundamental matrix. It can be computed from the same set 
            of point pairs using findFundamentalMat() .</param>
            <param name="imgSize">Size of the image.</param>
            <param name="H1">Output rectification homography matrix for the first image.</param>
            <param name="H2">Output rectification homography matrix for the second image.</param>
            <param name="threshold">Optional threshold used to filter out the outliers. 
            If the parameter is greater than zero, all the point pairs that do not comply 
            with the epipolar geometry (that is, the points for which |points2[i]^T * F * points1[i]| > threshold ) 
            are rejected prior to computing the homographies. Otherwise, all the points are considered inliers.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StereoRectifyUncalibrated(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},System.Double[0:,0:],ST4IVisionCoreNet.Size,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double)">
            <summary>
            computes the rectification transformation for an uncalibrated stereo camera (zero distortion is assumed)
            </summary>
            <param name="points1">Array of feature points in the first image.</param>
            <param name="points2">The corresponding points in the second image. 
            The same formats as in findFundamentalMat() are supported.</param>
            <param name="F">Input fundamental matrix. It can be computed from the same set 
            of point pairs using findFundamentalMat() .</param>
            <param name="imgSize">Size of the image.</param>
            <param name="H1">Output rectification homography matrix for the first image.</param>
            <param name="H2">Output rectification homography matrix for the second image.</param>
            <param name="threshold">Optional threshold used to filter out the outliers. 
            If the parameter is greater than zero, all the point pairs that do not comply 
            with the epipolar geometry (that is, the points for which |points2[i]^T * F * points1[i]| > threshold ) 
            are rejected prior to computing the homographies. Otherwise, all the points are considered inliers.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rectify3Collinear(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.InputArray},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.InputArray},ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Rect@,ST4IVisionCoreNet.Rect@,ST4IVisionCoreNet.StereoRectificationFlags)">
            <summary>
            computes the rectification transformations for 3-head camera, where all the heads are on the same line.
            </summary>
            <param name="cameraMatrix1"></param>
            <param name="distCoeffs1"></param>
            <param name="cameraMatrix2"></param>
            <param name="distCoeffs2"></param>
            <param name="cameraMatrix3"></param>
            <param name="distCoeffs3"></param>
            <param name="imgpt1"></param>
            <param name="imgpt3"></param>
            <param name="imageSize"></param>
            <param name="R12"></param>
            <param name="T12"></param>
            <param name="R13"></param>
            <param name="T13"></param>
            <param name="R1"></param>
            <param name="R2"></param>
            <param name="R3"></param>
            <param name="P1"></param>
            <param name="P2"></param>
            <param name="P3"></param>
            <param name="Q"></param>
            <param name="alpha"></param>
            <param name="newImgSize"></param>
            <param name="roi1"></param>
            <param name="roi2"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetOptimalNewCameraMatrix(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Rect@,System.Boolean)">
            <summary>
            Returns the new camera matrix based on the free scaling parameter.
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the array is null, the zero distortion coefficients are assumed.</param>
            <param name="imageSize">Original image size.</param>
            <param name="alpha">Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) 
            and 1 (when all the source image pixels are retained in the undistorted image). </param>
            <param name="newImgSize">Image size after rectification. By default,it is set to imageSize .</param>
            <param name="validPixROI">Optional output rectangle that outlines all-good-pixels region in the undistorted image. See roi1, roi2 description in stereoRectify() .</param>
            <param name="centerPrincipalPoint">Optional flag that indicates whether in the new camera matrix the principal point 
            should be at the image center or not. By default, the principal point is chosen to best fit a 
            subset of the source image (determined by alpha) to the corrected image.</param>
            <returns>optimal new camera matrix</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetOptimalNewCameraMatrix(System.Double[0:,0:],System.Double[],ST4IVisionCoreNet.Size,System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Rect@,System.Boolean)">
            <summary>
            Returns the new camera matrix based on the free scaling parameter.
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the array is null, the zero distortion coefficients are assumed.</param>
            <param name="imageSize">Original image size.</param>
            <param name="alpha">Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) 
            and 1 (when all the source image pixels are retained in the undistorted image). </param>
            <param name="newImgSize">Image size after rectification. By default,it is set to imageSize .</param>
            <param name="validPixROI">Optional output rectangle that outlines all-good-pixels region in the undistorted image. See roi1, roi2 description in stereoRectify() .</param>
            <param name="centerPrincipalPoint">Optional flag that indicates whether in the new camera matrix the principal point 
            should be at the image center or not. By default, the principal point is chosen to best fit a 
            subset of the source image (determined by alpha) to the corrected image.</param>
            <returns>optimal new camera matrix</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalibrateHandEye(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.HandEyeCalibrationMethod)">
             <summary>
             Computes Hand-Eye calibration.
             
             The function performs the Hand-Eye calibration using various methods. One approach consists in estimating the
             rotation then the translation(separable solutions) and the following methods are implemented:
             - R.Tsai, R.Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration \cite Tsai89
             - F.Park, B.Martin Robot Sensor Calibration: Solving AX = XB on the Euclidean Group \cite Park94
             - R.Horaud, F.Dornaika Hand-Eye Calibration \cite Horaud95
            
             Another approach consists in estimating simultaneously the rotation and the translation(simultaneous solutions),
             with the following implemented method:
             - N.Andreff, R.Horaud, B.Espiau On-line Hand-Eye Calibration \cite Andreff99
             - K.Daniilidis Hand-Eye Calibration Using Dual Quaternions \cite Daniilidis98
             </summary>
             <param name="R_gripper2base">Rotation part extracted from the homogeneous matrix that
             transforms a pointexpressed in the gripper frame to the robot base frame that contains the rotation
             matrices for all the transformationsfrom gripper frame to robot base frame.</param>
             <param name="t_gripper2base">Translation part extracted from the homogeneous matrix that transforms a point
             expressed in the gripper frame to the robot base frame.
             This is a vector(`vector&lt;Mat&gt;`) that contains the translation vectors for all the transformations
             from gripper frame to robot base frame.</param>
             <param name="R_target2cam">Rotation part extracted from the homogeneous matrix that transforms a point
             expressed in the target frame to the camera frame.
             This is a vector(`vector&lt;Mat&gt;`) that contains the rotation matrices for all the transformations
             from calibration target frame to camera frame.</param>
             <param name="t_target2cam">Rotation part extracted from the homogeneous matrix that transforms a point
             expressed in the target frame to the camera frame.
             This is a vector(`vector&lt;Mat&gt;`) that contains the translation vectors for all the transformations
             from calibration target frame to camera frame.</param>
             <param name="R_cam2gripper">Estimated rotation part extracted from the homogeneous matrix that transforms a point
             expressed in the camera frame to the gripper frame.</param>
             <param name="t_cam2gripper">Estimated translation part extracted from the homogeneous matrix that transforms a point
             expressed in the camera frame to the gripper frame.</param>
             <param name="method">One of the implemented Hand-Eye calibration method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalibrateRobotWorldHandEye(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.RobotWorldHandEyeCalibrationMethod)">
            <summary>
            Computes Robot-World/Hand-Eye calibration.
            The function performs the Robot-World/Hand-Eye calibration using various methods. One approach consists in estimating the
            rotation then the translation(separable solutions):
            - M.Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product \cite Shah2013SolvingTR
            </summary>
            <param name="R_world2cam">[in] R_world2cam Rotation part extracted from the homogeneous matrix that transforms a point
            expressed in the world frame to the camera frame. This is a vector of Mat that contains the rotation,
            `(3x3)` rotation matrices or `(3x1)` rotation vectors,for all the transformations from world frame to the camera frame.</param>
            <param name="t_world2cam">[in] Translation part extracted from the homogeneous matrix that transforms a point
            expressed in the world frame to the camera frame. This is a vector (`vector&lt;Mat&gt;`) that contains the `(3x1)`
            translation vectors for all the transformations from world frame to the camera frame.</param>
            <param name="R_base2gripper">[in] Rotation part extracted from the homogeneous matrix that transforms a point expressed
            in the robot base frame to the gripper frame. This is a vector (`vector&lt;Mat&gt;`) that contains the rotation,
            `(3x3)` rotation matrices or `(3x1)` rotation vectors, for all the transformations from robot base frame to the gripper frame.</param>
            <param name="t_base2gripper">[in] Rotation part extracted from the homogeneous matrix that transforms a point
            expressed in the robot base frame to the gripper frame. This is a vector (`vector&lt;Mat&gt;`) that contains the
            `(3x1)` translation vectors for all the transformations from robot base frame to the gripper frame.</param>
            <param name="R_base2world">[out] R_base2world Estimated `(3x3)` rotation part extracted from the homogeneous matrix
            that transforms a point expressed in the robot base frame to the world frame.</param>
            <param name="t_base2world">[out] t_base2world Estimated `(3x1)` translation part extracted from the homogeneous matrix
            that transforms a point expressed in the robot base frame to the world frame.</param>
            <param name="R_gripper2cam">[out] R_gripper2cam Estimated `(3x3)` rotation part extracted from the homogeneous matrix
            that transforms a point expressed in the gripper frame to the camera frame.</param>
            <param name="t_gripper2cam">[out] Estimated `(3x1)` translation part extracted from the homogeneous matrix that
            transforms a pointexpressed in the gripper frame to the camera frame.</param>
            <param name="method">One of the implemented Robot-World/Hand-Eye calibration method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalibrateRobotWorldHandEye(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Double[0:,0:]@,System.Double[]@,System.Double[0:,0:]@,System.Double[]@,ST4IVisionCoreNet.RobotWorldHandEyeCalibrationMethod)">
            <summary>
            omputes Robot-World/Hand-Eye calibration.
            The function performs the Robot-World/Hand-Eye calibration using various methods. One approach consists in estimating the
            rotation then the translation(separable solutions):
            - M.Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product \cite Shah2013SolvingTR
            </summary>
            <param name="R_world2cam">[in] R_world2cam Rotation part extracted from the homogeneous matrix that transforms a point
            expressed in the world frame to the camera frame. This is a vector of Mat that contains the rotation,
            `(3x3)` rotation matrices or `(3x1)` rotation vectors,for all the transformations from world frame to the camera frame.</param>
            <param name="t_world2cam">[in] Translation part extracted from the homogeneous matrix that transforms a point
            expressed in the world frame to the camera frame. This is a vector (`vector&lt;Mat&gt;`) that contains the `(3x1)`
            translation vectors for all the transformations from world frame to the camera frame.</param>
            <param name="R_base2gripper">[in] Rotation part extracted from the homogeneous matrix that transforms a point expressed
            in the robot base frame to the gripper frame. This is a vector (`vector&lt;Mat&gt;`) that contains the rotation,
            `(3x3)` rotation matrices or `(3x1)` rotation vectors, for all the transformations from robot base frame to the gripper frame.</param>
            <param name="t_base2gripper">[in] Rotation part extracted from the homogeneous matrix that transforms a point
            expressed in the robot base frame to the gripper frame. This is a vector (`vector&lt;Mat&gt;`) that contains the
            `(3x1)` translation vectors for all the transformations from robot base frame to the gripper frame.</param>
            <param name="R_base2world">[out] R_base2world Estimated `(3x3)` rotation part extracted from the homogeneous matrix
            that transforms a point expressed in the robot base frame to the world frame.</param>
            <param name="t_base2world">[out] t_base2world Estimated `(3x1)` translation part extracted from the homogeneous matrix
            that transforms a point expressed in the robot base frame to the world frame.</param>
            <param name="R_gripper2cam">[out] R_gripper2cam Estimated `(3x3)` rotation part extracted from the homogeneous matrix
            that transforms a point expressed in the gripper frame to the camera frame.</param>
            <param name="t_gripper2cam">[out] Estimated `(3x1)` translation part extracted from the homogeneous matrix that
            transforms a pointexpressed in the gripper frame to the camera frame.</param>
            <param name="method">One of the implemented Robot-World/Hand-Eye calibration method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertPointsToHomogeneous(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            converts point coordinates from normal pixel coordinates to homogeneous coordinates ((x,y)->(x,y,1))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N+1-dimensional points.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertPointsToHomogeneous(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec2f})">
            <summary>
            converts point coordinates from normal pixel coordinates to homogeneous coordinates ((x,y)->(x,y,1))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <returns>Output vector of N+1-dimensional points.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertPointsToHomogeneous(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec3f})">
            <summary>
            converts point coordinates from normal pixel coordinates to homogeneous coordinates ((x,y)->(x,y,1))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <returns>Output vector of N+1-dimensional points.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertPointsFromHomogeneous(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            converts point coordinates from homogeneous to normal pixel coordinates ((x,y,z)->(x/z, y/z))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N-1-dimensional points.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertPointsFromHomogeneous(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec3f})">
            <summary>
            converts point coordinates from homogeneous to normal pixel coordinates ((x,y,z)->(x/z, y/z))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <returns>Output vector of N-1-dimensional points.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertPointsFromHomogeneous(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec4f})">
            <summary>
            converts point coordinates from homogeneous to normal pixel coordinates ((x,y,z)->(x/z, y/z))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <returns>Output vector of N-1-dimensional points.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertPointsHomogeneous(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Converts points to/from homogeneous coordinates.
            </summary>
            <param name="src">Input array or vector of 2D, 3D, or 4D points.</param>
            <param name="dst">Output vector of 2D, 3D, or 4D points.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindFundamentalMat(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.FundamentalMatMethods,System.Double,System.Double,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates a fundamental matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N points from the first image. 
            The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 .</param>
            <param name="method">Method for computing a fundamental matrix.</param>
            <param name="param1">Parameter used for RANSAC. 
            It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is 
            considered an outlier and is not used for computing the final fundamental matrix. It can be set to 
            something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="param2">Parameter used for the RANSAC or LMedS methods only. 
            It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and 
            to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. For other methods, it is set to all 1’s.</param>
            <returns>fundamental matrix</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindFundamentalMat(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.FundamentalMatMethods,System.Double,System.Double,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates a fundamental matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N points from the first image. 
            The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 .</param>
            <param name="method">Method for computing a fundamental matrix.</param>
            <param name="param1">Parameter used for RANSAC. 
            It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is 
            considered an outlier and is not used for computing the final fundamental matrix. It can be set to 
            something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="param2">Parameter used for the RANSAC or LMedS methods only. 
            It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and 
            to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. For other methods, it is set to all 1’s.</param>
            <returns>fundamental matrix</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindFundamentalMat(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},ST4IVisionCoreNet.FundamentalMatMethods,System.Double,System.Double,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates a fundamental matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N points from the first image. 
            The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 .</param>
            <param name="method">Method for computing a fundamental matrix.</param>
            <param name="param1">Parameter used for RANSAC. 
            It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is 
            considered an outlier and is not used for computing the final fundamental matrix. It can be set to 
            something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="param2">Parameter used for the RANSAC or LMedS methods only. 
            It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and 
            to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. For other methods, it is set to all 1’s.</param>
            <returns>fundamental matrix</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ComputeCorrespondEpilines(ST4IVisionCoreNet.InputArray,System.Int32,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            For points in an image of a stereo pair, computes the corresponding epilines in the other image.
            </summary>
            <param name="points">Input points. N \times 1 or 1 x N matrix of type CV_32FC2 or CV_64FC2.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points .</param>
            <param name="F">Fundamental matrix that can be estimated using findFundamentalMat() or stereoRectify() .</param>
            <param name="lines">Output vector of the epipolar lines corresponding to the points in the other image.
             Each line ax + by + c=0 is encoded by 3 numbers (a, b, c) .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ComputeCorrespondEpilines(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},System.Int32,System.Double[0:,0:])">
            <summary>
            For points in an image of a stereo pair, computes the corresponding epilines in the other image.
            </summary>
            <param name="points">Input points. N \times 1 or 1 x N matrix of type CV_32FC2 or CV_64FC2.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points .</param>
            <param name="F">Fundamental matrix that can be estimated using findFundamentalMat() or stereoRectify() .</param>
            <returns>Output vector of the epipolar lines corresponding to the points in the other image.
             Each line ax + by + c=0 is encoded by 3 numbers (a, b, c) .</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ComputeCorrespondEpilines(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3d},System.Int32,System.Double[0:,0:])">
            <summary>
            For points in an image of a stereo pair, computes the corresponding epilines in the other image.
            </summary>
            <param name="points">Input points. N \times 1 or 1 x N matrix of type CV_32FC2 or CV_64FC2.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points .</param>
            <param name="F">Fundamental matrix that can be estimated using findFundamentalMat() or stereoRectify() .</param>
            <returns>Output vector of the epipolar lines corresponding to the points in the other image.
             Each line ax + by + c=0 is encoded by 3 numbers (a, b, c) .</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.TriangulatePoints(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Reconstructs points by triangulation.
            </summary>
            <param name="projMatr1">3x4 projection matrix of the first camera.</param>
            <param name="projMatr2">3x4 projection matrix of the second camera.</param>
            <param name="projPoints1">2xN array of feature points in the first image. In case of c++ version 
            it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="projPoints2">2xN array of corresponding points in the second image. In case of c++ version 
            it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="points4D">4xN array of reconstructed points in homogeneous coordinates.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.TriangulatePoints(System.Double[0:,0:],System.Double[0:,0:],System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d})">
            <summary>
            Reconstructs points by triangulation.
            </summary>
            <param name="projMatr1">3x4 projection matrix of the first camera.</param>
            <param name="projMatr2">3x4 projection matrix of the second camera.</param>
            <param name="projPoints1">2xN array of feature points in the first image. In case of c++ version 
            it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="projPoints2">2xN array of corresponding points in the second image. In case of c++ version 
            it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <returns>4xN array of reconstructed points in homogeneous coordinates.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CorrectMatches(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Refines coordinates of corresponding points.
            </summary>
            <param name="F">3x3 fundamental matrix.</param>
            <param name="points1">1xN array containing the first set of points.</param>
            <param name="points2">1xN array containing the second set of points.</param>
            <param name="newPoints1">The optimized points1.</param>
            <param name="newPoints2">The optimized points2.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CorrectMatches(System.Double[0:,0:],System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},ST4IVisionCoreNet.Point2d[]@,ST4IVisionCoreNet.Point2d[]@)">
            <summary>
            Refines coordinates of corresponding points.
            </summary>
            <param name="F">3x3 fundamental matrix.</param>
            <param name="points1">1xN array containing the first set of points.</param>
            <param name="points2">1xN array containing the second set of points.</param>
            <param name="newPoints1">The optimized points1.</param>
            <param name="newPoints2">The optimized points2.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RecoverPose(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputOutputArray)">
            <summary>
            Recover relative camera rotation and translation from an estimated essential matrix and the corresponding points in two images, using cheirality check.
            Returns the number of inliers which pass the check.
            </summary>
            <param name="E">The input essential matrix.</param>
            <param name="points1">Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1.</param>
            <param name="cameraMatrix">Camera matrix K=⎡⎣⎢fx000fy0cxcy1⎤⎦⎥ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix.</param>
            <param name="R">Recovered relative rotation.</param>
            <param name="t">Recovered relative translation.</param>
            <param name="mask">Input/output mask for inliers in points1 and points2. :
            If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E.
            Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check.
            This function decomposes an essential matrix using decomposeEssentialMat and then verifies possible pose hypotheses by doing cheirality check.
            The cheirality check basically means that the triangulated 3D points should have positive depth.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RecoverPose(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Double,ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.InputOutputArray)">
            <summary>
            Recover relative camera rotation and translation from an estimated essential matrix and the corresponding points in two images, using cheirality check.
            Returns the number of inliers which pass the check.
            </summary>
            <param name="E">The input essential matrix.</param>
            <param name="points1">Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1.</param>
            <param name="R">Recovered relative rotation.</param>
            <param name="t">Recovered relative translation.</param>
            <param name="focal">Focal length of the camera. Note that this function assumes that points1 and points2 are feature points from cameras with same focal length and principal point.</param>
            <param name="pp">principal point of the camera.</param>
            <param name="mask">Input/output mask for inliers in points1 and points2. :
            If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E.
            Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check.
            This function decomposes an essential matrix using decomposeEssentialMat and then verifies possible pose hypotheses by doing cheirality check.
            The cheirality check basically means that the triangulated 3D points should have positive depth.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RecoverPose(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Double,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Recover relative camera rotation and translation from an estimated essential matrix and the corresponding points in two images, using cheirality check.
            Returns the number of inliers which pass the check.
            </summary>
            <param name="E">The input essential matrix.</param>
            <param name="points1">Array of N 2D points from the first image. The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1.</param>
            <param name="cameraMatrix">Camera matrix K=⎡⎣⎢fx000fy0cxcy1⎤⎦⎥ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix.</param>
            <param name="R">Recovered relative rotation.</param>
            <param name="t">Recovered relative translation.</param>
            <param name="distanceTresh">threshold distance which is used to filter out far away points (i.e. infinite points).</param>
            <param name="mask">Input/output mask for inliers in points1 and points2. :
            If it is not empty, then it marks inliers in points1 and points2 for then given essential matrix E.
            Only these inliers will be used to recover pose. In the output mask only inliers which pass the cheirality check.
            This function decomposes an essential matrix using decomposeEssentialMat and then verifies possible pose hypotheses by doing cheirality check.
            The cheirality check basically means that the triangulated 3D points should have positive depth.</param>
            <param name="triangulatedPoints">3d points which were reconstructed by triangulation.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindEssentialMat(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.EssentialMatMethod,System.Double,System.Double,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates an essential matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N (N >= 5) 2D points from the first image.
            The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 .</param>
            <param name="cameraMatrix">Camera matrix K=⎡⎣⎢fx000fy0cxcy1⎤⎦⎥ . Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix.</param>
            <param name="method">Method for computing an essential matrix.
            RANSAC for the RANSAC algorithm.
            LMEDS for the LMedS algorithm.</param>
            <param name="prob">Parameter used for the RANSAC or LMedS methods only.
            It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="threshold">Parameter used for RANSAC.
            It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix.
            It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods.</param>
            <returns>essential matrix</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindEssentialMat(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Double,ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.EssentialMatMethod,System.Double,System.Double,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates an essential matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N (N >= 5) 2D points from the first image.
            The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image por LMedS methods only.
            It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="threshold">Parameter used for RANSAC.
            It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix.
            It can be set to something like 1-3, depending on ints of the same size and format as points1 .</param>
            <param name="focal">Focal length of the camera. Note that this function assumes that points1 and points2 are feature points from cameras with same focal length and principal point.</param>
            <param name="pp">principal point of the camera.</param>
            <param name="method">Method for computing an essential matrix.
            RANSAC for the RANSAC algorithm.
            LMEDS for the LMedS algorithm.</param>
            <param name="prob">Parameter used for the RANSAC othe accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods.</param>
            <returns>essential matrix</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FilterSpeckles(ST4IVisionCoreNet.InputOutputArray,System.Double,System.Int32,System.Double,ST4IVisionCoreNet.InputOutputArray)">
            <summary>
            filters off speckles (small regions of incorrectly computed disparity)
            </summary>
            <param name="img">The input 16-bit signed disparity image</param>
            <param name="newVal">The disparity value used to paint-off the speckles</param>
            <param name="maxSpeckleSize">The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm</param>
            <param name="maxDiff">Maximum difference between neighbor disparity pixels to put them into the same blob. 
            Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point disparity map, where disparity values 
            are multiplied by 16, this scale factor should be taken into account when specifying this parameter value.</param>
            <param name="buf">The optional temporary buffer to avoid memory allocation within the function.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetValidDisparityROI(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Rect,System.Int32,System.Int32,System.Int32)">
            <summary>
            computes valid disparity ROI from the valid ROIs of the rectified images (that are returned by cv::stereoRectify())
            </summary>
            <param name="roi1"></param>
            <param name="roi2"></param>
            <param name="minDisparity"></param>
            <param name="numberOfDisparities"></param>
            <param name="SADWindowSize"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ValidateDisparity(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            validates disparity using the left-right check. The matrix "cost" should be computed by the stereo correspondence algorithm
            </summary>
            <param name="disparity"></param>
            <param name="cost"></param>
            <param name="minDisparity"></param>
            <param name="numberOfDisparities"></param>
            <param name="disp12MaxDisp"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ReprojectImageTo3D(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Boolean,System.Int32)">
            <summary>
            reprojects disparity image to 3D: (x,y,d)->(X,Y,Z) using the matrix Q returned by cv::stereoRectify
            </summary>
            <param name="disparity">Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit floating-point disparity image.</param>
            <param name="_3dImage">Output 3-channel floating-point image of the same size as disparity. 
            Each element of _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map.</param>
            <param name="Q">4 x 4 perspective transformation matrix that can be obtained with stereoRectify().</param>
            <param name="handleMissingValues">Indicates, whether the function should handle missing values (i.e. points where the disparity was not computed). 
            If handleMissingValues=true, then pixels with the minimal disparity that corresponds to the outliers (see StereoBM::operator() ) are 
            transformed to 3D points with a very large Z value (currently set to 10000).</param>
            <param name="ddepth">he optional output array depth. If it is -1, the output image will have CV_32F depth. 
            ddepth can also be set to CV_16S, CV_32S or CV_32F.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EstimateAffine3D(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double)">
            <summary>
            Computes an optimal affine transformation between two 3D point sets.
            </summary>
            <param name="src">First input 3D point set.</param>
            <param name="dst">Second input 3D point set.</param>
            <param name="outVal">Output 3D affine transformation matrix 3 x 4 .</param>
            <param name="inliers">Output vector indicating which points are inliers.</param>
            <param name="ransacThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. 
            Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. 
            Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SampsonDistance(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Calculates the Sampson Distance between two points.
            </summary>
            <param name="pt1">first homogeneous 2d point</param>
            <param name="pt2">second homogeneous 2d point</param>
            <param name="f">F fundamental matrix</param>
            <returns>The computed Sampson distance.</returns>
            <remarks>https://github.com/opencv/opencv/blob/master/modules/calib3d/src/fundam.cpp#L1109</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SampsonDistance(ST4IVisionCoreNet.Point3d,ST4IVisionCoreNet.Point3d,System.Double[0:,0:])">
            <summary>
            Calculates the Sampson Distance between two points.
            </summary>
            <param name="pt1">first homogeneous 2d point</param>
            <param name="pt2">second homogeneous 2d point</param>
            <param name="f">F fundamental matrix</param>
            <returns>The computed Sampson distance.</returns>
            <remarks>https://github.com/opencv/opencv/blob/master/modules/calib3d/src/fundam.cpp#L1109</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EstimateAffine2D(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.RobustEstimationAlgorithms,System.Double,System.UInt64,System.Double,System.UInt64)">
            <summary>
            Computes an optimal affine transformation between two 2D point sets.
            </summary>
            <param name="from">First input 2D point set containing (X,Y).</param>
            <param name="to">Second input 2D point set containing (x,y).</param>
            <param name="inliers">Output vector indicating which points are inliers (1-inlier, 0-outlier).</param>
            <param name="method">Robust method used to compute transformation.</param>
            <param name="ransacReprojThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.Applies only to RANSAC.</param>
            <param name="maxIters">The maximum number of robust method iterations.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation.
            Anything between 0.95 and 0.99 is usually good enough.Values too close to 1 can slow down the estimation
            significantly.Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <param name="refineIters">Maximum number of iterations of refining algorithm (Levenberg-Marquardt).
            Passing 0 will disable refining, so the output matrix will be output of robust method.</param>
            <returns>Output 2D affine transformation matrix \f$2 \times 3\f$ or empty matrix if transformation could not be estimated.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EstimateAffinePartial2D(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.RobustEstimationAlgorithms,System.Double,System.UInt64,System.Double,System.UInt64)">
            <summary>
            Computes an optimal limited affine transformation with 4 degrees of freedom between two 2D point sets.
            </summary>
            <param name="from">First input 2D point set.</param>
            <param name="to">Second input 2D point set.</param>
            <param name="inliers">Output vector indicating which points are inliers.</param>
            <param name="method">Robust method used to compute transformation. </param>
            <param name="ransacReprojThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.Applies only to RANSAC.</param>
            <param name="maxIters">The maximum number of robust method iterations.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation.
            Anything between 0.95 and 0.99 is usually good enough.Values too close to 1 can slow down the estimation 
            significantly.Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <param name="refineIters"></param>
            <returns>Output 2D affine transformation (4 degrees of freedom) matrix 2x3 or empty matrix if transformation could not be estimated.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DecomposeHomographyMat(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Mat[]@,ST4IVisionCoreNet.Mat[]@,ST4IVisionCoreNet.Mat[]@)">
            <summary>
            Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).
            </summary>
            <param name="h">The input homography matrix between two images.</param>
            <param name="k">The input intrinsic camera calibration matrix.</param>
            <param name="rotations">Array of rotation matrices.</param>
            <param name="translations">Array of translation matrices.</param>
            <param name="normals">Array of plane normal matrices.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FilterHomographyDecompByVisibleRefpoints(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Filters homography decompositions based on additional information.
            </summary>
            <param name="rotations">Vector of rotation matrices.</param>
            <param name="normals">Vector of plane normal matrices.</param>
            <param name="beforePoints">Vector of (rectified) visible reference points before the homography is applied</param>
            <param name="afterPoints">Vector of (rectified) visible reference points after the homography is applied</param>
            <param name="possibleSolutions">Vector of int indices representing the viable solution set after filtering</param>
            <param name="pointsMask">optional Mat/Vector of 8u type representing the mask for the inliers as given by the findHomography function</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Undistort(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            corrects lens distortion for the given camera matrix and distortion coefficients
            </summary>
            <param name="src">Input (distorted) image.</param>
            <param name="dst">Output (corrected) image that has the same size and type as src .</param>
            <param name="cameraMatrix"> Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, 
            or 8 elements. If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="newCameraMatrix">Camera matrix of the distorted image. 
            By default, it is the same as cameraMatrix but you may additionally scale 
            and shift the result by using a different matrix.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InitUndistortRectifyMap(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            initializes maps for cv::remap() to correct lens distortion and optionally rectify the image
            </summary>
            <param name="cameraMatrix"></param>
            <param name="distCoeffs"></param>
            <param name="r"></param>
            <param name="newCameraMatrix"></param>
            <param name="size"></param>
            <param name="m1Type"></param>
            <param name="map1"></param>
            <param name="map2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InitWideAngleProjMap(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,System.Int32,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ProjectionType,System.Double)">
            <summary>
            initializes maps for cv::remap() for wide-angle
            </summary>
            <param name="cameraMatrix"></param>
            <param name="distCoeffs"></param>
            <param name="imageSize"></param>
            <param name="destImageWidth"></param>
            <param name="m1Type"></param>
            <param name="map1"></param>
            <param name="map2"></param>
            <param name="projType"></param>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetDefaultNewCameraMatrix(ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Size},System.Boolean)">
            <summary>
            returns the default new camera matrix (by default it is the same as cameraMatrix unless centerPricipalPoint=true)
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="imgSize">Camera view image size in pixels.</param>
            <param name="centerPrincipalPoint">Location of the principal point in the new camera matrix. 
            The parameter indicates whether this location should be at the image center or not.</param>
            <returns>the camera matrix that is either an exact copy of the input cameraMatrix 
            (when centerPrinicipalPoint=false), or the modified one (when centerPrincipalPoint=true).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.UndistortPoints(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes the ideal point coordinates from the observed point coordinates.
            </summary>
            <param name="src">Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).</param>
            <param name="dst">Output ideal point coordinates after undistortion and reverse perspective transformation. 
            If matrix P is identity or omitted, dst will contain normalized point coordinates.</param>
            <param name="cameraMatrix">Camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="r">Rectification transformation in the object space (3x3 matrix). 
            R1 or R2 computed by stereoRectify() can be passed here. 
            If the matrix is empty, the identity transformation is used.</param>
            <param name="p">New camera matrix (3x3) or new projection matrix (3x4). 
            P1 or P2 computed by stereoRectify() can be passed here. If the matrix is empty, 
            the identity new camera matrix is used.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.UndistortPointsIter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            Computes the ideal point coordinates from the observed point coordinates.
            </summary>
            <param name="src">Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).</param>
            <param name="dst">Output ideal point coordinates after undistortion and reverse perspective transformation. 
            If matrix P is identity or omitted, dst will contain normalized point coordinates.</param>
            <param name="cameraMatrix">Camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="r">Rectification transformation in the object space (3x3 matrix). 
            R1 or R2 computed by stereoRectify() can be passed here. 
            If the matrix is empty, the identity transformation is used.</param>
            <param name="p">New camera matrix (3x3) or new projection matrix (3x4). 
            P1 or P2 computed by stereoRectify() can be passed here. If the matrix is empty, 
            the identity new camera matrix is used.</param>
            <param name="termCriteria"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Sv.FishEye">
            <summary>
            The methods in this class use a so-called fisheye camera model.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.ProjectPoints(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Double,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Projects points using fisheye model.
            
            The function computes projections of 3D points to the image plane given intrinsic and extrinsic 
            camera parameters.Optionally, the function computes Jacobians - matrices of partial derivatives of 
            image points coordinates(as functions of all the input parameters) with respect to the particular 
            parameters, intrinsic and/or extrinsic.
            </summary>
            <param name="objectPoints">Array of object points, 1xN/Nx1 3-channel (or vector&lt;Point3f&gt; ), 
            where N is the number of points in the view.</param>
            <param name="imagePoints">Output array of image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, 
            or vector&lt;Point2f&gt;.</param>
            <param name="rvec"></param>
            <param name="tvec"></param>
            <param name="k">Camera matrix</param>
            <param name="d">Input vector of distortion coefficients</param>
            <param name="alpha">The skew coefficient.</param>
            <param name="jacobian">Optional output 2Nx15 jacobian matrix of derivatives of image points with respect 
            to components of the focal lengths, coordinates of the principal point, distortion coefficients, 
            rotation vector, translation vector, and the skew.In the old interface different components of 
            the jacobian are returned via different output parameters.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.DistortPoints(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Double)">
            <summary>
            Distorts 2D points using fisheye model.
            </summary>
            <param name="undistorted">Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), 
            where N is the number of points in the view.</param>
            <param name="distorted">Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .</param>
            <param name="k">Camera matrix</param>
            <param name="d">Input vector of distortion coefficients</param>
            <param name="alpha">The skew coefficient.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.UndistortPoints(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Undistorts 2D points using fisheye model
            </summary>
            <param name="distorted">Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), 
            where N is the number of points in the view.</param>
            <param name="undistorted">Output array of image points, 1xN/Nx1 2-channel, or vector&gt;Point2f&gt; .</param>
            <param name="k">Camera matrix</param>
            <param name="d">Input vector of distortion coefficients (k_1, k_2, k_3, k_4).</param>
            <param name="r">Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel</param>
            <param name="p">New camera matrix (3x3) or new projection matrix (3x4)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.InitUndistortRectifyMap(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,System.Int32,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Computes undistortion and rectification maps for image transform by cv::remap(). 
            If D is empty zero distortion is used, if R or P is empty identity matrixes are used.
            </summary>
            <param name="k">Camera matrix</param>
            <param name="d">Input vector of distortion coefficients (k_1, k_2, k_3, k_4).</param>
            <param name="r">Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel</param>
            <param name="p">New camera matrix (3x3) or new projection matrix (3x4)</param>
            <param name="size">Undistorted image size.</param>
            <param name="m1type">Type of the first output map that can be CV_32FC1 or CV_16SC2 . See convertMaps() for details.</param>
            <param name="map1">The first output map.</param>
            <param name="map2">The second output map.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.UndistortImage(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size)">
            <summary>
            Transforms an image to compensate for fisheye lens distortion.
            </summary>
            <param name="distorted">image with fisheye lens distortion.</param>
            <param name="undistorted">Output image with compensated fisheye lens distortion.</param>
            <param name="k">Camera matrix</param>
            <param name="d">Input vector of distortion coefficients (k_1, k_2, k_3, k_4).</param>
            <param name="knew">Camera matrix of the distorted image. By default, it is the identity matrix but you
            may additionally scale and shift the result by using a different matrix.</param>
            <param name="newSize"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.EstimateNewCameraMatrixForUndistortRectify(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,ST4IVisionCoreNet.Size,System.Double)">
            <summary>
            Estimates new camera matrix for undistortion or rectification.
            </summary>
            <param name="k">Camera matrix</param>
            <param name="d">Input vector of distortion coefficients (k_1, k_2, k_3, k_4).</param>
            <param name="imageSize"></param>
            <param name="r">Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
            1-channel or 1x1 3-channel</param>
            <param name="p">New camera matrix (3x3) or new projection matrix (3x4)</param>
            <param name="balance">Sets the new focal length in range between the min focal length and the max focal 
            length.Balance is in range of[0, 1].</param>
            <param name="newSize"></param>
            <param name="fovScale">Divisor for new focal length.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.Calibrate(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat}@,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat}@,ST4IVisionCoreNet.FishEyeCalibrationFlags,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            Performs camera calibaration
            </summary>
            <param name="objectPoints">vector of vectors of calibration pattern points in the calibration pattern coordinate space.</param>
            <param name="imagePoints">vector of vectors of the projections of calibration pattern points. 
            imagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to 
            objectPoints[i].size() for each i.</param>
            <param name="imageSize">Size of the image used only to initialize the intrinsic camera matrix.</param>
            <param name="k">Output 3x3 floating-point camera matrix</param>
            <param name="d">Output vector of distortion coefficients (k_1, k_2, k_3, k_4).</param>
            <param name="rvecs">Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view. 
            That is, each k-th rotation vector together with the corresponding k-th translation vector(see 
            the next output parameter description) brings the calibration pattern from the model coordinate 
            space(in which object points are specified) to the world coordinate space, that is, a real 
            position of the calibration pattern in the k-th pattern view(k= 0.. * M * -1).</param>
            <param name="tvecs">Output vector of translation vectors estimated for each pattern view.</param>
            <param name="flags">Different flags that may be zero or a combination of flag values</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.StereoRectify(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.FishEyeCalibrationFlags,ST4IVisionCoreNet.Size,System.Double,System.Double)">
            <summary>
            Stereo rectification for fisheye camera model
            </summary>
            <param name="k1">First camera matrix.</param>
            <param name="d1">First camera distortion parameters.</param>
            <param name="k2">Second camera matrix.</param>
            <param name="d2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="r">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="tvec">Translation vector between coordinate systems of the cameras.</param>
            <param name="r1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="r2">Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="p1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="p2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D ).</param>
            <param name="flags">Operation flags that may be zero or CALIB_ZERO_DISPARITY . If the flag is set, 
            the function makes the principal points of each camera have the same pixel coordinates in the 
            rectified views.And if the flag is not set, the function may still shift the images in the 
            horizontal or vertical direction(depending on the orientation of epipolar lines) to maximize the 
            useful image area.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to 
            initUndistortRectifyMap(see the stereo_calib.cpp sample in OpenCV samples directory). When(0,0) 
            is passed(default), it is set to the original imageSize.Setting it to larger value can help you 
            preserve details in the original image, especially when there is a big radial distortion.</param>
            <param name="balance">Sets the new focal length in range between the min focal length and the max focal
            length.Balance is in range of[0, 1].</param>
            <param name="fovScale">Divisor for new focal length.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FishEye.StereoCalibrate(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.FishEyeCalibrationFlags,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            Performs stereo calibration
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points.</param>
            <param name="imagePoints1">Vector of vectors of the projections of the calibration pattern points, 
            observed by the first camera.</param>
            <param name="imagePoints2">Vector of vectors of the projections of the calibration pattern points, 
            observed by the second camera.</param>
            <param name="k1">Input/output first camera matrix</param>
            <param name="d1">Input/output vector of distortion coefficients (k_1, k_2, k_3, k_4) of 4 elements.</param>
            <param name="k2">Input/output second camera matrix. The parameter is similar to K1 .</param>
            <param name="d2">Input/output lens distortion coefficients for the second camera. The parameter is 
            similar to D1.</param>
            <param name="imageSize">Size of the image used only to initialize intrinsic camera matrix.</param>
            <param name="r">Output rotation matrix between the 1st and the 2nd camera coordinate systems.</param>
            <param name="t">Output translation vector between the coordinate systems of the cameras.</param>
            <param name="flags">Different flags that may be zero or a combination of the FishEyeCalibrationFlags values</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BorderInterpolate(System.Int32,System.Int32,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Computes the source location of an extrapolated pixel.
            </summary>
            <param name="p">0-based coordinate of the extrapolated pixel along one of the axes, likely &lt;0 or &gt;= len</param>
            <param name="len">Length of the array along the corresponding axis.</param>
            <param name="borderType">Border type, one of the #BorderTypes, except for #BORDER_TRANSPARENT and BORDER_ISOLATED. 
            When borderType==BORDER_CONSTANT, the function always returns -1, regardless</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CopyMakeBorder(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Forms a border around the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same type as src and 
            the size Size(src.cols+left+right, src.rows+top+bottom)</param>
            <param name="top">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="bottom">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="left">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="right">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="borderType">The border type</param>
            <param name="value">The border value if borderType == Constant</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Add(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Computes the per-element sum of two arrays or an array and a scalar.
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. It must have the same size and same type as src1</param>
            <param name="dst">The destination array; it will have the same size and same type as src1</param>
            <param name="mask">The optional operation mask, 8-bit single channel array; specifies elements of the destination array to be changed. [By default this is null]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Subtract(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Calculates per-element difference between two arrays or array and a scalar
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. It must have the same size and same type as src1</param>
            <param name="dst">The destination array; it will have the same size and same type as src1</param>
            <param name="mask">The optional operation mask, 8-bit single channel array; specifies elements of the destination array to be changed. [By default this is null]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Subtract(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Calculates per-element difference between two arrays or array and a scalar
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. It must have the same size and same type as src1</param>
            <param name="dst">The destination array; it will have the same size and same type as src1</param>
            <param name="mask">The optional operation mask, 8-bit single channel array; specifies elements of the destination array to be changed. [By default this is null]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Subtract(ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Calculates per-element difference between two arrays or array and a scalar
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. It must have the same size and same type as src1</param>
            <param name="dst">The destination array; it will have the same size and same type as src1</param>
            <param name="mask">The optional operation mask, 8-bit single channel array; specifies elements of the destination array to be changed. [By default this is null]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Multiply(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Int32)">
            <summary>
            Calculates the per-element scaled product of two arrays
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array of the same size and the same type as src1</param>
            <param name="dst">The destination array; will have the same size and the same type as src1</param>
            <param name="scale">The optional scale factor. [By default this is 1]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Divide(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Int32)">
            <summary>
            Performs per-element division of two arrays or a scalar by an array.
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array; should have the same size and same type as src1</param>
            <param name="dst">The destination array; will have the same size and same type as src2</param>
            <param name="scale">Scale factor [By default this is 1]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Divide(System.Double,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Performs per-element division of two arrays or a scalar by an array.
            </summary>
            <param name="scale">Scale factor</param>
            <param name="src2">The first source array</param>
            <param name="dst">The destination array; will have the same size and same type as src2</param>
            <param name="dtype"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ScaleAdd(ST4IVisionCoreNet.InputArray,System.Double,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            adds scaled array to another one (dst = alpha*src1 + src2)
            </summary>
            <param name="src1"></param>
            <param name="alpha"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.AddWeighted(ST4IVisionCoreNet.InputArray,System.Double,ST4IVisionCoreNet.InputArray,System.Double,System.Double,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            computes weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)
            </summary>
            <param name="src1"></param>
            <param name="alpha"></param>
            <param name="src2"></param>
            <param name="beta"></param>
            <param name="gamma"></param>
            <param name="dst"></param>
            <param name="dtype"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertScaleAbs(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double)">
            <summary>
            Scales, computes absolute values and converts the result to 8-bit.
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array</param>
            <param name="alpha">The optional scale factor. [By default this is 1]</param>
            <param name="beta">The optional delta added to the scaled values. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertFp16(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
             <summary>
             Converts an array to half precision floating number.
            
             This function converts FP32(single precision floating point) from/to FP16(half precision floating point). CV_16S format is used to represent FP16 data.
             There are two use modes(src -&gt; dst) : CV_32F -&gt; CV_16S and CV_16S -&gt; CV_32F.The input array has to have type of CV_32F or
             CV_16S to represent the bit depth.If the input array is neither of them, the function will raise an error.
             The format of half precision floating point is defined in IEEE 754-2008.
             </summary>
             <param name="src">input array.</param>
             <param name="dst">output array.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.LUT(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            transforms array of numbers using a lookup table: dst(i)=lut(src(i))
            </summary>
            <param name="src">Source array of 8-bit elements</param>
            <param name="lut">Look-up table of 256 elements. 
            In the case of multi-channel source array, the table should either have 
            a single channel (in this case the same table is used for all channels)
             or the same number of channels as in the source array</param>
            <param name="dst">Destination array; 
            will have the same size and the same number of channels as src, 
            and the same depth as lut</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.LUT(ST4IVisionCoreNet.InputArray,System.Byte[],ST4IVisionCoreNet.OutputArray)">
            <summary>
            transforms array of numbers using a lookup table: dst(i)=lut(src(i))
            </summary>
            <param name="src">Source array of 8-bit elements</param>
            <param name="lut">Look-up table of 256 elements. 
            In the case of multi-channel source array, the table should either have 
            a single channel (in this case the same table is used for all channels) 
            or the same number of channels as in the source array</param>
            <param name="dst">Destination array; 
            will have the same size and the same number of channels as src, 
            and the same depth as lut</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Sum(ST4IVisionCoreNet.InputArray)">
            <summary>
            computes sum of array elements
            </summary>
            <param name="src">The source array; must have 1 to 4 channels</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CountNonZero(ST4IVisionCoreNet.InputArray)">
            <summary>
            computes the number of nonzero array elements
            </summary>
            <param name="mtx">Single-channel array</param>
            <returns>number of non-zero elements in mtx</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindNonZero(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            returns the list of locations of non-zero pixels
            </summary>
            <param name="src"></param>
            <param name="idx"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Mean(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes mean value of selected array elements
            </summary>
            <param name="src">The source array; it should have 1 to 4 channels
             (so that the result can be stored in Scalar)</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MeanStdDev(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes mean value and standard deviation of all or selected array elements
            </summary>
            <param name="src">The source array; it should have 1 to 4 channels 
            (so that the results can be stored in Scalar's)</param>
            <param name="mean">The output parameter: computed mean value</param>
            <param name="stddev">The output parameter: computed standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MeanStdDev(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Scalar@,ST4IVisionCoreNet.Scalar@,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes mean value and standard deviation of all or selected array elements
            </summary>
            <param name="src">The source array; it should have 1 to 4 channels 
            (so that the results can be stored in Scalar's)</param>
            <param name="mean">The output parameter: computed mean value</param>
            <param name="stddev">The output parameter: computed standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Norm(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.NormTypes,ST4IVisionCoreNet.InputArray)">
            <summary>
            Calculates absolute array norm, absolute difference norm, or relative difference norm.
            </summary>
            <param name="src1">The first source array</param>
            <param name="normType">Type of the norm</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Norm(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.NormTypes,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes norm of selected part of the difference between two arrays
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array of the same size and the same type as src1</param>
            <param name="normType">Type of the norm</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PSNR(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Double)">
            <summary>
            Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.
            
            This function calculates the Peak Signal-to-Noise Ratio(PSNR) image quality metric in decibels(dB), 
            between two input arrays src1 and src2.The arrays must have the same type.
            </summary>
            <param name="src1">first input array.</param>
            <param name="src2">second input array of the same size as src1.</param>
            <param name="r">the maximum pixel value (255 by default)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BatchDistance(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.NormTypes,System.Int32,ST4IVisionCoreNet.InputArray,System.Int32,System.Boolean)">
            <summary>
            naive nearest neighbor finder
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dist"></param>
            <param name="dtype"></param>
            <param name="nidx"></param>
            <param name="normType"></param>
            <param name="k"></param>
            <param name="mask"></param>
            <param name="update"></param>
            <param name="crosscheck"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Normalize(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,System.Double,System.Double,ST4IVisionCoreNet.NormTypes,System.Int32,ST4IVisionCoreNet.InputArray)">
            <summary>
            scales and shifts array elements so that either the specified norm (alpha) 
            or the minimum (alpha) and maximum (beta) array values get the specified values
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array; will have the same size as src</param>
            <param name="alpha">The norm value to normalize to or the lower range boundary 
            in the case of range normalization</param>
            <param name="beta">The upper range boundary in the case of range normalization; 
            not used for norm normalization</param>
            <param name="normType">The normalization type</param>
            <param name="dtype">When the parameter is negative, 
            the destination array will have the same type as src, 
            otherwise it will have the same number of channels as src and the depth =CV_MAT_DEPTH(rtype)</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinMaxLoc(ST4IVisionCoreNet.InputArray,System.Double@,System.Double@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinMaxLoc(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.Point@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinMaxLoc(ST4IVisionCoreNet.InputArray,System.Double@,System.Double@,ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.InputArray)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask used to select a sub-array</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinMaxIdx(ST4IVisionCoreNet.InputArray,System.Double@,System.Double@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinMaxIdx(ST4IVisionCoreNet.InputArray,System.Int32[],System.Int32[])">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minIdx"></param>
            <param name="maxIdx"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinMaxIdx(ST4IVisionCoreNet.InputArray,System.Double@,System.Double@,System.Int32[],System.Int32[],ST4IVisionCoreNet.InputArray)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minIdx"></param>
            <param name="maxIdx"></param>
            <param name="mask"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Reduce(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ReduceDimension,ST4IVisionCoreNet.ReduceTypes,System.Int32)">
            <summary>
            transforms 2D matrix to 1D row or column vector by taking sum, minimum, maximum or mean value over all the rows
            </summary>
            <param name="src">The source 2D matrix</param>
            <param name="dst">The destination vector. 
            Its size and type is defined by dim and dtype parameters</param>
            <param name="dim">The dimension index along which the matrix is reduced. 
            0 means that the matrix is reduced to a single row and 1 means that the matrix is reduced to a single column</param>
            <param name="rtype"></param>
            <param name="dtype">When it is negative, the destination vector will have 
            the same type as the source matrix, otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), mtx.channels())</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Merge(ST4IVisionCoreNet.Mat[],ST4IVisionCoreNet.Mat)">
            <summary>
            makes multi-channel array out of several single-channel arrays
            </summary>
            <param name="mv"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Split(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat[]@)">
            <summary>
            Copies each plane of a multi-channel array to a dedicated array
            </summary>
            <param name="src">The source multi-channel array</param>
            <param name="mv">The destination array or vector of arrays; 
            The number of arrays must match mtx.channels() . 
            The arrays themselves will be reallocated if needed</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Split(ST4IVisionCoreNet.Mat)">
            <summary>
            Copies each plane of a multi-channel array to a dedicated array
            </summary>
            <param name="src">The source multi-channel array</param>
            <returns>The number of arrays must match mtx.channels() . 
            The arrays themselves will be reallocated if needed</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MixChannels(ST4IVisionCoreNet.Mat[],ST4IVisionCoreNet.Mat[],System.Int32[])">
            <summary>
            copies selected channels from the input arrays to the selected channels of the output arrays
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="fromTo"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ExtractChannel(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            extracts a single channel from src (coi is 0-based index)
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="coi"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InsertChannel(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,System.Int32)">
            <summary>
            inserts a single channel to dst (coi is 0-based index)
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="coi"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Flip(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.FlipMode)">
            <summary>
            reverses the order of the rows, columns or both in a matrix
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
            <param name="flipCode">Specifies how to flip the array: 
            0 means flipping around the x-axis, positive (e.g., 1) means flipping around y-axis, 
            and negative (e.g., -1) means flipping around both axes. See also the discussion below for the formulas.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rotate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.RotateFlags)">
            <summary>
            Rotates a 2D array in multiples of 90 degrees.
            </summary>
            <param name="src">input array.</param>
            <param name="dst">output array of the same type as src.
            The size is the same with ROTATE_180, and the rows and cols are switched for
            ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE.</param>
            <param name="rotateCode">an enum to specify how to rotate the array.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Repeat(ST4IVisionCoreNet.InputArray,System.Int32,System.Int32,ST4IVisionCoreNet.OutputArray)">
            <summary>
            replicates the input matrix the specified number of times in the horizontal and/or vertical direction
            </summary>
            <param name="src">The source array to replicate</param>
            <param name="ny">How many times the src is repeated along the vertical axis</param>
            <param name="nx">How many times the src is repeated along the horizontal axis</param>
            <param name="dst">The destination array; will have the same type as src</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Repeat(ST4IVisionCoreNet.Mat,System.Int32,System.Int32)">
            <summary>
            replicates the input matrix the specified number of times in the horizontal and/or vertical direction
            </summary>
            <param name="src">The source array to replicate</param>
            <param name="ny">How many times the src is repeated along the vertical axis</param>
            <param name="nx">How many times the src is repeated along the horizontal axis</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.HConcat(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies horizontal concatenation to given matrices.
            </summary>
            <param name="src">input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.</param>
            <param name="dst">output array. It has the same number of rows and depth as the src, and the sum of cols of the src.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.HConcat(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies horizontal concatenation to given matrices.
            </summary>
            <param name="src1">first input array to be considered for horizontal concatenation.</param>
            <param name="src2">second input array to be considered for horizontal concatenation.</param>
            <param name="dst">output array. It has the same number of rows and depth as the src1 and src2, and the sum of cols of the src1 and src2.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.VConcat(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies vertical concatenation to given matrices.
            </summary>
            <param name="src">input array or vector of matrices. all of the matrices must have the same number of cols and the same depth.</param>
            <param name="dst">output array. It has the same number of cols and depth as the src, and the sum of rows of the src.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.VConcat(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies vertical concatenation to given matrices.
            </summary>
            <param name="src1">first input array to be considered for vertical concatenation.</param>
            <param name="src2">second input array to be considered for vertical concatenation.</param>
            <param name="dst">output array. It has the same number of cols and depth as the src1 and src2, and the sum of rows of the src1 and src2.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BitwiseAnd(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes bitwise conjunction of the two arrays (dst = src1 &amp; src2)
            </summary>
            <param name="src1">first input array or a scalar.</param>
            <param name="src2">second input array or a scalar.</param>
            <param name="dst">output array that has the same size and type as the input</param>
            <param name="mask">optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BitwiseOr(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes bitwise disjunction of the two arrays (dst = src1 | src2)
            </summary>
            <param name="src1">first input array or a scalar.</param>
            <param name="src2">second input array or a scalar.</param>
            <param name="dst">output array that has the same size and type as the input</param>
            <param name="mask">optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BitwiseXor(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes bitwise exclusive-or of the two arrays (dst = src1 ^ src2)
            </summary>
            <param name="src1">first input array or a scalar.</param>
            <param name="src2">second input array or a scalar.</param>
            <param name="dst">output array that has the same size and type as the input</param>
            <param name="mask">optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BitwiseNot(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            inverts each bit of array (dst = ~src)
            </summary>
            <param name="src">input array.</param>
            <param name="dst">output array that has the same size and type as the input</param>
            <param name="mask">optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Absdiff(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates the per-element absolute difference between two arrays or between an array and a scalar.
            </summary>
            <param name="src1">first input array or a scalar.</param>
            <param name="src2">second input array or a scalar.</param>
            <param name="dst">output array that has the same size and type as input arrays.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CopyTo(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Copies the matrix to another one.
            When the operation mask is specified, if the Mat::create call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.
            </summary>
            <param name="src">Source matrix.</param>
            <param name="dst">Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="mask">Operation mask of the same size as \*this. Its non-zero elements indicate which matrix
            elements need to be copied.The mask has to be of type CV_8U and can have 1 or multiple channels.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InRange(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Checks if array elements lie between the elements of two other arrays.
            </summary>
            <param name="src">first input array.</param>
            <param name="lowerb">inclusive lower boundary array or a scalar.</param>
            <param name="upperb">inclusive upper boundary array or a scalar.</param>
            <param name="dst">output array of the same size as src and CV_8U type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InRange(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Checks if array elements lie between the elements of two other arrays.
            </summary>
            <param name="src">first input array.</param>
            <param name="lowerb">inclusive lower boundary array or a scalar.</param>
            <param name="upperb">inclusive upper boundary array or a scalar.</param>
            <param name="dst">output array of the same size as src and CV_8U type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Compare(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.CmpType)">
            <summary>
            Performs the per-element comparison of two arrays or an array and scalar value.
            </summary>
            <param name="src1">first input array or a scalar; when it is an array, it must have a single channel.</param>
            <param name="src2">second input array or a scalar; when it is an array, it must have a single channel.</param>
            <param name="dst">output array of type ref CV_8U that has the same size and the same number of channels as the input arrays.</param>
            <param name="cmpop">a flag, that specifies correspondence between the arrays (cv::CmpTypes)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Min(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            computes per-element minimum of two arrays (dst = min(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Min(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat)">
            <summary>
            computes per-element minimum of two arrays (dst = min(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Min(ST4IVisionCoreNet.Mat,System.Double,ST4IVisionCoreNet.Mat)">
            <summary>
            computes per-element minimum of array and scalar (dst = min(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Max(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            computes per-element maximum of two arrays (dst = max(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Max(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat)">
            <summary>
            computes per-element maximum of two arrays (dst = max(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Max(ST4IVisionCoreNet.Mat,System.Double,ST4IVisionCoreNet.Mat)">
            <summary>
            computes per-element maximum of array and scalar (dst = max(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Sqrt(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            computes square root of each matrix element (dst = src**0.5)
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Pow(ST4IVisionCoreNet.InputArray,System.Double,ST4IVisionCoreNet.OutputArray)">
            <summary>
            raises the input matrix elements to the specified power (b = a**power)
            </summary>
            <param name="src">The source array</param>
            <param name="power">The exponent of power</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Exp(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            computes exponent of each matrix element (dst = e**src)
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Log(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            computes natural logarithm of absolute value of each matrix element: dst = log(abs(src))
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PolarToCart(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            Calculates x and y coordinates of 2D vectors from their magnitude and angle.
            </summary>
            <param name="magnitude">input floating-point array of magnitudes of 2D vectors;
            it can be an empty matrix(=Mat()), in this case, the function assumes that all the magnitudes are = 1; if it is not empty,
            it must have the same size and type as angle.</param>
            <param name="angle">input floating-point array of angles of 2D vectors.</param>
            <param name="x">output array of x-coordinates of 2D vectors; it has the same size and type as angle.</param>
            <param name="y">output array of y-coordinates of 2D vectors; it has the same size and type as angle.</param>
            <param name="angleInDegrees">when true, the input angles are measured in degrees, otherwise, they are measured in radians.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CartToPolar(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            Calculates the magnitude and angle of 2D vectors.
            </summary>
            <param name="x">array of x-coordinates; this must be a single-precision or double-precision floating-point array.</param>
            <param name="y">array of y-coordinates, that must have the same size and same type as x.</param>
            <param name="magnitude">output array of magnitudes of the same size and type as x.</param>
            <param name="angle">output array of angles that has the same size and type as x;
            the angles are measured in radians(from 0 to 2\*Pi) or in degrees(0 to 360 degrees).</param>
            <param name="angleInDegrees">a flag, indicating whether the angles are measured in radians(which is by default), or in degrees.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Phase(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            Calculates the rotation angle of 2D vectors.
            </summary>
            <param name="x">input floating-point array of x-coordinates of 2D vectors.</param>
            <param name="y">input array of y-coordinates of 2D vectors; it must have the same size and the same type as x.</param>
            <param name="angle">output array of vector angles; it has the same size and same type as x.</param>
            <param name="angleInDegrees">when true, the function calculates the angle in degrees, otherwise, they are measured in radians.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Magnitude(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates the magnitude of 2D vectors.
            </summary>
            <param name="x">floating-point array of x-coordinates of the vectors.</param>
            <param name="y">floating-point array of y-coordinates of the vectors; it must have the same size as x.</param>
            <param name="magnitude">output array of the same size and type as x.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CheckRange(ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            checks that each matrix element is within the specified range.
            </summary>
            <param name="src">The array to check</param>
            <param name="quiet">The flag indicating whether the functions quietly 
            return false when the array elements are out of range, 
            or they throw an exception.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CheckRange(ST4IVisionCoreNet.InputArray,System.Boolean,ST4IVisionCoreNet.Point@,System.Double,System.Double)">
            <summary>
            checks that each matrix element is within the specified range.
            </summary>
            <param name="src">The array to check</param>
            <param name="quiet">The flag indicating whether the functions quietly 
            return false when the array elements are out of range, 
            or they throw an exception.</param>
            <param name="pos">The optional output parameter, where the position of 
            the first outlier is stored.</param>
            <param name="minVal">The inclusive lower boundary of valid values range</param>
            <param name="maxVal">The exclusive upper boundary of valid values range</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PatchNaNs(ST4IVisionCoreNet.InputOutputArray,System.Double)">
            <summary>
            converts NaN's to the given number
            </summary>
            <param name="a"></param>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Gemm(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Double,ST4IVisionCoreNet.InputArray,System.Double,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.GemmFlags)">
            <summary>
            implements generalized matrix product algorithm GEMM from BLAS
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="alpha"></param>
            <param name="src3"></param>
            <param name="gamma"></param>
            <param name="dst"></param>
            <param name="flags"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MulTransposed(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Boolean,ST4IVisionCoreNet.InputArray,System.Double,System.Int32)">
            <summary>
            multiplies matrix by its transposition from the left or from the right
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination square matrix</param>
            <param name="aTa">Specifies the multiplication ordering; see the description below</param>
            <param name="delta">The optional delta matrix, subtracted from src before the 
            multiplication. When the matrix is empty ( delta=Mat() ), it’s assumed to be 
            zero, i.e. nothing is subtracted, otherwise if it has the same size as src, 
            then it’s simply subtracted, otherwise it is "repeated" to cover the full src 
            and then subtracted. Type of the delta matrix, when it's not empty, must be the 
            same as the type of created destination matrix, see the rtype description</param>
            <param name="scale">The optional scale factor for the matrix product</param>
            <param name="dtype">When it’s negative, the destination matrix will have the 
            same type as src . Otherwise, it will have type=CV_MAT_DEPTH(rtype), 
            which should be either CV_32F or CV_64F</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Transpose(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            transposes the matrix
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array of the same type as src</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Transform(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            performs affine transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source array; must have as many channels (1 to 4) as mtx.cols or mtx.cols-1</param>
            <param name="dst">The destination array; will have the same size and depth as src and as many channels as mtx.rows</param>
            <param name="m">The transformation matrix</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PerspectiveTransform(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="dst">The destination array; it will have the same size and same type as src</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PerspectiveTransform(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.Mat)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PerspectiveTransform(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2d},ST4IVisionCoreNet.Mat)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PerspectiveTransform(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f},ST4IVisionCoreNet.Mat)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PerspectiveTransform(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3d},ST4IVisionCoreNet.Mat)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CompleteSymm(ST4IVisionCoreNet.InputOutputArray,System.Boolean)">
            <summary>
            extends the symmetrical matrix from the lower half or from the upper half
            </summary>
            <param name="mtx"> Input-output floating-point square matrix</param>
            <param name="lowerToUpper">If true, the lower half is copied to the upper half, 
            otherwise the upper half is copied to the lower half</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetIdentity(ST4IVisionCoreNet.InputOutputArray,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            initializes scaled identity matrix
            </summary>
            <param name="mtx">The matrix to initialize (not necessarily square)</param>
            <param name="s">The value to assign to the diagonal elements</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Determinant(ST4IVisionCoreNet.InputArray)">
            <summary>
            computes determinant of a square matrix
            </summary>
            <param name="mtx">The input matrix; must have CV_32FC1 or CV_64FC1 type and square size</param>
            <returns>determinant of the specified matrix.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Trace(ST4IVisionCoreNet.InputArray)">
            <summary>
            computes trace of a matrix
            </summary>
            <param name="mtx">The source matrix</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Invert(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DecompTypes)">
            <summary>
            computes inverse or pseudo-inverse matrix
            </summary>
            <param name="src">The source floating-point MxN matrix</param>
            <param name="dst">The destination matrix; will have NxM size and the same type as src</param>
            <param name="flags">The inversion method</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Solve(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DecompTypes)">
            <summary>
            solves linear system or a least-square problem
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SolveLP(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method).
            </summary>
            <param name="func">This row-vector corresponds to \f$c\f$ in the LP problem formulation (see above). 
            It should contain 32- or 64-bit floating point numbers.As a convenience, column-vector may be also submitted,
            in the latter case it is understood to correspond to \f$c^T\f$.</param>
            <param name="constr">`m`-by-`n+1` matrix, whose rightmost column corresponds to \f$b\f$ in formulation above 
            and the remaining to \f$A\f$. It should containt 32- or 64-bit floating point numbers.</param>
            <param name="z">The solution will be returned here as a column-vector - it corresponds to \f$c\f$ in the 
            formulation above.It will contain 64-bit floating point numbers.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Sort(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.SortFlags)">
            <summary>
            sorts independently each matrix row or each matrix column
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="dst">The destination array of the same size and the same type as src</param>
            <param name="flags">The operation flags, a combination of the SortFlag values</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SortIdx(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.SortFlags)">
            <summary>
            sorts independently each matrix row or each matrix column
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="dst">The destination integer array of the same size as src</param>
            <param name="flags">The operation flags, a combination of SortFlag values</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SolveCubic(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            finds real roots of a cubic polynomial
            </summary>
            <param name="coeffs">The equation coefficients, an array of 3 or 4 elements</param>
            <param name="roots">The destination array of real roots which will have 1 or 3 elements</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SolvePoly(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            finds real and complex roots of a polynomial
            </summary>
            <param name="coeffs">The array of polynomial coefficients</param>
            <param name="roots">The destination (complex) array of roots</param>
            <param name="maxIters">The maximum number of iterations the algorithm does</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Eigen(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Computes eigenvalues and eigenvectors of a symmetric matrix.
            </summary>
            <param name="src">The input matrix; must have CV_32FC1 or CV_64FC1 type, 
            square size and be symmetric: src^T == src</param>
            <param name="eigenvalues">The output vector of eigenvalues of the same type as src; 
            The eigenvalues are stored in the descending order.</param>
            <param name="eigenvectors">The output matrix of eigenvectors; 
            It will have the same size and the same type as src; The eigenvectors are stored 
            as subsequent matrix rows, in the same order as the corresponding eigenvalues</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EigenNonSymmetric(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).
            </summary>
            <param name="src">input matrix (CV_32FC1 or CV_64FC1 type).</param>
            <param name="eigenvalues">output vector of eigenvalues (type is the same type as src).</param>
            <param name="eigenvectors">output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalcCovarMatrix(ST4IVisionCoreNet.Mat[],ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.CovarFlags,System.Nullable{ST4IVisionCoreNet.MatType})">
            <summary>
            computes covariation matrix of a set of samples
            </summary>
            <param name="samples">samples stored as separate matrices</param>
            <param name="covar">output covariance matrix of the type ctype and square size.</param>
            <param name="mean">input or output (depending on the flags) array as the average value of the input vectors.</param>
            <param name="flags">operation flags as a combination of CovarFlags</param>
            <param name="ctype">type of the matrixl; it equals 'CV_64F' by default.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalcCovarMatrix(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.CovarFlags,System.Nullable{ST4IVisionCoreNet.MatType})">
            <summary>
            computes covariation matrix of a set of samples
            </summary>
            <param name="samples">samples stored as rows/columns of a single matrix.</param>
            <param name="covar">output covariance matrix of the type ctype and square size.</param>
            <param name="mean">input or output (depending on the flags) array as the average value of the input vectors.</param>
            <param name="flags">operation flags as a combination of CovarFlags</param>
            <param name="ctype">type of the matrixl; it equals 'CV_64F' by default.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PCACompute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            PCA of the supplied dataset. 
            </summary>
            <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
            <param name="eigenvectors">eigenvectors of the covariation matrix</param>
            <param name="maxComponents">maximum number of components that PCA should
            retain; by default, all the components are retained.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PCACompute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            PCA of the supplied dataset. 
            </summary>
            <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
            <param name="eigenvectors">eigenvectors of the covariation matrix</param>
            <param name="eigenvalues">eigenvalues of the covariation matrix</param>
            <param name="maxComponents">maximum number of components that PCA should
            retain; by default, all the components are retained.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PCAComputeVar(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.OutputArray,System.Double)">
            <summary>
            PCA of the supplied dataset. 
            </summary>
            <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
            <param name="eigenvectors">eigenvectors of the covariation matrix</param>
            <param name="retainedVariance">Percentage of variance that PCA should retain.
            Using this parameter will let the PCA decided how many components to retain but it will always keep at least 2.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PCAComputeVar(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Double)">
            <summary>
            PCA of the supplied dataset. 
            </summary>
            <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
            <param name="eigenvectors">eigenvectors of the covariation matrix</param>
            <param name="eigenvalues">eigenvalues of the covariation matrix</param>
            <param name="retainedVariance">Percentage of variance that PCA should retain.
            Using this parameter will let the PCA decided how many components to retain but it will always keep at least 2.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PCAProject(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Projects vector(s) to the principal component subspace.
            </summary>
            <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
            <param name="eigenvectors">eigenvectors of the covariation matrix</param>
            <param name="result">output vectors</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PCABackProject(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Reconstructs vectors from their PC projections.
            </summary>
            <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
            <param name="eigenvectors">eigenvectors of the covariation matrix</param>
            <param name="result">output vectors</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SVDecomp(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.SVD.Flags)">
            <summary>
            decomposes matrix and stores the results to user-provided matrices
            </summary>
            <param name="src">decomposed matrix. The depth has to be CV_32F or CV_64F.</param>
            <param name="w">calculated singular values</param>
            <param name="u">calculated left singular vectors</param>
            <param name="vt">transposed matrix of right singular vectors</param>
            <param name="flags">peration flags - see SVD::Flags.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SVBackSubst(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            performs back substitution for the previously computed SVD
            </summary>
            <param name="w">calculated singular values</param>
            <param name="u">calculated left singular vectors</param>
            <param name="vt">transposed matrix of right singular vectors</param>
            <param name="rhs">right-hand side of a linear system (u*w*v')*dst = rhs to be solved, where A has been previously decomposed.</param>
            <param name="dst">output</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Mahalanobis(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Calculates the Mahalanobis distance between two vectors.
            </summary>
            <param name="v1">first 1D input vector.</param>
            <param name="v2">second 1D input vector.</param>
            <param name="icovar">inverse covariance matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Dft(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DftFlags,System.Int32)">
            <summary>
            Performs a forward Discrete Fourier transform of 1D or 2D floating-point array.
            </summary>
            <param name="src">The source array, real or complex</param>
            <param name="dst">The destination array, which size and type depends on the flags</param>
            <param name="flags">Transformation flags, a combination of the DftFlag2 values</param>
            <param name="nonzeroRows">When the parameter != 0, the function assumes that 
            only the first nonzeroRows rows of the input array ( DFT_INVERSE is not set) 
            or only the first nonzeroRows of the output array ( DFT_INVERSE is set) contain non-zeros, 
            thus the function can handle the rest of the rows more efficiently and 
            thus save some time. This technique is very useful for computing array cross-correlation 
            or convolution using DFT</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Idft(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DftFlags,System.Int32)">
            <summary>
            Performs an inverse Discrete Fourier transform of 1D or 2D floating-point array.
            </summary>
            <param name="src">The source array, real or complex</param>
            <param name="dst">The destination array, which size and type depends on the flags</param>
            <param name="flags">Transformation flags, a combination of the DftFlag2 values</param>
            <param name="nonzeroRows">When the parameter != 0, the function assumes that 
            only the first nonzeroRows rows of the input array ( DFT_INVERSE is not set) 
            or only the first nonzeroRows of the output array ( DFT_INVERSE is set) contain non-zeros, 
            thus the function can handle the rest of the rows more efficiently and 
            thus save some time. This technique is very useful for computing array cross-correlation 
            or convolution using DFT</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Dct(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DctFlags)">
            <summary>
            Performs forward or inverse 1D or 2D Discrete Cosine Transformation
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
            <param name="flags">Transformation flags, a combination of DctFlag2 values</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Idct(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DctFlags)">
            <summary>
            Performs inverse 1D or 2D Discrete Cosine Transformation
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
            <param name="flags">Transformation flags, a combination of DctFlag2 values</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MulSpectrums(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DftFlags,System.Boolean)">
            <summary>
            Performs the per-element multiplication of two Fourier spectrums.
            </summary>
            <param name="a">first input array.</param>
            <param name="b">second input array of the same size and type as src1.</param>
            <param name="c"> output array of the same size and type as src1.</param>
            <param name="flags">operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
            each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.</param>
            <param name="conjB">optional flag that conjugates the second input array before the multiplication (true) or not (false).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetOptimalDFTSize(System.Int32)">
            <summary>
            Returns the optimal DFT size for a given vector size.
            </summary>
            <param name="vecSize">vector size.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetTheRNG">
            <summary>
            Returns the thread-local Random number generator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetTheRNG(System.UInt64)">
            <summary>
            Sets the thread-local Random number generator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Randu(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            fills array with uniformly-distributed random numbers from the range [low, high)
            </summary>
            <param name="dst">The output array of random numbers. 
            The array must be pre-allocated and have 1 to 4 channels</param>
            <param name="low">The inclusive lower boundary of the generated random numbers</param>
            <param name="high">The exclusive upper boundary of the generated random numbers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Randu(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Scalar)">
            <summary>
            fills array with uniformly-distributed random numbers from the range [low, high)
            </summary>
            <param name="dst">The output array of random numbers. 
            The array must be pre-allocated and have 1 to 4 channels</param>
            <param name="low">The inclusive lower boundary of the generated random numbers</param>
            <param name="high">The exclusive upper boundary of the generated random numbers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Randn(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            fills array with normally-distributed random numbers with the specified mean and the standard deviation
            </summary>
            <param name="dst">The output array of random numbers. 
            The array must be pre-allocated and have 1 to 4 channels</param>
            <param name="mean">The mean value (expectation) of the generated random numbers</param>
            <param name="stddev">The standard deviation of the generated random numbers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Randn(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Scalar)">
            <summary>
            fills array with normally-distributed random numbers with the specified mean and the standard deviation
            </summary>
            <param name="dst">The output array of random numbers. 
            The array must be pre-allocated and have 1 to 4 channels</param>
            <param name="mean">The mean value (expectation) of the generated random numbers</param>
            <param name="stddev">The standard deviation of the generated random numbers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RandShuffle(ST4IVisionCoreNet.InputOutputArray,System.Double)">
            <summary>
            shuffles the input array elements
            </summary>
            <param name="dst">The input/output numerical 1D array</param>
            <param name="iterFactor">The scale factor that determines the number of random swap operations.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RandShuffle(ST4IVisionCoreNet.InputOutputArray,System.Double,ST4IVisionCoreNet.RNG@)">
            <summary>
            shuffles the input array elements
            </summary>
            <param name="dst">The input/output numerical 1D array</param>
            <param name="iterFactor">The scale factor that determines the number of random swap operations.</param>
            <param name="rng">The optional random number generator used for shuffling. 
            If it is null, theRng() is used instead.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Kmeans(ST4IVisionCoreNet.InputArray,System.Int32,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.TermCriteria,System.Int32,ST4IVisionCoreNet.KMeansFlags,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Finds centers of clusters and groups input samples around the clusters.
            </summary>
            <param name="data">Data for clustering. An array of N-Dimensional points with float coordinates is needed.</param>
            <param name="k">Number of clusters to split the set by.</param>
            <param name="bestLabels">Input/output integer array that stores the cluster indices for every sample.</param>
            <param name="criteria">The algorithm termination criteria, that is, the maximum number of iterations and/or
            the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster centers
            moves by less than criteria.epsilon on some iteration, the algorithm stops.</param>
            <param name="attempts">Flag to specify the number of times the algorithm is executed using different
            initial labellings. The algorithm returns the labels that yield the best compactness (see the last function parameter).</param>
            <param name="flags">Flag that can take values of cv::KmeansFlags</param>
            <param name="centers">Output matrix of the cluster centers, one row per each cluster center.</param>
            <returns>The function returns the compactness measure that is computed as
            \f[\sum _i  \| \texttt{samples} _i -  \texttt{centers} _{ \texttt{labels} _i} \| ^2\f]
            after every attempt. The best (minimum) value is chosen and the corresponding labels and the compactness
            value are returned by the function. Basically, you can use only the core of the function,
            set the number of attempts to 1, initialize labels each time using a custom algorithm,
            pass them with the ( flags = #KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best (most-compact) clustering.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FastAtan2(System.Single,System.Single)">
            <summary>
            computes the angle in degrees (0..360) of the vector (x,y)
            </summary>
            <param name="y"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CubeRoot(System.Single)">
            <summary>
            computes cube root of the argument
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Glob(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="pattern"></param>
            <param name="recursive"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetNumThreads(System.Int32)">
            <summary>
            OpenCV will try to set the number of threads for the next parallel region.
            If threads == 0, OpenCV will disable threading optimizations and run all it's functions
            sequentially.Passing threads &lt; 0 will reset threads number to system default. This function must
            be called outside of parallel region.
            OpenCV will try to run its functions with specified threads number, but some behaviour differs from framework:
            -   `TBB` - User-defined parallel constructions will run with the same threads number, if another is not specified.If later on user creates his own scheduler, OpenCV will use it.
            -   `OpenMP` - No special defined behaviour.
            -   `Concurrency` - If threads == 1, OpenCV will disable threading optimizations and run its functions sequentially.
            -   `GCD` - Supports only values &lt;= 0.
            -   `C=` - No special defined behaviour.
            </summary>
            <param name="nThreads">Number of threads used by OpenCV.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetNumThreads">
            <summary>
            Returns the number of threads used by OpenCV for parallel regions.
            
            Always returns 1 if OpenCV is built without threading support.
            The exact meaning of return value depends on the threading framework used by OpenCV library:
            - `TBB` - The number of threads, that OpenCV will try to use for parallel regions. If there is
            any tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns default
            number of threads used by TBB library.
            - `OpenMP` - An upper bound on the number of threads that could be used to form a new team.
            - `Concurrency` - The number of threads, that OpenCV will try to use for parallel regions.
            - `GCD` - Unsupported; returns the GCD thread pool limit(512) for compatibility.
            - `C=` - The number of threads, that OpenCV will try to use for parallel regions, if before
            called setNumThreads with threads &gt; 0, otherwise returns the number of logical CPUs,
            available for the process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetThreadNum">
            <summary>
            Returns the index of the currently executed thread within the current parallel region.
            Always returns 0 if called outside of parallel region.
            @deprecated Current implementation doesn't corresponding to this documentation.
            The exact meaning of the return value depends on the threading framework used by OpenCV library:
            - `TBB` - Unsupported with current 4.1 TBB release.Maybe will be supported in future.
            - `OpenMP` - The thread number, within the current team, of the calling thread.
            - `Concurrency` - An ID for the virtual processor that the current context is executing
            on(0 for master thread and unique number for others, but not necessary 1,2,3,...).
            - `GCD` - System calling thread's ID. Never returns 0 inside parallel region.
            - `C=` - The index of the current parallel task.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetBuildInformation">
             <summary>
             Returns full configuration time cmake output.
            
             Returned value is raw cmake output including version control system revision, compiler version,
             compiler flags, enabled modules and third party libraries, etc.Output format depends on target architecture.
             </summary>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetVersionString">
            <summary>
            Returns library version string.
            For example "3.4.1-dev".
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetVersionMajor">
            <summary>
            Returns major library version
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetVersionMinor">
            <summary>
            Returns minor library version
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetVersionRevision">
            <summary>
            Returns revision field of the library version
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetTickCount">
            <summary>
            Returns the number of ticks.
            The function returns the number of ticks after the certain event (for example, when the machine was
            turned on). It can be used to initialize RNG or to measure a function execution time by reading the
            tick count before and after the function call.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetTickFrequency">
            <summary>
            Returns the number of ticks per second.
            The function returns the number of ticks per second.That is, the following code computes the execution time in seconds:
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetCpuTickCount">
             <summary>
             Returns the number of CPU ticks.
            
             The function returns the current number of CPU ticks on some architectures(such as x86, x64, PowerPC).
             On other platforms the function is equivalent to getTickCount.It can also be used for very accurate time
             measurements, as well as for RNG initialization.Note that in case of multi-CPU systems a thread, from which
             getCPUTickCount is called, can be suspended and resumed at another CPU with its own counter. So,
             theoretically (and practically) the subsequent calls to the function do not necessary return the monotonously
             increasing values. Also, since a modern CPU varies the CPU frequency depending on the load, the number of CPU
             clocks spent in some code cannot be directly converted to time units.Therefore, getTickCount is generally
             a preferable solution for measuringexecution time.
             </summary>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CheckHardwareSupport(ST4IVisionCoreNet.CpuFeatures)">
            <summary>
            Returns true if the specified feature is supported by the host hardware.
            The function returns true if the host hardware supports the specified feature.When user calls
            setUseOptimized(false), the subsequent calls to checkHardwareSupport() will return false until
            setUseOptimized(true) is called.This way user can dynamically switch on and off the optimized code in OpenCV.
            </summary>
            <param name="feature">The feature of interest, one of cv::CpuFeatures</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetHardwareFeatureName(ST4IVisionCoreNet.CpuFeatures)">
            <summary>
            Returns feature name by ID.
            Returns empty string if feature is not defined
            </summary>
            <param name="feature"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetCpuFeaturesLine">
            <summary>
            Returns list of CPU features enabled during compilation.
            Returned value is a string containing space separated list of CPU features with following markers:
            - no markers - baseline features
            - prefix `*` - features enabled in dispatcher
            - suffix `?` - features enabled but not available in HW
            </summary>
            <example>
            `SSE SSE2 SSE3* SSE4.1 *SSE4.2 *FP16* AVX *AVX2* AVX512-SKX?`
            </example>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetNumberOfCpus">
            <summary>
            Returns the number of logical CPUs available for the process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetUseOptimized(System.Boolean)">
            <summary>
            Turns on/off available optimization.
            The function turns on or off the optimized code in OpenCV. Some optimization can not be enabled
            or disabled, but, for example, most of SSE code in OpenCV can be temporarily turned on or off this way.
            </summary>
            <param name="onoff"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.UseOptimized">
            <summary>
            Returns the current optimization status.
            The function returns the current optimization status, which is controlled by cv::setUseOptimized().
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.AlignSize(System.Int32,System.Int32)">
            <summary>
            Aligns buffer size by the certain number of bytes
            This small inline function aligns a buffer size by 
            the certian number of bytes by enlarging it.
            </summary>
            <param name="sz"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetBreakOnError(System.Boolean)">
            <summary>
            Sets/resets the break-on-error mode.
            When the break-on-error mode is set, the default error handler issues a hardware exception,
            which can make debugging more convenient.
            </summary>
            <param name="flag"></param>
            <returns>the previous state</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Format(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.FormatType)">
            <summary>
            
            </summary>
            <param name="mtx"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Abs(ST4IVisionCoreNet.Mat)">
            <summary>
            Computes absolute value of each matrix element
            </summary>
            <param name="src">matrix</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Abs(ST4IVisionCoreNet.MatExpr)">
            <summary>
            Computes absolute value of each matrix element
            </summary>
            <param name="src">matrix expression</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Sv.PartitionPredicate`1">
            <summary>
            Equivalence predicate (a boolean function of two arguments).
            The predicate returns true when the elements are certainly in the same class, and returns false if they may or may not be in the same class.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Partition``1(System.Collections.Generic.IEnumerable{``0},System.Int32[]@,ST4IVisionCoreNet.Sv.PartitionPredicate{``0})">
            <summary>
            Splits an element set into equivalency classes.
            Consider using GroupBy of Linq instead.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="vec">Set of elements stored as a vector.</param>
            <param name="labels">Output vector of labels. It contains as many elements as vec. Each label labels[i] is a 0-based cluster index of vec[i] .</param>
            <param name="predicate">Equivalence predicate (a boolean function of two arguments).
            The predicate returns true when the elements are certainly in the same class, and returns false if they may or may not be in the same class.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FAST(ST4IVisionCoreNet.InputArray,System.Int32,System.Boolean)">
            <summary>
            Detects corners using the FAST algorithm
            </summary>
            <param name="image">grayscale image where keypoints (corners) are detected.</param>
            <param name="threshold">threshold on difference between intensity of the central pixel 
            and pixels of a circle around this pixel.</param>
            <param name="nonmaxSupression">if true, non-maximum suppression is applied to 
            detected corners (keypoints).</param>
            <returns>keypoints detected on the image.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FAST(ST4IVisionCoreNet.InputArray,System.Int32,System.Boolean,ST4IVisionCoreNet.FASTType)">
            <summary>
            Detects corners using the FAST algorithm
            </summary>
            <param name="image">grayscale image where keypoints (corners) are detected.</param>
            <param name="threshold">threshold on difference between intensity of the central pixel 
            and pixels of a circle around this pixel.</param>
            <param name="nonmaxSupression">if true, non-maximum suppression is applied to 
            detected corners (keypoints).</param>
            <param name="type">one of the three neighborhoods as defined in the paper</param>
            <returns>keypoints detected on the image.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.AGAST(ST4IVisionCoreNet.InputArray,System.Int32,System.Boolean,ST4IVisionCoreNet.AgastFeatureDetector.DetectorType)">
            <summary>
            Detects corners using the AGAST algorithm
            </summary>
            <param name="image">grayscale image where keypoints (corners) are detected.</param>
            <param name="threshold">threshold on difference between intensity of the central pixel 
            and pixels of a circle around this pixel.</param>
            <param name="nonmaxSuppression">if true, non-maximum suppression is applied to 
            detected corners (keypoints).</param>
            <param name="type">one of the four neighborhoods as defined in the paper</param>
            <returns>keypoints detected on the image.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawKeypoints(ST4IVisionCoreNet.InputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},ST4IVisionCoreNet.InputOutputArray,System.Nullable{ST4IVisionCoreNet.Scalar},ST4IVisionCoreNet.DrawMatchesFlags)">
            <summary>
            Draw keypoints.
            </summary>
            <param name="image">Source image.</param>
            <param name="keypoints">Keypoints from the source image.</param>
            <param name="outImage">Output image. Its content depends on the flags value defining what is drawn in the output image. See possible flags bit values below.</param>
            <param name="color">Color of keypoints.</param>
            <param name="flags">Flags setting drawing features. Possible flags bit values are defined by DrawMatchesFlags.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawMatches(ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.DMatch},ST4IVisionCoreNet.Mat,System.Nullable{ST4IVisionCoreNet.Scalar},System.Nullable{ST4IVisionCoreNet.Scalar},System.Collections.Generic.IEnumerable{System.Byte},ST4IVisionCoreNet.DrawMatchesFlags)">
            <summary>
            Draws the found matches of keypoints from two images.
            </summary>
            <param name="img1">First source image.</param>
            <param name="keypoints1">Keypoints from the first source image.</param>
            <param name="img2">Second source image.</param>
            <param name="keypoints2">Keypoints from the second source image.</param>
            <param name="matches1To2">Matches from the first image to the second one, which means that keypoints1[i]
            has a corresponding point in keypoints2[matches[i]] .</param>
            <param name="outImg">Output image. Its content depends on the flags value defining what is drawn in the
            output image. See possible flags bit values below.</param>
            <param name="matchColor">Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1),
            the color is generated randomly.</param>
            <param name="singlePointColor">Color of single keypoints (circles), which means that keypoints do not
            have the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly.</param>
            <param name="matchesMask">Mask determining which matches are drawn. If the mask is empty, all matches are drawn.</param>
            <param name="flags">Flags setting drawing features. Possible flags bit values are defined by DrawMatchesFlags.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawMatchesKnn(ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.DMatch}},ST4IVisionCoreNet.Mat,System.Nullable{ST4IVisionCoreNet.Scalar},System.Nullable{ST4IVisionCoreNet.Scalar},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Byte}},ST4IVisionCoreNet.DrawMatchesFlags)">
            <summary>
            Draws the found matches of keypoints from two images.
            </summary>
            <param name="img1">First source image.</param>
            <param name="keypoints1">Keypoints from the first source image.</param>
            <param name="img2">Second source image.</param>
            <param name="keypoints2">Keypoints from the second source image.</param>
            <param name="matches1To2">Matches from the first image to the second one, which means that keypoints1[i]
            has a corresponding point in keypoints2[matches[i]] .</param>
            <param name="outImg">Output image. Its content depends on the flags value defining what is drawn in the
            output image. See possible flags bit values below.</param>
            <param name="matchColor">Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1),
            the color is generated randomly.</param>
            <param name="singlePointColor">Color of single keypoints (circles), which means that keypoints do not
            have the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly.</param>
            <param name="matchesMask">Mask determining which matches are drawn. If the mask is empty, all matches are drawn.</param>
            <param name="flags">Flags setting drawing features. Possible flags bit values are defined by DrawMatchesFlags.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EvaluateFeatureDetector(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.KeyPoint[]@,ST4IVisionCoreNet.KeyPoint[]@,System.Single@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="img1"></param>
            <param name="img2"></param>
            <param name="H1to2"></param>
            <param name="keypoints1"></param>
            <param name="keypoints2"></param>
            <param name="repeatability"></param>
            <param name="correspCount"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ComputeRecallPrecisionCurve(ST4IVisionCoreNet.DMatch[][],System.Byte[][])">
            <summary>
            
            </summary>
            <param name="matches1to2"></param>
            <param name="correctMatches1to2Mask"></param>
            <returns>recallPrecisionCurve</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetRecall(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Single)">
            <summary>
            
            </summary>
            <param name="recallPrecisionCurve"></param>
            <param name="lPrecision"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetNearestPoint(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Single)">
            <summary>
            
            </summary>
            <param name="recallPrecisionCurve"></param>
            <param name="lPrecision"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.NamedWindow(System.String,ST4IVisionCoreNet.WindowFlags)">
            <summary>
            Creates a window.
            </summary>
            <param name="winName">Name of the window in the window caption that may be used as a window identifier.</param>
            <param name="flags">
            Flags of the window. Currently the only supported flag is CV WINDOW AUTOSIZE. If this is set, 
            the window size is automatically adjusted to fit the displayed image (see imshow ), and the user can not change the window size manually.
            </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DestroyWindow(System.String)">
            <summary>
            Destroys the specified window.
            </summary>
            <param name="winName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DestroyAllWindows">
            <summary>
            Destroys all of the HighGUI windows.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.StartWindowThread">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.WaitKeyEx(System.Int32)">
            <summary>
            Waits for a pressed key.
            Similar to #waitKey, but returns full key code. 
            Key code is implementation specific and depends on used backend: QT/GTK/Win32/etc
            </summary>
            <param name="delay">Delay in milliseconds. 0 is the special value that means ”forever”</param>
            <returns>Returns the code of the pressed key or -1 if no key was pressed before the specified time had elapsed.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.WaitKey(System.Int32)">
            <summary>
            Waits for a pressed key. 
            </summary>
            <param name="delay">Delay in milliseconds. 0 is the special value that means ”forever”</param>
            <returns>Returns the code of the pressed key or -1 if no key was pressed before the specified time had elapsed.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImShow(System.String,ST4IVisionCoreNet.Mat)">
            <summary>
            Displays the image in the specified window
            </summary>
            <param name="winName">Name of the window.</param>
            <param name="mat">Image to be shown.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ResizeWindow(System.String,System.Int32,System.Int32)">
            <summary>
            Resizes window to the specified size
            </summary>
            <param name="winName">Window name</param>
            <param name="width">The new window width</param>
            <param name="height">The new window height</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ResizeWindow(System.String,ST4IVisionCoreNet.Size)">
            <summary>
            Resizes window to the specified size
            </summary>
            <param name="winName">Window name</param>
            <param name="size">The new window size</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MoveWindow(System.String,System.Int32,System.Int32)">
            <summary>
            Moves window to the specified position
            </summary>
            <param name="winName">Window name</param>
            <param name="x">The new x-coordinate of the window</param>
            <param name="y">The new y-coordinate of the window</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetWindowProperty(System.String,ST4IVisionCoreNet.WindowPropertyFlags,System.Double)">
            <summary>
            Changes parameters of a window dynamically.
            </summary>
            <param name="winName">Name of the window.</param>
            <param name="propId">Window property to retrieve.</param>
            <param name="propValue">New value of the window property.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetWindowTitle(System.String,System.String)">
            <summary>
            Updates window title
            </summary>
            <param name="winName">Name of the window</param>
            <param name="title">New title</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetWindowProperty(System.String,ST4IVisionCoreNet.WindowPropertyFlags)">
            <summary>
            Provides parameters of a window.
            </summary>
            <param name="winName">Name of the window.</param>
            <param name="propId">Window property to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetWindowImageRect(System.String)">
            <summary>
            Provides rectangle of image in the window.
            The function getWindowImageRect returns the client screen coordinates, width and height of the image rendering area.
            </summary>
            <param name="winName">Name of the window.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetMouseCallback(System.String,ST4IVisionCoreNet.MouseCallback,System.IntPtr)">
            <summary>
            Sets the callback function for mouse events occuring within the specified window.
            </summary>
            <param name="windowName">Name of the window. </param>
            <param name="onMouse">Reference to the function to be called every time mouse event occurs in the specified window. </param>
            <param name="userData"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetMouseWheelDelta(ST4IVisionCoreNet.MouseEventFlags)">
            <summary>
            Gets the mouse-wheel motion delta, when handling mouse-wheel events cv::EVENT_MOUSEWHEEL and cv::EVENT_MOUSEHWHEEL.
            
            For regular mice with a scroll-wheel, delta will be a multiple of 120. The value 120 corresponds to 
            a one notch rotation of the wheel or the threshold for action to be taken and one such action should 
            occur for each delta.Some high-precision mice with higher-resolution freely-rotating wheels may 
            generate smaller values. 
            
            For cv::EVENT_MOUSEWHEEL positive and negative values mean forward and backward scrolling, 
            respectively.For cv::EVENT_MOUSEHWHEEL, where available, positive and negative values mean right and 
            left scrolling, respectively.
            </summary>
            <param name="flags">The mouse callback flags parameter.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SelectROI(System.String,ST4IVisionCoreNet.InputArray,System.Boolean,System.Boolean)">
            <summary>
            Selects ROI on the given image.
            Function creates a window and allows user to select a ROI using mouse.
            Controls: use `space` or `enter` to finish selection, use key `c` to cancel selection (function will return the zero cv::Rect).
            </summary>
            <param name="windowName">name of the window where selection process will be shown.</param>
            <param name="img">image to select a ROI.</param>
            <param name="showCrosshair">if true crosshair of selection rectangle will be shown.</param>
            <param name="fromCenter">if true center of selection will match initial mouse position. In opposite case a corner of
            selection rectangle will correspond to the initial mouse position.</param>
            <returns>selected ROI or empty rect if selection canceled.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SelectROI(ST4IVisionCoreNet.InputArray,System.Boolean,System.Boolean)">
            <summary>
            Selects ROI on the given image.
            Function creates a window and allows user to select a ROI using mouse.
            Controls: use `space` or `enter` to finish selection, use key `c` to cancel selection (function will return the zero cv::Rect).
            </summary>
            <param name="img">image to select a ROI.</param>
            <param name="showCrosshair">if true crosshair of selection rectangle will be shown.</param>
            <param name="fromCenter">if true center of selection will match initial mouse position. In opposite case a corner of
            selection rectangle will correspond to the initial mouse position.</param>
            <returns>selected ROI or empty rect if selection canceled.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SelectROIs(System.String,ST4IVisionCoreNet.InputArray,System.Boolean,System.Boolean)">
            <summary>
            Selects ROIs on the given image.
            Function creates a window and allows user to select a ROIs using mouse.
            Controls: use `space` or `enter` to finish current selection and start a new one,
            use `esc` to terminate multiple ROI selection process.
            </summary>
            <param name="windowName">name of the window where selection process will be shown.</param>
            <param name="img">image to select a ROI.</param>
            <param name="showCrosshair">if true crosshair of selection rectangle will be shown.</param>
            <param name="fromCenter">if true center of selection will match initial mouse position. In opposite case a corner of
            selection rectangle will correspond to the initial mouse position.</param>
            <returns>selected ROIs.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateTrackbar(System.String,System.String,System.Int32@,System.Int32,ST4IVisionCoreNet.TrackbarCallbackNative,System.IntPtr)">
            <summary>
            Creates a trackbar and attaches it to the specified window.
            The function createTrackbar creates a trackbar(a slider or range control) with the specified name 
            and range, assigns a variable value to be a position synchronized with the trackbar and specifies 
            the callback function onChange to be called on the trackbar position change.The created trackbar is 
            displayed in the specified window winName.
            </summary>
            <param name="trackbarName">Name of the created trackbar.</param>
            <param name="winName">Name of the window that will be used as a parent of the created trackbar.</param>
            <param name="value">Optional pointer to an integer variable whose value reflects the position of the slider.Upon creation,
             the slider position is defined by this variable.</param>
            <param name="count">Maximal position of the slider. The minimal position is always 0.</param>
            <param name="onChange">Pointer to the function to be called every time the slider changes position. 
            This function should be prototyped as void Foo(int, void\*); , where the first parameter is the trackbar 
            position and the second parameter is the user data(see the next parameter). If the callback is 
            the NULL pointer, no callbacks are called, but only value is updated.</param>
            <param name="userData">User data that is passed as is to the callback. It can be used to handle trackbar events without using global variables.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateTrackbar(System.String,System.String,System.Int32,ST4IVisionCoreNet.TrackbarCallbackNative,System.IntPtr)">
            <summary>
            Creates a trackbar and attaches it to the specified window.
            The function createTrackbar creates a trackbar(a slider or range control) with the specified name 
            and range, assigns a variable value to be a position synchronized with the trackbar and specifies 
            the callback function onChange to be called on the trackbar position change.The created trackbar is 
            displayed in the specified window winName.
            </summary>
            <param name="trackbarName">Name of the created trackbar.</param>
            <param name="winName">Name of the window that will be used as a parent of the created trackbar.</param>
            <param name="count">Maximal position of the slider. The minimal position is always 0.</param>
            <param name="onChange">Pointer to the function to be called every time the slider changes position. 
            This function should be prototyped as void Foo(int, void\*); , where the first parameter is the trackbar 
            position and the second parameter is the user data(see the next parameter). If the callback is 
            the NULL pointer, no callbacks are called, but only value is updated.</param>
            <param name="userData">User data that is passed as is to the callback. It can be used to handle trackbar events without using global variables.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetTrackbarPos(System.String,System.String)">
            <summary>
            Returns the trackbar position.
            </summary>
            <param name="trackbarName">Name of the trackbar.</param>
            <param name="winName">Name of the window that is the parent of the trackbar.</param>
            <returns>trackbar position</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetTrackbarPos(System.String,System.String,System.Int32)">
            <summary>
            Sets the trackbar position.
            </summary>
            <param name="trackbarName">Name of the trackbar.</param>
            <param name="winName">Name of the window that is the parent of trackbar.</param>
            <param name="pos">New position.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetTrackbarMax(System.String,System.String,System.Int32)">
            <summary>
            Sets the trackbar maximum position.
            The function sets the maximum position of the specified trackbar in the specified window.
            </summary>
            <param name="trackbarName">Name of the trackbar.</param>
            <param name="winName">Name of the window that is the parent of trackbar.</param>
            <param name="maxVal">New maximum position.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SetTrackbarMin(System.String,System.String,System.Int32)">
            <summary>
            Sets the trackbar minimum position.
            The function sets the minimum position of the specified trackbar in the specified window.
            </summary>
            <param name="trackbarName">Name of the trackbar.</param>
            <param name="winName">Name of the window that is the parent of trackbar.</param>
            <param name="minVal">New minimum position.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetWindowHandle(System.String)">
            <summary>
            get native window handle (HWND in case of Win32 and Widget in case of X Window) 
            </summary>
            <param name="windowName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InitContainer(System.Object)">
            <summary>
            Initialize XAML container panel for use by ImShow
            </summary>
            <param name="panel">Panel container.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImRead(System.String,ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Loads an image from a file.
            </summary>
            <param name="fileName">Name of file to be loaded.</param>
            <param name="flags">Specifies color type of the loaded image</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImReadMulti(System.String,ST4IVisionCoreNet.Mat[]@,ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Loads a multi-page image from a file. 
            </summary>
            <param name="filename">Name of file to be loaded.</param>
            <param name="mats">A vector of Mat objects holding each page, if more than one.</param>
            <param name="flags">Flag that can take values of @ref cv::ImreadModes, default with IMREAD_ANYCOLOR.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImWrite(System.String,ST4IVisionCoreNet.Mat,System.Int32[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="img">Image to be saved.</param>
            <param name="prms">Format-specific save parameters encoded as pairs</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImWrite(System.String,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="img">Image to be saved.</param>
            <param name="prms">Format-specific save parameters encoded as pairs</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImWrite(System.String,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Int32[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="img">Image to be saved.</param>
            <param name="prms">Format-specific save parameters encoded as pairs</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImWrite(System.String,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="img">Image to be saved.</param>
            <param name="prms">Format-specific save parameters encoded as pairs</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImDecode(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="buf">The input array of vector of bytes.</param>
            <param name="flags">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImDecode(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="buf">The input array of vector of bytes.</param>
            <param name="flags">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImDecode(System.Byte[],ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="buf">The input array of vector of bytes.</param>
            <param name="flags">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImDecode(System.ReadOnlySpan{System.Byte},ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="span">The input slice of bytes.</param>
            <param name="flags">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImEncode(System.String,ST4IVisionCoreNet.InputArray,System.Byte[]@,System.Int32[])">
            <summary>
            Compresses the image and stores it in the memory buffer
            </summary>
            <param name="ext">The file extension that defines the output format</param>
            <param name="img">The image to be written</param>
            <param name="buf">Output buffer resized to fit the compressed image.</param>
            <param name="prms">Format-specific parameters.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ImEncode(System.String,ST4IVisionCoreNet.InputArray,System.Byte[]@,ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Compresses the image and stores it in the memory buffer
            </summary>
            <param name="ext">The file extension that defines the output format</param>
            <param name="img">The image to be written</param>
            <param name="buf">Output buffer resized to fit the compressed image.</param>
            <param name="prms">Format-specific parameters.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.HaveImageReader(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.HaveImageWriter(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetGaussianKernel(System.Int32,System.Double,System.Nullable{ST4IVisionCoreNet.MatType})">
            <summary>
            Returns Gaussian filter coefficients.
            </summary>
            <param name="ksize">Aperture size. It should be odd and positive.</param>
            <param name="sigma">Gaussian standard deviation.
            If it is non-positive, it is computed from ksize as `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.</param>
            <param name="ktype">Type of filter coefficients. It can be CV_32F or CV_64F.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetDerivKernels(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Int32,System.Boolean,System.Nullable{ST4IVisionCoreNet.MatType})">
            <summary>
            Returns filter coefficients for computing spatial image derivatives.
            </summary>
            <param name="kx">Output matrix of row filter coefficients. It has the type ktype.</param>
            <param name="ky">Output matrix of column filter coefficients. It has the type ktype.</param>
            <param name="dx">Derivative order in respect of x.</param>
            <param name="dy">Derivative order in respect of y.</param>
            <param name="ksize">Aperture size. It can be CV_SCHARR, 1, 3, 5, or 7.</param>
            <param name="normalize">Flag indicating whether to normalize (scale down) the filter coefficients or not.
            Theoretically, the coefficients should have the denominator \f$=2^{ksize*2-dx-dy-2}\f$. 
            If you are going to filter floating-point images, you are likely to use the normalized kernels.
            But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, 
            and wish to preserve all the fractional bits, you may want to set normalize = false.</param>
            <param name="ktype">Type of filter coefficients. It can be CV_32f or CV_64F.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetGaborKernel(ST4IVisionCoreNet.Size,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Returns Gabor filter coefficients. 
            </summary>
            <remarks>
            For more details about gabor filter equations and parameters, see: https://en.wikipedia.org/wiki/Gabor_filter
            </remarks>
            <param name="ksize">Size of the filter returned.</param>
            <param name="sigma">Standard deviation of the gaussian envelope.</param>
            <param name="theta">Orientation of the normal to the parallel stripes of a Gabor function.</param>
            <param name="lambd">Wavelength of the sinusoidal factor.</param>
            <param name="gamma">Spatial aspect ratio.</param>
            <param name="psi">Phase offset.</param>
            <param name="ktype">Type of filter coefficients. It can be CV_32F or CV_64F.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetStructuringElement(ST4IVisionCoreNet.MorphShapes,ST4IVisionCoreNet.Size)">
            <summary>
            Returns a structuring element of the specified size and shape for morphological operations.
            The function constructs and returns the structuring element that can be further passed to erode,
            dilate or morphologyEx.But you can also construct an arbitrary binary mask yourself and use it as the structuring element.
            </summary>
            <param name="shape">Element shape that could be one of MorphShapes</param>
            <param name="ksize">Size of the structuring element.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetStructuringElement(ST4IVisionCoreNet.MorphShapes,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Point)">
            <summary>
            Returns a structuring element of the specified size and shape for morphological operations.
            The function constructs and returns the structuring element that can be further passed to erode,
            dilate or morphologyEx.But you can also construct an arbitrary binary mask yourself and use it as the structuring element.
            </summary>
            <param name="shape">Element shape that could be one of MorphShapes</param>
            <param name="ksize">Size of the structuring element.</param>
            <param name="anchor">Anchor position within the element. The default value (−1,−1) means that the anchor is at the center.
            Note that only the shape of a cross-shaped element depends on the anchor position.
            In other cases the anchor just regulates how much the result of the morphological operation is shifted.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MedianBlur(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Smoothes image using median filter
            </summary>
            <param name="src">The source 1-, 3- or 4-channel image. 
            When ksize is 3 or 5, the image depth should be CV_8U , CV_16U or CV_32F. 
            For larger aperture sizes it can only be CV_8U</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
            <param name="ksize">The aperture linear size. It must be odd and more than 1, i.e. 3, 5, 7 ...</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GaussianBlur(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Size,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Blurs an image using a Gaussian filter.
            </summary>
            <param name="src">input image; the image can have any number of channels, which are processed independently, 
            but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</param>
            <param name="dst">output image of the same size and type as src.</param>
            <param name="ksize">Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. 
            Or, they can be zero’s and then they are computed from sigma* .</param>
            <param name="sigmaX">Gaussian kernel standard deviation in X direction.</param>
            <param name="sigmaY">Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, 
            if both sigmas are zeros, they are computed from ksize.width and ksize.height, 
            respectively (see getGaussianKernel() for details); to fully control the result 
            regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</param>
            <param name="borderType">pixel extrapolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BilateralFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Applies bilateral filter to the image
            </summary>
            <param name="src">The source 8-bit or floating-point, 1-channel or 3-channel image</param>
            <param name="dst">The destination image; will have the same size and the same type as src</param>
            <param name="d">The diameter of each pixel neighborhood, that is used during filtering. 
            If it is non-positive, it's computed from sigmaSpace</param>
            <param name="sigmaColor">Filter sigma in the color space. 
            Larger value of the parameter means that farther colors within the pixel neighborhood 
            will be mixed together, resulting in larger areas of semi-equal color</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. 
            Larger value of the parameter means that farther pixels will influence each other 
            (as long as their colors are close enough; see sigmaColor). Then d>0 , it specifies 
            the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace</param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BoxFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Size,System.Nullable{ST4IVisionCoreNet.Point},System.Boolean,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Smoothes image using box filter
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same type as src</param>
            <param name="ddepth"></param>
            <param name="ksize">The smoothing kernel size</param>
            <param name="anchor">The anchor point. The default value Point(-1,-1) means that the anchor is at the kernel center</param>
            <param name="normalize">Indicates, whether the kernel is normalized by its area or not</param>
            <param name="borderType">The border mode used to extrapolate pixels outside of the image</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SqrBoxFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,ST4IVisionCoreNet.Size,System.Nullable{ST4IVisionCoreNet.Point},System.Boolean,ST4IVisionCoreNet.BorderTypes)">
             <summary>
             Calculates the normalized sum of squares of the pixel values overlapping the filter.
            
             For every pixel f(x, y) in the source image, the function calculates the sum of squares of those neighboring
             pixel values which overlap the filter placed over the pixel f(x, y).
            
             The unnormalized square box filter can be useful in computing local image statistics such as the the local
             variance and standard deviation around the neighborhood of a pixel.
             </summary>
             <param name="src"></param>
             <param name="dst"></param>
             <param name="ddepth"></param>
             <param name="ksize"></param>
             <param name="anchor"></param>
             <param name="normalize"></param>
             <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Blur(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Size,System.Nullable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Smoothes image using normalized box filter
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same type as src</param>
            <param name="ksize">The smoothing kernel size</param>
            <param name="anchor">The anchor point. The default value Point(-1,-1) means that the anchor is at the kernel center</param>
            <param name="borderType">The border mode used to extrapolate pixels outside of the image</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Filter2D(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Convolves an image with the kernel
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image. It will have the same size and the same number of channels as src</param>
            <param name="ddepth">The desired depth of the destination image. If it is negative, it will be the same as src.depth()</param>
            <param name="kernel">Convolution kernel (or rather a correlation kernel), 
            a single-channel floating point matrix. If you want to apply different kernels to 
            different channels, split the image into separate color planes using split() and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of 
            a filtered point within the kernel. The anchor should lie within the kernel. 
            The special default value (-1,-1) means that the anchor is at the kernel center</param>
            <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SepFilter2D(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Applies separable linear filter to an image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same number of channels as src</param>
            <param name="ddepth">The destination image depth</param>
            <param name="kernelX">The coefficients for filtering each row</param>
            <param name="kernelY">The coefficients for filtering each column</param>
            <param name="anchor">The anchor position within the kernel; The default value (-1, 1) means that the anchor is at the kernel center</param>
            <param name="delta">The value added to the filtered results before storing them</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Sobel(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,System.Int32,System.Int32,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Calculates the first, second, third or mixed image derivatives using an extended Sobel operator
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same number of channels as src</param>
            <param name="ddepth">The destination image depth</param>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="ksize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7</param>
            <param name="scale">The optional scale factor for the computed derivative values (by default, no scaling is applied</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SpatialGradient(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Int32,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Calculates the first order image derivative in both x and y using a Sobel operator
            </summary>
            <param name="src">input image.</param>
            <param name="dx">output image with first-order derivative in x.</param>
            <param name="dy">output image with first-order derivative in y.</param>
            <param name="ksize">size of Sobel kernel. It must be 3.</param>
            <param name="borderType">pixel extrapolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Scharr(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,System.Int32,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Calculates the first x- or y- image derivative using Scharr operator
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same number of channels as src</param>
            <param name="ddepth">The destination image depth</param>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="scale">The optional scale factor for the computed derivative values (by default, no scaling is applie</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Laplacian(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Calculates the Laplacian of an image
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image; will have the same size and the same number of channels as src</param>
            <param name="ddepth">The desired depth of the destination image</param>
            <param name="ksize">The aperture size used to compute the second-derivative filters</param>
            <param name="scale">The optional scale factor for the computed Laplacian values (by default, no scaling is applied</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Canny(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Finds edges in an image using Canny algorithm.
            </summary>
            <param name="src">Single-channel 8-bit input image</param>
            <param name="edges">The output edge map. It will have the same size and the same type as image</param>
            <param name="threshold1">The first threshold for the hysteresis procedure</param>
            <param name="threshold2">The second threshold for the hysteresis procedure</param>
            <param name="apertureSize">Aperture size for the Sobel operator [By default this is ApertureSize.Size3]</param>
            <param name="L2gradient">Indicates, whether the more accurate L2 norm should be used to compute the image gradient magnitude (true), or a faster default L1 norm is enough (false). [By default this is false]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Canny(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,System.Boolean)">
            <summary>
            Finds edges in an image using the Canny algorithm with custom image gradient.
            </summary>
            <param name="dx">16-bit x derivative of input image (CV_16SC1 or CV_16SC3).</param>
            <param name="dy">16-bit y derivative of input image (same type as dx).</param>
            <param name="edges">output edge map; single channels 8-bit image, which has the same size as image.</param>
            <param name="threshold1">first threshold for the hysteresis procedure.</param>
            <param name="threshold2">second threshold for the hysteresis procedure.</param>
            <param name="L2gradient">Indicates, whether the more accurate L2 norm should be used to compute the image gradient magnitude (true), or a faster default L1 norm is enough (false). [By default this is false]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CornerMinEigenVal(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Calculates the minimal eigenvalue of gradient matrices for corner detection.
            </summary>
            <param name="src">Input single-channel 8-bit or floating-point image.</param>
            <param name="dst">Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as src .</param>
            <param name="blockSize">Neighborhood size (see the details on #cornerEigenValsAndVecs ).</param>
            <param name="ksize">Aperture parameter for the Sobel operator.</param>
            <param name="borderType">Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CornerHarris(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Harris corner detector.
            </summary>
            <param name="src">Input single-channel 8-bit or floating-point image.</param>
            <param name="dst">Image to store the Harris detector responses.
            It has the type CV_32FC1 and the same size as src.</param>
            <param name="blockSize">Neighborhood size (see the details on #cornerEigenValsAndVecs ).</param>
            <param name="ksize">Aperture parameter for the Sobel operator.</param>
            <param name="k">Harris detector free parameter. See the formula above.</param>
            <param name="borderType">Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CornerEigenValsAndVecs(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            computes both eigenvalues and the eigenvectors of 2x2 derivative covariation matrix  at each pixel. The output is stored as 6-channel matrix.
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="blockSize"></param>
            <param name="ksize"></param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PreCornerDetect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            computes another complex cornerness criteria at each pixel
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="ksize"></param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CornerSubPix(ST4IVisionCoreNet.InputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.TermCriteria)">
            <summary>
            adjusts the corner locations with sub-pixel accuracy to maximize the certain cornerness criteria
            </summary>
            <param name="image">Input image.</param>
            <param name="inputCorners">Initial coordinates of the input corners and refined coordinates provided for output.</param>
            <param name="winSize">Half of the side length of the search window.</param>
            <param name="zeroZone">Half of the size of the dead region in the middle of the search zone 
            over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities 
            of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such a size.</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. 
            That is, the process of corner position refinement stops either after criteria.maxCount iterations 
            or when the corner position moves by less than criteria.epsilon on some iteration.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GoodFeaturesToTrack(ST4IVisionCoreNet.InputArray,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.InputArray,System.Int32,System.Boolean,System.Double)">
            <summary>
            finds the strong enough corners where the cornerMinEigenVal() or cornerHarris() report the local maxima
            </summary>
            <param name="src">Input 8-bit or floating-point 32-bit, single-channel image.</param>
            <param name="maxCorners">Maximum number of corners to return. If there are more corners than are found, 
            the strongest of them is returned.</param>
            <param name="qualityLevel">Parameter characterizing the minimal accepted quality of image corners. 
            The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue 
            or the Harris function response (see cornerHarris() ). The corners with the quality measure less than 
            the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01, 
            then all the corners with the quality measure less than 15 are rejected.</param>
            <param name="minDistance">Minimum possible Euclidean distance between the returned corners.</param>
            <param name="mask">Optional region of interest. If the image is not empty
             (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region 
            in which the corners are detected.</param>
            <param name="blockSize">Size of an average block for computing a derivative covariation matrix over each pixel neighborhood.</param>
            <param name="useHarrisDetector">Parameter indicating whether to use a Harris detector</param>
            <param name="k">Free parameter of the Harris detector.</param>
            <returns>Output vector of detected corners.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.HoughLines(ST4IVisionCoreNet.InputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines in a binary image using standard Hough transform.
            </summary>
            <param name="image">The 8-bit, single-channel, binary source image. The image may be modified by the function</param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">The accumulator threshold parameter. Only those lines are returned that get enough votes ( &gt; threshold )</param>
            <param name="srn">For the multi-scale Hough transform it is the divisor for the distance resolution rho. [By default this is 0]</param>
            <param name="stn">For the multi-scale Hough transform it is the divisor for the distance resolution theta. [By default this is 0]</param>
            <returns>The output vector of lines. Each line is represented by a two-element vector (rho, theta) . 
            rho is the distance from the coordinate origin (0,0) (top-left corner of the image) and theta is the line rotation angle in radians</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.HoughLinesP(ST4IVisionCoreNet.InputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines segments in a binary image using probabilistic Hough transform.
            </summary>
            <param name="image"></param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">The accumulator threshold parameter. Only those lines are returned that get enough votes ( &gt; threshold )</param>
            <param name="minLineLength">The minimum line length. Line segments shorter than that will be rejected. [By default this is 0]</param>
            <param name="maxLineGap">The maximum allowed gap between points on the same line to link them. [By default this is 0]</param>
            <returns>The output lines. Each line is represented by a 4-element vector (x1, y1, x2, y2)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.HoughLinesPointSet(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Finds lines in a set of points using the standard Hough transform.
            The function finds lines in a set of points using a modification of the Hough transform.
            </summary>
            <param name="point">Input vector of points. Each vector must be encoded as a Point vector \f$(x,y)\f$. Type must be CV_32FC2 or CV_32SC2.</param>
            <param name="lines">Output vector of found lines. Each vector is encoded as a vector&lt;Vec3d&gt;</param>
            <param name="linesMax">Max count of hough lines.</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes</param>
            <param name="minRho">Minimum Distance value of the accumulator in pixels.</param>
            <param name="maxRho">Maximum Distance value of the accumulator in pixels.</param>
            <param name="rhoStep">Distance resolution of the accumulator in pixels.</param>
            <param name="minTheta">Minimum angle value of the accumulator in radians.</param>
            <param name="maxTheta">Maximum angle value of the accumulator in radians.</param>
            <param name="thetaStep">Angle resolution of the accumulator in radians.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.HoughCircles(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.HoughModes,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in a grayscale image using a Hough transform.
            </summary>
            <param name="image">The 8-bit, single-channel, grayscale input image</param>
            <param name="method">The available methods are HoughMethods.Gradient and HoughMethods.GradientAlt</param>
            <param name="dp">The inverse ratio of the accumulator resolution to the image resolution. </param>
            <param name="minDist">Minimum distance between the centers of the detected circles. </param>
            <param name="param1">The first method-specific parameter. [By default this is 100]</param>
            <param name="param2">The second method-specific parameter. [By default this is 100]</param>
            <param name="minRadius">Minimum circle radius. [By default this is 0]</param>
            <param name="maxRadius">Maximum circle radius. [By default this is 0] </param>
            <returns>The output vector found circles. Each vector is encoded as 3-element floating-point vector (x, y, radius)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MorphologyDefaultBorderValue">
            <summary>
            Default borderValue for Dilate/Erode
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Dilate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Int32,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Dilates an image by using a specific structuring element.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image. It will have the same size and the same type as src</param>
            <param name="element">The structuring element used for dilation. If element=new Mat() , a 3x3 rectangular structuring element is used</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">The number of times dilation is applied. [By default this is 1]</param>
            <param name="borderType">The pixel extrapolation method. [By default this is BorderType.Constant]</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Erode(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Int32,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Erodes an image by using a specific structuring element.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image. It will have the same size and the same type as src</param>
            <param name="element">The structuring element used for dilation. If element=new Mat(), a 3x3 rectangular structuring element is used</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">The number of times erosion is applied</param>
            <param name="borderType">The pixel extrapolation method</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MorphologyEx(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MorphTypes,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Int32,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Performs advanced morphological transformations
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image. It will have the same size and the same type as src</param>
            <param name="op">Type of morphological operation</param>
            <param name="element">Structuring element</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">Number of times erosion and dilation are applied. [By default this is 1]</param>
            <param name="borderType">The pixel extrapolation method. [By default this is BorderType.Constant]</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Resize(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Size,System.Double,System.Double,ST4IVisionCoreNet.InterpolationFlags)">
            <summary>
            Resizes an image.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image; it has the size dsize (when it is non-zero) or the size computed 
            from src.size(), fx, and fy; the type of dst is the same as of src.</param>
            <param name="dsize">output image size; if it equals zero, it is computed as: 
            dsize = Size(round(fx*src.cols), round(fy*src.rows))
            Either dsize or both fx and fy must be non-zero.</param>
            <param name="fx">scale factor along the horizontal axis; when it equals 0, 
            it is computed as: (double)dsize.width/src.cols</param>
            <param name="fy">scale factor along the vertical axis; when it equals 0, 
            it is computed as: (double)dsize.height/src.rows</param>
            <param name="interpolation">interpolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.WarpAffine(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InterpolationFlags,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Applies an affine transformation to an image.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image that has the size dsize and the same type as src.</param>
            <param name="m">2x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods and the optional flag 
            WARP_INVERSE_MAP that means that M is the inverse transformation (dst -> src) .</param>
            <param name="borderMode">pixel extrapolation method; when borderMode=BORDER_TRANSPARENT, 
            it means that the pixels in the destination image corresponding to the "outliers" 
            in the source image are not modified by the function.</param>
            <param name="borderValue">value used in case of a constant border; by default, it is 0.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.WarpPerspective(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InterpolationFlags,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Applies a perspective transformation to an image.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image that has the size dsize and the same type as src.</param>
            <param name="m">3x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) 
            and the optional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (dst -> src).</param>
            <param name="borderMode">pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).</param>
            <param name="borderValue">value used in case of a constant border; by default, it equals 0.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.WarpPerspective(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single[0:,0:],ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InterpolationFlags,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Applies a perspective transformation to an image.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image that has the size dsize and the same type as src.</param>
            <param name="m">3x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) 
            and the optional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (dst -> src).</param>
            <param name="borderMode">pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).</param>
            <param name="borderValue">value used in case of a constant border; by default, it equals 0.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Remap(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InterpolationFlags,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Applies a generic geometrical transformation to an image.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image. It has the same size as map1 and the same type as src</param>
            <param name="map1">The first map of either (x,y) points or just x values having the type CV_16SC2, CV_32FC1, or CV_32FC2.</param>
            <param name="map2">The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively.</param>
            <param name="interpolation">Interpolation method. The method INTER_AREA is not supported by this function.</param>
            <param name="borderMode">Pixel extrapolation method. When borderMode=BORDER_TRANSPARENT, 
            it means that the pixels in the destination image that corresponds to the "outliers" in 
            the source image are not modified by the function.</param>
            <param name="borderValue">Value used in case of a constant border. By default, it is 0.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvertMaps(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,System.Boolean)">
            <summary>
            Converts image transformation maps from one representation to another.
            </summary>
            <param name="map1">The first input map of type CV_16SC2 , CV_32FC1 , or CV_32FC2 .</param>
            <param name="map2">The second input map of type CV_16UC1 , CV_32FC1 , or none (empty matrix), respectively.</param>
            <param name="dstmap1">The first output map that has the type dstmap1type and the same size as src.</param>
            <param name="dstmap2">The second output map.</param>
            <param name="dstmap1Type">Type of the first output map that should be CV_16SC2 , CV_32FC1 , or CV_32FC2 .</param>
            <param name="nnInterpolation">Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetRotationMatrix2D(ST4IVisionCoreNet.Point2f,System.Double,System.Double)">
            <summary>
            Calculates an affine matrix of 2D rotation.
            </summary>
            <param name="center">Center of the rotation in the source image.</param>
            <param name="angle">Rotation angle in degrees. Positive values mean counter-clockwise rotation (the coordinate origin is assumed to be the top-left corner).</param>
            <param name="scale">Isotropic scale factor.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.InvertAffineTransform(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Inverts an affine transformation.
            </summary>
            <param name="m">Original affine transformation.</param>
            <param name="im">Output reverse affine transformation.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetPerspectiveTransform(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            Calculates a perspective transform from four pairs of the corresponding points.
            The function calculates the 3×3 matrix of a perspective transform.
            </summary>
            <param name="src">Coordinates of quadrangle vertices in the source image.</param>
            <param name="dst">Coordinates of the corresponding quadrangle vertices in the destination image.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetPerspectiveTransform(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Calculates a perspective transform from four pairs of the corresponding points.
            The function calculates the 3×3 matrix of a perspective transform.
            </summary>
            <param name="src">Coordinates of quadrangle vertices in the source image.</param>
            <param name="dst">Coordinates of the corresponding quadrangle vertices in the destination image.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetAffineTransform(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            Calculates an affine transform from three pairs of the corresponding points.
            The function calculates the 2×3 matrix of an affine transform.
            </summary>
            <param name="src">Coordinates of triangle vertices in the source image.</param>
            <param name="dst">Coordinates of the corresponding triangle vertices in the destination image.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetAffineTransform(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Calculates an affine transform from three pairs of the corresponding points.
            The function calculates the 2×3 matrix of an affine transform.
            </summary>
            <param name="src">Coordinates of triangle vertices in the source image.</param>
            <param name="dst">Coordinates of the corresponding triangle vertices in the destination image.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetRectSubPix(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Retrieves a pixel rectangle from an image with sub-pixel accuracy.
            </summary>
            <param name="image">Source image.</param>
            <param name="patchSize">Size of the extracted patch.</param>
            <param name="center">Floating point coordinates of the center of the extracted rectangle 
            within the source image. The center must be inside the image.</param>
            <param name="patch">Extracted patch that has the size patchSize and the same number of channels as src .</param>
            <param name="patchType">Depth of the extracted pixels. By default, they have the same depth as src.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.LogPolar(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Point2f,System.Double,ST4IVisionCoreNet.InterpolationFlags)">
            <summary>
            Remaps an image to log-polar space.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center; where the output precision is maximal</param>
            <param name="m">Magnitude scale parameter.</param>
            <param name="flags">A combination of interpolation methods, see cv::InterpolationFlags</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.LinearPolar(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Point2f,System.Double,ST4IVisionCoreNet.InterpolationFlags)">
            <summary>
            Remaps an image to polar space.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center</param>
            <param name="maxRadius">Inverse magnitude scale parameter</param>
            <param name="flags">A combination of interpolation methods, see cv::InterpolationFlags</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.WarpPolar(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Point2f,System.Double,ST4IVisionCoreNet.InterpolationFlags,ST4IVisionCoreNet.WarpPolarMode)">
            <summary>
            Remaps an image to polar or semilog-polar coordinates space.
            </summary>
            <remarks>
            -  The function can not operate in-place.
            -  To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
            -  This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767.
            </remarks>
            <param name="src">Source image.</param>
            <param name="dst">Destination image. It will have same type as src.</param>
            <param name="dsize">The destination image size (see description for valid options).</param>
            <param name="center">The transformation center.</param>
            <param name="maxRadius">The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.</param>
            <param name="interpolationFlags">interpolation methods.</param>
            <param name="warpPolarMode">interpolation methods.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Integral(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Calculates the integral of an image.
            The function calculates one or more integral images for the source image.
            </summary>
            <param name="src"></param>
            <param name="sum"></param>
            <param name="sdepth"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Integral(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Calculates the integral of an image.
            The function calculates one or more integral images for the source image.
            </summary>
            <param name="src"></param>
            <param name="sum"></param>
            <param name="sqsum"></param>
            <param name="sdepth"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Integral(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32)">
            <summary>
            Calculates the integral of an image.
            The function calculates one or more integral images for the source image.
            </summary>
            <param name="src">input image as W×H, 8-bit or floating-point (32f or 64f).</param>
            <param name="sum">integral image as (W+1)×(H+1) , 32-bit integer or floating-point (32f or 64f).</param>
            <param name="sqsum">integral image for squared pixel values; it is (W+1)×(H+1), double-precision floating-point (64f) array.</param>
            <param name="tilted">integral for the image rotated by 45 degrees; it is (W+1)×(H+1) array with the same data type as sum.</param>
            <param name="sdepth">desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F.</param>
            <param name="sqdepth">desired depth of the integral image of squared pixel values, CV_32F or CV_64F.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Accumulate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Adds an image to the accumulator.
            </summary>
            <param name="src">Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</param>
            <param name="dst">Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</param>
            <param name="mask">Optional operation mask.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.AccumulateSquare(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Adds the square of a source image to the accumulator.
            </summary>
            <param name="src">Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</param>
            <param name="dst">Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</param>
            <param name="mask">Optional operation mask.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.AccumulateProduct(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Adds the per-element product of two input images to the accumulator.
            </summary>
            <param name="src1">First input image, 1- or 3-channel, 8-bit or 32-bit floating point.</param>
            <param name="src2">Second input image of the same type and the same size as src1</param>
            <param name="dst">Accumulator with the same number of channels as input images, 32-bit or 64-bit floating-point.</param>
            <param name="mask">Optional operation mask.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.AccumulateWeighted(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,System.Double,ST4IVisionCoreNet.InputArray)">
            <summary>
            Updates a running average.
            </summary>
            <param name="src">Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</param>
            <param name="dst">Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</param>
            <param name="alpha">Weight of the input image.</param>
            <param name="mask">Optional operation mask.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PhaseCorrelate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Double@)">
            <summary>
            The function is used to detect translational shifts that occur between two images.
            
            The operation takes advantage of the Fourier shift theorem for detecting the translational shift in
            the frequency domain.It can be used for fast image registration as well as motion estimation.
            For more information please see http://en.wikipedia.org/wiki/Phase_correlation.
            
            Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed with getOptimalDFTSize.
            </summary>
            <param name="src1">Source floating point array (CV_32FC1 or CV_64FC1)</param>
            <param name="src2">Source floating point array (CV_32FC1 or CV_64FC1)</param>
            <param name="window">Floating point array with windowing coefficients to reduce edge effects (optional).</param>
            <param name="response">Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).</param>
            <returns>detected phase shift(sub-pixel) between the two arrays.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateHanningWindow(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Computes a Hanning window coefficients in two dimensions.
            </summary>
            <param name="dst">Destination array to place Hann coefficients in</param>
            <param name="winSize">The window size specifications</param>
            <param name="type">Created array type</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Threshold(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,ST4IVisionCoreNet.ThresholdTypes)">
            <summary>
            Applies a fixed-level threshold to each array element.
            </summary>
            <param name="src">input array (single-channel, 8-bit or 32-bit floating point).</param>
            <param name="dst">output array of the same size and type as src.</param>
            <param name="thresh">threshold value.</param>
            <param name="maxval">maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types.</param>
            <param name="type">thresholding type (see the details below).</param>
            <returns>the computed threshold value when type == OTSU</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.AdaptiveThreshold(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,ST4IVisionCoreNet.AdaptiveThresholdTypes,ST4IVisionCoreNet.ThresholdTypes,System.Int32,System.Double)">
            <summary>
            Applies an adaptive threshold to an array.
            </summary>
            <param name="src">Source 8-bit single-channel image.</param>
            <param name="dst">Destination image of the same size and the same type as src .</param>
            <param name="maxValue">Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.</param>
            <param name="adaptiveMethod">Adaptive thresholding algorithm to use, ADAPTIVE_THRESH_MEAN_C or ADAPTIVE_THRESH_GAUSSIAN_C .</param>
            <param name="thresholdType">Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV .</param>
            <param name="blockSize">Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</param>
            <param name="c">Constant subtracted from the mean or weighted mean (see the details below). 
            Normally, it is positive but may be zero or negative as well.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PyrDown(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Nullable{ST4IVisionCoreNet.Size},ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Blurs an image and downsamples it.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image; it has the specified size and the same type as src.</param>
            <param name="dstSize">size of the output image; by default, it is computed as Size((src.cols+1)/2</param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PyrUp(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Nullable{ST4IVisionCoreNet.Size},ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Upsamples an image and then blurs it.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image. It has the specified size and the same type as src.</param>
            <param name="dstSize">size of the output image; by default, it is computed as Size(src.cols*2, (src.rows*2)</param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalcHist(ST4IVisionCoreNet.Mat[],System.Int32[],ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32[],ST4IVisionCoreNet.Rangef[],System.Boolean,System.Boolean)">
            <summary>
            computes the joint dense histogram for a set of images.
            </summary>
            <param name="images"></param>
            <param name="channels"></param>
            <param name="mask"></param>
            <param name="hist"></param>
            <param name="dims"></param>
            <param name="histSize"></param>
            <param name="ranges"></param>
            <param name="uniform"></param>
            <param name="accumulate"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalcHist(ST4IVisionCoreNet.Mat[],System.Int32[],ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32[],System.Single[][],System.Boolean,System.Boolean)">
            <summary>
            computes the joint dense histogram for a set of images.
            </summary>
            <param name="images"></param>
            <param name="channels"></param>
            <param name="mask"></param>
            <param name="hist"></param>
            <param name="dims"></param>
            <param name="histSize"></param>
            <param name="ranges"></param>
            <param name="uniform"></param>
            <param name="accumulate"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalcBackProject(ST4IVisionCoreNet.Mat[],System.Int32[],ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Rangef[],System.Boolean)">
            <summary>
            computes the joint dense histogram for a set of images.
            </summary>
            <param name="images"></param>
            <param name="channels"></param>
            <param name="hist"></param>
            <param name="backProject"></param>
            <param name="ranges"></param>
            <param name="uniform"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CompareHist(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.HistCompMethods)">
            <summary>
            compares two histograms stored in dense arrays
            </summary>
            <param name="h1">The first compared histogram</param>
            <param name="h2">The second compared histogram of the same size as h1</param>
            <param name="method">The comparison method</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EqualizeHist(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            normalizes the grayscale image brightness and contrast by normalizing its histogram
            </summary>
            <param name="src">The source 8-bit single channel image</param>
            <param name="dst">The destination image; will have the same size and the same type as src</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateCLAHE(System.Double,System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            Creates a predefined CLAHE object
            </summary>
            <param name="clipLimit"></param>
            <param name="tileGridSize"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EMD(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.DistanceTypes)">
             <summary>
             Computes the "minimal work" distance between two weighted point configurations.
            
             The function computes the earth mover distance and/or a lower boundary of the distance between the
             two weighted point configurations.One of the applications described in @cite RubnerSept98,
             @cite Rubner2000 is multi-dimensional histogram comparison for image retrieval.EMD is a transportation
             problem that is solved using some modification of a simplex algorithm, thus the complexity is
             exponential in the worst case, though, on average it is much faster.In the case of a real metric
             the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
             to determine roughly whether the two signatures are far enough so that they cannot relate to the same object.
             </summary>
             <param name="signature1">First signature, a \f$\texttt{size1}\times \texttt{dims}+1\f$ floating-point matrix. 
             Each row stores the point weight followed by the point coordinates.The matrix is allowed to have
             a single column(weights only) if the user-defined cost matrix is used.The weights must be non-negative
             and have at least one non-zero value.</param>
             <param name="signature2">Second signature of the same format as signature1 , though the number of rows
             may be different.The total weights may be different.In this case an extra "dummy" point is added
             to either signature1 or signature2. The weights must be non-negative and have at least one non-zero value.</param>
             <param name="distType">Used metric.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EMD(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.DistanceTypes,ST4IVisionCoreNet.InputArray)">
             <summary>
             Computes the "minimal work" distance between two weighted point configurations.
            
             The function computes the earth mover distance and/or a lower boundary of the distance between the
             two weighted point configurations.One of the applications described in @cite RubnerSept98,
             @cite Rubner2000 is multi-dimensional histogram comparison for image retrieval.EMD is a transportation
             problem that is solved using some modification of a simplex algorithm, thus the complexity is
             exponential in the worst case, though, on average it is much faster.In the case of a real metric
             the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
             to determine roughly whether the two signatures are far enough so that they cannot relate to the same object.
             </summary>
             <param name="signature1">First signature, a \f$\texttt{size1}\times \texttt{dims}+1\f$ floating-point matrix. 
             Each row stores the point weight followed by the point coordinates.The matrix is allowed to have
             a single column(weights only) if the user-defined cost matrix is used.The weights must be non-negative
             and have at least one non-zero value.</param>
             <param name="signature2">Second signature of the same format as signature1 , though the number of rows
             may be different.The total weights may be different.In this case an extra "dummy" point is added
             to either signature1 or signature2. The weights must be non-negative and have at least one non-zero value.</param>
             <param name="distType">Used metric.</param>
             <param name="cost">User-defined size1 x size2 cost matrix. Also, if a cost matrix
             is used, lower boundary lowerBound cannot be calculated because it needs a metric function.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EMD(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.DistanceTypes,ST4IVisionCoreNet.InputArray,System.Single@,ST4IVisionCoreNet.OutputArray)">
             <summary>
             Computes the "minimal work" distance between two weighted point configurations.
            
             The function computes the earth mover distance and/or a lower boundary of the distance between the
             two weighted point configurations.One of the applications described in @cite RubnerSept98,
             @cite Rubner2000 is multi-dimensional histogram comparison for image retrieval.EMD is a transportation
             problem that is solved using some modification of a simplex algorithm, thus the complexity is
             exponential in the worst case, though, on average it is much faster.In the case of a real metric
             the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
             to determine roughly whether the two signatures are far enough so that they cannot relate to the same object.
             </summary>
             <param name="signature1">First signature, a \f$\texttt{size1}\times \texttt{dims}+1\f$ floating-point matrix. 
             Each row stores the point weight followed by the point coordinates.The matrix is allowed to have
             a single column(weights only) if the user-defined cost matrix is used.The weights must be non-negative
             and have at least one non-zero value.</param>
             <param name="signature2">Second signature of the same format as signature1 , though the number of rows
             may be different.The total weights may be different.In this case an extra "dummy" point is added
             to either signature1 or signature2. The weights must be non-negative and have at least one non-zero value.</param>
             <param name="distType">Used metric.</param>
             <param name="cost">User-defined size1 x size2 cost matrix. Also, if a cost matrix
             is used, lower boundary lowerBound cannot be calculated because it needs a metric function.</param>
             <param name="lowerBound">Optional input/output parameter: lower boundary of a distance between the two
             signatures that is a distance between mass centers.The lower boundary may not be calculated if
             the user-defined cost matrix is used, the total weights of point configurations are not equal, or
             if the signatures consist of weights only(the signature matrices have a single column). You ** must**
             initialize \*lowerBound.If the calculated distance between mass centers is greater or equal to
             \*lowerBound(it means that the signatures are far enough), the function does not calculate EMD.
             In any case \*lowerBound is set to the calculated distance between mass centers on return.
             Thus, if you want to calculate both distance between mass centers and EMD, \*lowerBound should be set to 0.</param>
             <param name="flow">Resultant size1 x size2 flow matrix: flow[i,j] is  a flow from i-th point of signature1
             to j-th point of signature2.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Watershed(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray)">
            <summary>
            Performs a marker-based image segmentation using the watershed algorithm.
            </summary>
            <param name="image">Input 8-bit 3-channel image.</param>
            <param name="markers">Input/output 32-bit single-channel image (map) of markers. 
            It should have the same size as image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PyrMeanShiftFiltering(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,System.Int32,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            Performs initial step of meanshift segmentation of an image.
            </summary>
            <param name="src">The source 8-bit, 3-channel image.</param>
            <param name="dst">The destination image of the same format and the same size as the source.</param>
            <param name="sp">The spatial window radius.</param>
            <param name="sr">The color window radius.</param>
            <param name="maxLevel">Maximum level of the pyramid for the segmentation.</param>
            <param name="termcrit">Termination criteria: when to stop meanshift iterations.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GrabCut(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,System.Int32,ST4IVisionCoreNet.GrabCutModes)">
            <summary>
            Segments the image using GrabCut algorithm
            </summary>
            <param name="img">Input 8-bit 3-channel image.</param>
            <param name="mask">Input/output 8-bit single-channel mask. 
            The mask is initialized by the function when mode is set to GC_INIT_WITH_RECT. 
            Its elements may have Sv.GC_BGD / Sv.GC_FGD / Sv.GC_PR_BGD / Sv.GC_PR_FGD</param>
            <param name="rect">ROI containing a segmented object. The pixels outside of the ROI are 
            marked as "obvious background". The parameter is only used when mode==GC_INIT_WITH_RECT.</param>
            <param name="bgdModel">Temporary array for the background model. Do not modify it while you are processing the same image.</param>
            <param name="fgdModel">Temporary arrays for the foreground model. Do not modify it while you are processing the same image.</param>
            <param name="iterCount">Number of iterations the algorithm should make before returning the result. 
            Note that the result can be refined with further calls with mode==GC_INIT_WITH_MASK or mode==GC_EVAL .</param>
            <param name="mode">Operation mode that could be one of GrabCutFlag value.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DistanceTransformWithLabels(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DistanceTypes,ST4IVisionCoreNet.DistanceTransformMasks,ST4IVisionCoreNet.DistanceTransformLabelTypes)">
            <summary>
            Calculates the distance to the closest zero pixel for each pixel of the source image.
            </summary>
            <param name="src">8-bit, single-channel (binary) source image.</param>
            <param name="dst">Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
            single-channel image of the same size as src.</param>
            <param name="labels">Output 2D array of labels (the discrete Voronoi diagram). It has the type
            CV_32SC1 and the same size as src.</param>
            <param name="distanceType">Type of distance</param>
            <param name="maskSize">Size of the distance transform mask, see #DistanceTransformMasks.
            #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type,
            the parameter is forced to 3 because a 3x3 mask gives the same result as 5x5 or any larger aperture.</param>
            <param name="labelType">Type of the label array to build</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DistanceTransform(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DistanceTypes,ST4IVisionCoreNet.DistanceTransformMasks,System.Int32)">
            <summary>
            computes the distance transform map
            </summary>
            <param name="src">8-bit, single-channel (binary) source image.</param>
            <param name="dst">Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
            single-channel image of the same size as src.</param>
            <param name="distanceType">Type of distance</param>
            <param name="maskSize">Size of the distance transform mask, see #DistanceTransformMasks. In case of the
            #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a 3x3 mask gives
            the same result as 5x5 or any larger aperture.</param>
            <param name="dstType">Type of output image. It can be MatType.CV_8U or MatType.CV_32F.
            Type CV_8U can be used only for  the first variant of the function and distanceType == #DIST_L1.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FloodFill(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar)">
            <summary>
            Fills a connected component with the given color.
            </summary>
            <param name="image">Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FloodFill(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Rect@,System.Nullable{ST4IVisionCoreNet.Scalar},System.Nullable{ST4IVisionCoreNet.Scalar},ST4IVisionCoreNet.FloodFillFlags)">
            <summary>
            Fills a connected component with the given color.
            </summary>
            <param name="image">Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <param name="rect">Optional output parameter set by the function to the 
            minimum bounding rectangle of the repainted domain.</param>
            <param name="loDiff">Maximal lower brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="upDiff">Maximal upper brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="flags">Operation flags. Lower bits contain a connectivity value, 
            4 (default) or 8, used within the function. Connectivity determines which 
            neighbors of a pixel are considered. Using FloodFillFlags.MaskOnly will
            fill in the mask using the grey value 255 (white). </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FloodFill(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar)">
            <summary>
            Fills a connected component with the given color.
            </summary>
            <param name="image">Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.</param>
            <param name="mask">(For the second function only) Operation mask that should be a single-channel 8-bit image, 
            2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of 
            initializing the mask content. Flood-filling cannot go across non-zero pixels in the mask. For example, 
            an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask 
            in multiple calls to the function to make sure the filled area does not overlap.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FloodFill(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Rect@,System.Nullable{ST4IVisionCoreNet.Scalar},System.Nullable{ST4IVisionCoreNet.Scalar},ST4IVisionCoreNet.FloodFillFlags)">
            <summary>
            Fills a connected component with the given color.
            </summary>
            <param name="image">Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.</param>
            <param name="mask">(For the second function only) Operation mask that should be a single-channel 8-bit image, 
            2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of 
            initializing the mask content. Flood-filling cannot go across non-zero pixels in the mask. For example, 
            an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask 
            in multiple calls to the function to make sure the filled area does not overlap.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <param name="rect">Optional output parameter set by the function to the 
            minimum bounding rectangle of the repainted domain.</param>
            <param name="loDiff">Maximal lower brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="upDiff">Maximal upper brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="flags">Operation flags. Lower bits contain a connectivity value, 
            4 (default) or 8, used within the function. Connectivity determines which 
            neighbors of a pixel are considered. Using FloodFillFlags.MaskOnly will
            fill in the mask using the grey value 255 (white). </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BlendLinear(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Performs linear blending of two images:
            dst(i,j) = weights1(i,j)*src1(i,j) + weights2(i,j)*src2(i,j)
            </summary>
            <param name="src1">It has a type of CV_8UC(n) or CV_32FC(n), where n is a positive integer.</param>
            <param name="src2">It has the same type and size as src1.</param>
            <param name="weights1">It has a type of CV_32FC1 and the same size with src1.</param>
            <param name="weights2">It has a type of CV_32FC1 and the same size with src1.</param>
            <param name="dst">It is created if it does not have the same size and type with src1.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CvtColor(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ColorConversionCodes,System.Int32)">
            <summary>
            Converts image from one color space to another
            </summary>
            <param name="src">The source image, 8-bit unsigned, 16-bit unsigned or single-precision floating-point</param>
            <param name="dst">The destination image; will have the same size and the same depth as src</param>
            <param name="code">The color space conversion code</param>
            <param name="dstCn">The number of channels in the destination image; if the parameter is 0, the number of the channels will be derived automatically from src and the code</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CvtColorTwoPlane(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ColorConversionCodes)">
            <summary>
            Converts an image from one color space to another where the source image is stored in two planes.
            This function only supports YUV420 to RGB conversion as of now.
            </summary>
            <param name="src1">8-bit image (#CV_8U) of the Y plane.</param>
            <param name="src2">image containing interleaved U/V plane.</param>
            <param name="dst">output image.</param>
            <param name="code">Specifies the type of conversion. It can take any of the following values:
            - #COLOR_YUV2BGR_NV12
            - #COLOR_YUV2RGB_NV12
            - #COLOR_YUV2BGRA_NV12
            - #COLOR_YUV2RGBA_NV12
            - #COLOR_YUV2BGR_NV21
            - #COLOR_YUV2RGB_NV21
            - #COLOR_YUV2BGRA_NV21
            - #COLOR_YUV2RGBA_NV21</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Demosaicing(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ColorConversionCodes,System.Int32)">
             <summary>
             main function for all demosaicing processes
             </summary>
             <param name="src">input image: 8-bit unsigned or 16-bit unsigned.</param>
             <param name="dst">output image of the same size and depth as src.</param>
             <param name="code">Color space conversion code (see the description below).</param>
             <param name="dstCn">number of channels in the destination image; if the parameter is 0,
             the number of the channels is derived automatically from src and code.</param>
             <remarks>
             The function can do the following transformations:
            
             -   Demosaicing using bilinear interpolation
             
                 #COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR
                 #COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY
            
             -   Demosaicing using Variable Number of Gradients.
            
                 #COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG
            
             -   Edge-Aware Demosaicing.
            
                 #COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA
            
             -   Demosaicing with alpha channel
            
                 # COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA
             </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Moments(ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (single-channel, 8-bit or floating-point 
            2D array) or an array ( 1xN or Nx1 ) of 2D points ( Point or Point2f )</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Moments(System.Byte[0:,0:],System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (8-bit) 2D array</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Moments(System.Single[0:,0:],System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (floating-point) 2D array</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Moments(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">Array of 2D points</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Moments(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">Array of 2D points</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MatchTemplate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.TemplateMatchModes,ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes the proximity map for the raster template and the image where the template is searched for
            </summary>
            <param name="image">Image where the search is running; should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and have the same data type</param>
            <param name="result">A map of comparison results; will be single-channel 32-bit floating-point. 
            If image is WxH and templ is wxh then result will be (W-w+1) x (H-h+1).</param>
            <param name="method">Specifies the comparison method</param>
            <param name="mask">Mask of searched template. It must have the same datatype and size with templ. It is not set by default.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConnectedComponentsWithAlgorithm(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes)">
             <summary>
             Computes the connected components labeled image of boolean image.
            
             image with 4 or 8 way connectivity - returns N, the total number of labels[0, N - 1] where 0
             represents the background label.ltype specifies the output label image type, an important
             consideration based on the total number of labels or alternatively the total number of pixels in
             the source image.ccltype specifies the connected components labeling algorithm to use, currently
             Grana (BBDT) and Wu's (SAUF) algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes
             for details.Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.
             This function uses parallel version of both Grana and Wu's algorithms if at least one allowed
             parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.
             </summary>
             <param name="image">the 8-bit single-channel image to be labeled</param>
             <param name="labels">destination labeled image</param>
             <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
             <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
             <param name="ccltype">connected components algorithm type.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConnectedComponents(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled image</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConnectedComponents(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity,ST4IVisionCoreNet.MatType)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled image</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConnectedComponents(ST4IVisionCoreNet.InputArray,System.Int32[0:,0:]@,ST4IVisionCoreNet.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled rectangular array</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConnectedComponentsWithStatsWithAlgorithm(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes)">
             <summary>
             computes the connected components labeled image of boolean image and also produces a statistics output for each label.
            
             image with 4 or 8 way connectivity - returns N, the total number of labels[0, N - 1] where 0
             represents the background label.ltype specifies the output label image type, an important
             consideration based on the total number of labels or alternatively the total number of pixels in
             the source image.ccltype specifies the connected components labeling algorithm to use, currently
             Grana's (BBDT) and Wu's (SAUF) algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes
             for details.Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.
             This function uses parallel version of both Grana and Wu's algorithms (statistics included) if at least one allowed
             parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.
             </summary>
             <param name="image">the 8-bit single-channel image to be labeled</param>
             <param name="labels">destination labeled image</param>
             <param name="stats">statistics output for each label, including the background label, see below for
             available statistics.Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes. The data type is CV_32S.</param>
             <param name="centroids">centroid output for each label, including the background label. Centroids are
             accessed via centroids(label, 0) for x and centroids(label, 1) for y.The data type CV_64F.</param>
             <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
             <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
             <param name="ccltype">connected components algorithm type.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConnectedComponentsWithStats(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled image</param>
            <param name="stats">statistics output for each label, including the background label, 
            see below for available statistics. Statistics are accessed via stats(label, COLUMN) 
            where COLUMN is one of cv::ConnectedComponentsTypes</param>
            <param name="centroids">floating point centroid (x,y) output for each label, 
            including the background label</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConnectedComponentsWithStats(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity,ST4IVisionCoreNet.MatType)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled image</param>
            <param name="stats">statistics output for each label, including the background label, 
            see below for available statistics. Statistics are accessed via stats(label, COLUMN) 
            where COLUMN is one of cv::ConnectedComponentsTypes</param>
            <param name="centroids">floating point centroid (x,y) output for each label, 
            including the background label</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConnectedComponentsEx(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.PixelConnectivity,ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ccltype"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindContours(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point[][]@,ST4IVisionCoreNet.HierarchyIndex[]@,ST4IVisionCoreNet.RetrievalModes,ST4IVisionCoreNet.ContourApproximationModes,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds contours in a binary image.
            </summary>
            <param name="image">Source, an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary.
            The function modifies the image while extracting the contours.</param> 
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology. 
            It has as many elements as the number of contours. For each i-th contour contours[i], 
            the members of the elements hierarchy[i] are set to 0-based indices in contours of the next 
            and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. 
            If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.</param>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindContours(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Mat[]@,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.RetrievalModes,ST4IVisionCoreNet.ContourApproximationModes,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds contours in a binary image.
            </summary>
            <param name="image">Source, an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary.
            The function modifies the image while extracting the contours.</param> 
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology. 
            It has as many elements as the number of contours. For each i-th contour contours[i], 
            the members of the elements hierarchy[i] are set to 0-based indices in contours of the next 
            and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. 
            If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.</param>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindContoursAsArray(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.RetrievalModes,ST4IVisionCoreNet.ContourApproximationModes,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds contours in a binary image.
            </summary>
            <param name="image">Source, an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary.
            The function modifies the image while extracting the contours.</param> 
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
            <returns>Detected contours. Each contour is stored as a vector of points.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindContoursAsMat(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.RetrievalModes,ST4IVisionCoreNet.ContourApproximationModes,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds contours in a binary image.
            </summary>
            <param name="image">Source, an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary.
            The function modifies the image while extracting the contours.</param> 
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
            <returns>Detected contours. Each contour is stored as a vector of points.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ApproxPolyDP(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Boolean)">
            <summary>
            Approximates contour or a curve using Douglas-Peucker algorithm
            </summary>
            <param name="curve">The polygon or curve to approximate. 
            Must be 1 x N or N x 1 matrix of type CV_32SC2 or CV_32FC2.</param>
            <param name="approxCurve">The result of the approximation; 
            The type should match the type of the input curve</param>
            <param name="epsilon">Specifies the approximation accuracy. 
            This is the maximum distance between the original curve and its approximation.</param>
            <param name="closed">The result of the approximation; 
            The type should match the type of the input curve</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ApproxPolyDP(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Double,System.Boolean)">
            <summary>
            Approximates contour or a curve using Douglas-Peucker algorithm
            </summary>
            <param name="curve">The polygon or curve to approximate.</param>
            <param name="epsilon">Specifies the approximation accuracy. 
            This is the maximum distance between the original curve and its approximation.</param>
            <param name="closed">The result of the approximation; 
            The type should match the type of the input curve</param>
            <returns>The result of the approximation; 
            The type should match the type of the input curve</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ApproxPolyDP(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Double,System.Boolean)">
            <summary>
            Approximates contour or a curve using Douglas-Peucker algorithm
            </summary>
            <param name="curve">The polygon or curve to approximate.</param>
            <param name="epsilon">Specifies the approximation accuracy. 
            This is the maximum distance between the original curve and its approximation.</param>
            <param name="closed">If true, the approximated curve is closed 
            (i.e. its first and last vertices are connected), otherwise it’s not</param>
            <returns>The result of the approximation; 
            The type should match the type of the input curve</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ArcLength(ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length.
            </summary>
            <param name="curve">The input vector of 2D points, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <param name="closed">Indicates, whether the curve is closed or not.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ArcLength(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length.
            </summary>
            <param name="curve">The input vector of 2D points.</param>
            <param name="closed">Indicates, whether the curve is closed or not.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ArcLength(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length.
            </summary>
            <param name="curve">The input vector of 2D points.</param>
            <param name="closed">Indicates, whether the curve is closed or not.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BoundingRect(ST4IVisionCoreNet.InputArray)">
            <summary>
            Calculates the up-right bounding rectangle of a point set.
            </summary>
            <param name="curve">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns>Minimal up-right bounding rectangle for the specified point set.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BoundingRect(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point})">
            <summary>
            Calculates the up-right bounding rectangle of a point set.
            </summary>
            <param name="curve">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns>Minimal up-right bounding rectangle for the specified point set.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BoundingRect(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            Calculates the up-right bounding rectangle of a point set.
            </summary>
            <param name="curve">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns>Minimal up-right bounding rectangle for the specified point set.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ContourArea(ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            Calculates the contour area
            </summary>
            <param name="contour">The contour vertices, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="oriented"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ContourArea(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Boolean)">
            <summary>
            Calculates the contour area
            </summary>
            <param name="contour">The contour vertices, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="oriented"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ContourArea(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Boolean)">
            <summary>
            Calculates the contour area
            </summary>
            <param name="contour">The contour vertices, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="oriented"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinAreaRect(ST4IVisionCoreNet.InputArray)">
            <summary>
            Finds the minimum area rotated rectangle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinAreaRect(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds the minimum area rotated rectangle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinAreaRect(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            Finds the minimum area rotated rectangle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BoxPoints(ST4IVisionCoreNet.RotatedRect,ST4IVisionCoreNet.OutputArray)">
             <summary>
             Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.
            
             The function finds the four vertices of a rotated rectangle.This function is useful to draw the 
             rectangle.In C++, instead of using this function, you can directly use RotatedRect::points method. Please
             visit the @ref tutorial_bounding_rotated_ellipses "tutorial on Creating Bounding rotated boxes and ellipses for contours" for more information.
             </summary>
             <param name="box">The input rotated rectangle. It may be the output of</param>
             <param name="points">The output array of four vertices of rectangles.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BoxPoints(ST4IVisionCoreNet.RotatedRect)">
             <summary>
             Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.
            
             The function finds the four vertices of a rotated rectangle.This function is useful to draw the 
             rectangle.In C++, instead of using this function, you can directly use RotatedRect::points method. Please
             visit the @ref tutorial_bounding_rotated_ellipses "tutorial on Creating Bounding rotated boxes and ellipses for contours" for more information.
             </summary>
             <param name="box">The input rotated rectangle. It may be the output of</param>
             <returns>The output array of four vertices of rectangles.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinEnclosingCircle(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f@,System.Single@)">
            <summary>
            Finds the minimum area circle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <param name="center">The output center of the circle</param>
            <param name="radius">The output radius of the circle</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinEnclosingCircle(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.Point2f@,System.Single@)">
            <summary>
            Finds the minimum area circle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <param name="center">The output center of the circle</param>
            <param name="radius">The output radius of the circle</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinEnclosingCircle(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.Point2f@,System.Single@)">
            <summary>
            Finds the minimum area circle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <param name="center">The output center of the circle</param>
            <param name="radius">The output radius of the circle</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinEnclosingTriangle(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Finds a triangle of minimum area enclosing a 2D point set and returns its area.
            </summary>
            <param name="points">Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector or Mat</param>
            <param name="triangle">Output vector of three 2D points defining the vertices of the triangle. The depth</param>
            <returns>Triangle area</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinEnclosingTriangle(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.Point2f[]@)">
            <summary>
            Finds a triangle of minimum area enclosing a 2D point set and returns its area.
            </summary>
            <param name="points">Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector or Mat</param>
            <param name="triangle">Output vector of three 2D points defining the vertices of the triangle. The depth</param>
            <returns>Triangle area</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MinEnclosingTriangle(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.Point2f[]@)">
            <summary>
            Finds a triangle of minimum area enclosing a 2D point set and returns its area.
            </summary>
            <param name="points">Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector or Mat</param>
            <param name="triangle">Output vector of three 2D points defining the vertices of the triangle. The depth</param>
            <returns>Triangle area</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MatchShapes(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.ShapeMatchModes,System.Double)">
            <summary>
            Compares two shapes.
            </summary>
            <param name="contour1">First contour or grayscale image.</param>
            <param name="contour2">Second contour or grayscale image.</param>
            <param name="method">Comparison method</param>
            <param name="parameter">Method-specific parameter (not supported now)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MatchShapes(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.ShapeMatchModes,System.Double)">
            <summary>
            Compares two shapes.
            </summary>
            <param name="contour1">First contour or grayscale image.</param>
            <param name="contour2">Second contour or grayscale image.</param>
            <param name="method">Comparison method</param>
            <param name="parameter">Method-specific parameter (not supported now)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvexHull(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Boolean,System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="hull">The output convex hull. It is either a vector of points that form the 
            hull (must have the same type as the input points), or a vector of 0-based point 
            indices of the hull points in the original array (since the set of convex hull 
            points is a subset of the original point set).</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <param name="returnPoints"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvexHull(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of points that form 
            the hull (must have the same type as the input points).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvexHull(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of points that form 
            the hull (must have the same type as the input points).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvexHullIndices(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of 0-based point indices of the 
            hull points in the original array (since the set of convex hull points is a subset of the original point set).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvexHullIndices(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of 0-based point indices of the 
            hull points in the original array (since the set of convex hull points is a subset of the original point set).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvexityDefects(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="contour">Input contour.</param>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <param name="convexityDefects">
            The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0.
            </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvexityDefects(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="contour">Input contour.</param>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <returns>The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ConvexityDefects(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="contour">Input contour.</param>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <returns>The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.IsContourConvex(ST4IVisionCoreNet.InputArray)">
            <summary>
            returns true if the contour is convex. 
            Does not support contours with self-intersection
            </summary>
            <param name="contour">Input vector of 2D points</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.IsContourConvex(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point})">
            <summary>
            returns true if the contour is convex. 
            Does not support contours with self-intersection
            </summary>
            <param name="contour">Input vector of 2D points</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.IsContourConvex(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            returns true if the contour is convex. D
            oes not support contours with self-intersection
            </summary>
            <param name="contour">Input vector of 2D points</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.IntersectConvexConvex(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            finds intersection of two convex polygons
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p12"></param>
            <param name="handleNested"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.IntersectConvexConvex(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.Point[]@,System.Boolean)">
            <summary>
            finds intersection of two convex polygons
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p12"></param>
            <param name="handleNested"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.IntersectConvexConvex(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.Point2f[]@,System.Boolean)">
            <summary>
            finds intersection of two convex polygons
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p12"></param>
            <param name="handleNested"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipse(ST4IVisionCoreNet.InputArray)">
            <summary>
            Fits ellipse to the set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipse(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point})">
            <summary>
            Fits ellipse to the set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipse(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            Fits ellipse to the set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipseAMS(ST4IVisionCoreNet.InputArray)">
            <summary>
            Fits an ellipse around a set of 2D points.
            
            The function calculates the ellipse that fits a set of 2D points.
            It returns the rotated rectangle in which the ellipse is inscribed.
            The Approximate Mean Square(AMS) proposed by @cite Taubin1991 is used.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipseAMS(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point})">
            <summary>
            Fits an ellipse around a set of 2D points.
            
            The function calculates the ellipse that fits a set of 2D points.
            It returns the rotated rectangle in which the ellipse is inscribed.
            The Approximate Mean Square(AMS) proposed by @cite Taubin1991 is used.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipseAMS(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            Fits an ellipse around a set of 2D points.
            
            The function calculates the ellipse that fits a set of 2D points.
            It returns the rotated rectangle in which the ellipse is inscribed.
            The Approximate Mean Square(AMS) proposed by @cite Taubin1991 is used.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipseDirect(ST4IVisionCoreNet.InputArray)">
             <summary>
             Fits an ellipse around a set of 2D points.
            
             The function calculates the ellipse that fits a set of 2D points.
             It returns the rotated rectangle in which the ellipse is inscribed.
             The Direct least square(Direct) method by @cite Fitzgibbon1999 is used.
             </summary>
             <param name="points">Input 2D point set</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipseDirect(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point})">
             <summary>
             Fits an ellipse around a set of 2D points.
            
             The function calculates the ellipse that fits a set of 2D points.
             It returns the rotated rectangle in which the ellipse is inscribed.
             The Direct least square(Direct) method by @cite Fitzgibbon1999 is used.
             </summary>
             <param name="points">Input 2D point set</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitEllipseDirect(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
             <summary>
             Fits an ellipse around a set of 2D points.
            
             The function calculates the ellipse that fits a set of 2D points.
             It returns the rotated rectangle in which the ellipse is inscribed.
             The Direct least square(Direct) method by @cite Fitzgibbon1999 is used.
             </summary>
             <param name="points">Input 2D point set</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitLine(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 2D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="line">Output line parameters. 
            In case of 2D fitting, it should be a vector of 4 elements 
            (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector 
            collinear to the line and (x0, y0) is a point on the line. 
            In case of 3D fitting, it should be a vector of 6 elements 
            (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a 
            normalized vector collinear to the line and (x0, y0, z0) is a point on the line.</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitLine(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 2D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitLine(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 2D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitLine(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3i},ST4IVisionCoreNet.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 3D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FitLine(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f},ST4IVisionCoreNet.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 3D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PointPolygonTest(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f,System.Boolean)">
            <summary>
            Checks if the point is inside the contour. Optionally computes the signed distance from the point to the contour boundary
            </summary>
            <param name="contour"></param>
            <param name="pt"></param>
            <param name="measureDist"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PointPolygonTest(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.Point2f,System.Boolean)">
            <summary>
            Checks if the point is inside the contour. Optionally computes the signed distance from the point to the contour boundary
            </summary>
            <param name="contour"></param>
            <param name="pt"></param>
            <param name="measureDist"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PointPolygonTest(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.Point2f,System.Boolean)">
            <summary>
            Checks if the point is inside the contour. 
            Optionally computes the signed distance from the point to the contour boundary.
            </summary>
            <param name="contour">Input contour.</param>
            <param name="pt">Point tested against the contour.</param>
            <param name="measureDist">If true, the function estimates the signed distance 
            from the point to the nearest contour edge. Otherwise, the function only checks 
            if the point is inside a contour or not.</param>
            <returns>Positive (inside), negative (outside), or zero (on an edge) value.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RotatedRectangleIntersection(ST4IVisionCoreNet.RotatedRect,ST4IVisionCoreNet.RotatedRect,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Finds out if there is any intersection between two rotated rectangles.
            If there is then the vertices of the interesecting region are returned as well.
            Below are some examples of intersection configurations. 
            The hatched pattern indicates the intersecting region and the red 
            vertices are returned by the function.
            </summary>
            <param name="rect1">First rectangle</param>
            <param name="rect2">Second rectangle</param>
            <param name="intersectingRegion">
            The output array of the verticies of the intersecting region. 
            It returns at most 8 vertices.
            Stored as std::vector&lt;cv::Point2f&gt; or cv::Mat as Mx1 of type CV_32FC2.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.RotatedRectangleIntersection(ST4IVisionCoreNet.RotatedRect,ST4IVisionCoreNet.RotatedRect,ST4IVisionCoreNet.Point2f[]@)">
            <summary>
            Finds out if there is any intersection between two rotated rectangles.
            If there is then the vertices of the interesecting region are returned as well.
            Below are some examples of intersection configurations. 
            The hatched pattern indicates the intersecting region and the red 
            vertices are returned by the function.
            </summary>
            <param name="rect1">First rectangle</param>
            <param name="rect2">Second rectangle</param>
            <param name="intersectingRegion">
            The output array of the verticies of the intersecting region. 
            It returns at most 8 vertices.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ApplyColorMap(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ColormapTypes)">
            <summary>
            Applies a GNU Octave/MATLAB equivalent colormap on a given image.
            </summary>
            <param name="src">The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.</param>
            <param name="dst">The result is the colormapped source image. Note: Mat::create is called on dst.</param>
            <param name="colormap">colormap The colormap to apply</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ApplyColorMap(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Applies a user colormap on a given image.
            </summary>
            <param name="src">The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.</param>
            <param name="dst">The result is the colormapped source image. Note: Mat::create is called on dst.</param>
            <param name="userColor">The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Line(ST4IVisionCoreNet.InputOutputArray,System.Int32,System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws a line segment connecting two points
            </summary>
            <param name="img">The image. </param>
            <param name="pt1X">First point's x-coordinate of the line segment. </param>
            <param name="pt1Y">First point's y-coordinate of the line segment. </param>
            <param name="pt2X">Second point's x-coordinate of the line segment. </param>
            <param name="pt2Y">Second point's y-coordinate of the line segment. </param>
            <param name="color">Line color. </param>
            <param name="thickness">Line thickness. [By default this is 1]</param>
            <param name="lineType">Type of the line. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Line(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws a line segment connecting two points
            </summary>
            <param name="img">The image. </param>
            <param name="pt1">First point of the line segment. </param>
            <param name="pt2">Second point of the line segment. </param>
            <param name="color">Line color. </param>
            <param name="thickness">Line thickness. [By default this is 1]</param>
            <param name="lineType">Type of the line. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ArrowedLine(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32,System.Double)">
            <summary>
            Draws a arrow segment pointing from the first point to the second one.
            The function arrowedLine draws an arrow between pt1 and pt2 points in the image. 
            See also cv::line.
            </summary>
            <param name="img">Image.</param>
            <param name="pt1">The point the arrow starts from.</param>
            <param name="pt2">The point the arrow points to.</param>
            <param name="color">Line color.</param>
            <param name="thickness">Line thickness.</param>
            <param name="lineType">Type of the line, see cv::LineTypes</param>
            <param name="shift">Number of fractional bits in the point coordinates.</param>
            <param name="tipLength">The length of the arrow tip in relation to the arrow length</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rectangle(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="img">Image. </param>
            <param name="pt1">One of the rectangle vertices. </param>
            <param name="pt2">Opposite rectangle vertex. </param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rectangle(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="img">Image. </param>
            <param name="rect">Rectangle.</param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle.
            Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rectangle(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="img">Image. </param>
            <param name="rect">Rectangle.</param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle.
            Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Rectangle(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="img">Image. </param>
            <param name="pt1">One of the rectangle vertices. </param>
            <param name="pt2">Opposite rectangle vertex. </param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle.
            Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Circle(ST4IVisionCoreNet.InputOutputArray,System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws a circle
            </summary>
            <param name="img">Image where the circle is drawn. </param>
            <param name="centerX">X-coordinate of the center of the circle. </param>
            <param name="centerY">Y-coordinate of the center of the circle. </param>
            <param name="radius">Radius of the circle. </param>
            <param name="color">Circle color. </param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn. [By default this is 1]</param>
            <param name="lineType">Type of the circle boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Circle(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws a circle
            </summary>
            <param name="img">Image where the circle is drawn. </param>
            <param name="center">Center of the circle. </param>
            <param name="radius">Radius of the circle. </param>
            <param name="color">Circle color. </param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn. [By default this is 1]</param>
            <param name="lineType">Type of the circle boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Ellipse(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Size,System.Double,System.Double,System.Double,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws simple or thick elliptic arc or fills ellipse sector
            </summary>
            <param name="img">Image. </param>
            <param name="center">Center of the ellipse. </param>
            <param name="axes">Length of the ellipse axes. </param>
            <param name="angle">Rotation angle. </param>
            <param name="startAngle">Starting angle of the elliptic arc. </param>
            <param name="endAngle">Ending angle of the elliptic arc. </param>
            <param name="color">Ellipse color. </param>
            <param name="thickness">Thickness of the ellipse arc. [By default this is 1]</param>
            <param name="lineType">Type of the ellipse boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Ellipse(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.RotatedRect,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes)">
            <summary>
            Draws simple or thick elliptic arc or fills ellipse sector
            </summary>
            <param name="img">Image. </param>
            <param name="box">The enclosing box of the ellipse drawn </param>
            <param name="color">Ellipse color. </param>
            <param name="thickness">Thickness of the ellipse boundary. [By default this is 1]</param>
            <param name="lineType">Type of the ellipse boundary. [By default this is LineType.Link8]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawMarker(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.MarkerTypes,System.Int32,System.Int32,ST4IVisionCoreNet.LineTypes)">
             <summary>
             Draws a marker on a predefined position in an image.
            
             The function cv::drawMarker draws a marker on a given position in the image.For the moment several
             marker types are supported, see #MarkerTypes for more information.
             </summary>
             <param name="img">Image.</param>
             <param name="position">The point where the crosshair is positioned.</param>
             <param name="color">Line color.</param>
             <param name="markerType">The specific type of marker you want to use.</param>
             <param name="markerSize">The length of the marker axis [default = 20 pixels]</param>
             <param name="thickness">Line thickness.</param>
             <param name="lineType">Type of the line.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FillConvexPoly(ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Fills a convex polygon.
            </summary>
            <param name="img">Image</param>
            <param name="pts">The polygon vertices</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FillConvexPoly(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Fills a convex polygon.
            </summary>
            <param name="img">Image</param>
            <param name="pts">The polygon vertices</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FillPoly(ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point}},ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.LineTypes,System.Int32,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Fills the area bounded by one or more polygons
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of polygons, each represented as an array of points</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
            <param name="offset"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FillPoly(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.LineTypes,System.Int32,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Fills the area bounded by one or more polygons
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of polygons, each represented as an array of points</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
            <param name="offset"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Polylines(ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point}},System.Boolean,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            draws one or more polygonal curves
            </summary>
            <param name="img"></param>
            <param name="pts"></param>
            <param name="isClosed"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="shift"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Polylines(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,System.Boolean,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            draws one or more polygonal curves
            </summary>
            <param name="img"></param>
            <param name="pts"></param>
            <param name="isClosed"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="shift"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawContours(ST4IVisionCoreNet.InputOutputArray,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point}},System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.HierarchyIndex},System.Int32,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            draws contours in the image
            </summary>
            <param name="image">Destination image.</param>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours.</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative (for example, thickness=CV_FILLED ), 
            the contour interiors are drawn.</param>
            <param name="lineType">Line connectivity. </param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="maxLevel">Maximal level for drawn contours. If it is 0, only the specified contour is drawn. 
            If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, 
            all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account 
            when there is hierarchy available.</param>
            <param name="offset">Optional contour shift parameter. Shift all the drawn contours by the specified offset = (dx, dy)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DrawContours(ST4IVisionCoreNet.InputOutputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,ST4IVisionCoreNet.Mat,System.Int32,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            draws contours in the image
            </summary>
            <param name="image">Destination image.</param>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours.</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative (for example, thickness=CV_FILLED ), 
            the contour interiors are drawn.</param>
            <param name="lineType">Line connectivity. </param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="maxLevel">Maximal level for drawn contours. If it is 0, only the specified contour is drawn. 
            If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, 
            all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account 
            when there is hierarchy available.</param>
            <param name="offset">Optional contour shift parameter. Shift all the drawn contours by the specified offset = (dx, dy)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ClipLine(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.Point@)">
            <summary>
            Clips the line against the image rectangle
            </summary>
            <param name="imgSize">The image size</param>
            <param name="pt1">The first line point</param>
            <param name="pt2">The second line point</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ClipLine(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.Point@)">
            <summary>
            Clips the line against the image rectangle
            </summary>
            <param name="imgRect">sThe image rectangle</param>
            <param name="pt1">The first line point</param>
            <param name="pt2">The second line point</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Ellipse2Poly(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Size,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Approximates an elliptic arc with a polyline.
            The function ellipse2Poly computes the vertices of a polyline that 
            approximates the specified elliptic arc. It is used by cv::ellipse.
            </summary>
            <param name="center">Center of the arc.</param>
            <param name="axes">Half of the size of the ellipse main axes. See the ellipse for details.</param>
            <param name="angle">Rotation angle of the ellipse in degrees. See the ellipse for details.</param>
            <param name="arcStart">Starting angle of the elliptic arc in degrees.</param>
            <param name="arcEnd">Ending angle of the elliptic arc in degrees.</param>
            <param name="delta">Angle between the subsequent polyline vertices. It defines the approximation</param>
            <returns>Output vector of polyline vertices.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Ellipse2Poly(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Size2d,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Approximates an elliptic arc with a polyline.
            The function ellipse2Poly computes the vertices of a polyline that 
            approximates the specified elliptic arc. It is used by cv::ellipse.
            </summary>
            <param name="center">Center of the arc.</param>
            <param name="axes">Half of the size of the ellipse main axes. See the ellipse for details.</param>
            <param name="angle">Rotation angle of the ellipse in degrees. See the ellipse for details.</param>
            <param name="arcStart">Starting angle of the elliptic arc in degrees.</param>
            <param name="arcEnd">Ending angle of the elliptic arc in degrees.</param>
            <param name="delta">Angle between the subsequent polyline vertices. It defines the approximation</param>
            <returns>Output vector of polyline vertices.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PutText(ST4IVisionCoreNet.InputOutputArray,System.String,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.HersheyFonts,System.Double,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Boolean)">
            <summary>
            renders text string in the image
            </summary>
            <param name="img">Image.</param>
            <param name="text">Text string to be drawn.</param>
            <param name="org">Bottom-left corner of the text string in the image.</param>
            <param name="fontFace">Font type, see #HersheyFonts.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="color">Text color.</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type. See #LineTypes</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner.
            Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetTextSize(System.String,ST4IVisionCoreNet.HersheyFonts,System.Double,System.Int32,System.Int32@)">
            <summary>
            returns bounding box of the text string
            </summary>
            <param name="text">Input text string.</param>
            <param name="fontFace">Font to use, see #HersheyFonts.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="thickness">Thickness of lines used to render the text. See #putText for details.</param>
            <param name="baseLine">baseLine y-coordinate of the baseline relative to the bottom-most text</param>
            <returns>The size of a box that contains the specified text.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GetFontScaleFromHeight(ST4IVisionCoreNet.HersheyFonts,System.Int32,System.Int32)">
            <summary>
            Calculates the font-specific size to use to achieve a given height in pixels.
            </summary>
            <param name="fontFace">Font to use, see cv::HersheyFonts.</param>
            <param name="pixelHeight">Pixel height to compute the fontScale for</param>
            <param name="thickness">Thickness of lines used to render the text.See putText for details.</param>
            <returns>The fontSize to use for cv::putText</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GroupRectangles(System.Collections.Generic.IList{ST4IVisionCoreNet.Rect},System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList"> Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GroupRectangles(System.Collections.Generic.IList{ST4IVisionCoreNet.Rect},System.Int32[]@,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList"> Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="weights"></param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GroupRectangles(System.Collections.Generic.IList{ST4IVisionCoreNet.Rect},System.Int32,System.Double,System.Int32[]@,System.Double[]@)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList"></param>
            <param name="groupThreshold"></param>
            <param name="eps"></param>
            <param name="weights"></param>
            <param name="levelWeights"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GroupRectangles(System.Collections.Generic.IList{ST4IVisionCoreNet.Rect},System.Int32[]@,System.Double[]@,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList"></param>
            <param name="rejectLevels"></param>
            <param name="levelWeights"></param>
            <param name="groupThreshold"></param>
            <param name="eps"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.GroupRectanglesMeanshift(System.Collections.Generic.IList{ST4IVisionCoreNet.Rect},System.Double[]@,System.Double[]@,System.Double,System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            
            </summary>
            <param name="rectList"></param>
            <param name="foundWeights"></param>
            <param name="foundScales"></param>
            <param name="detectThreshold"></param>
            <param name="winDetSize"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Inpaint(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,ST4IVisionCoreNet.InpaintMethod)">
            <summary>
            Restores the selected region in an image using the region neighborhood.
            </summary>
            <param name="src">Input 8-bit, 16-bit unsigned or 32-bit float 1-channel or 8-bit 3-channel image.</param>
            <param name="inpaintMask">Inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that needs to be inpainted.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="inpaintRadius">Radius of a circular neighborhood of each point inpainted that is considered by the algorithm.</param>
            <param name="flags">Inpainting method that could be cv::INPAINT_NS or cv::INPAINT_TELEA</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FastNlMeansDenoising(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Int32,System.Int32)">
            <summary>
            Perform image denoising using Non-local Means Denoising algorithm 
            with several computational optimizations. Noise expected to be a gaussian white noise
            </summary>
            <param name="src">Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src .</param>
            <param name="h">
            Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, 
            smaller h value preserves details but also preserves some noise</param>
            <param name="templateWindowSize">
            Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">
            Size in pixels of the window that is used to compute weighted average for given pixel. 
            Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FastNlMeansDenoisingColored(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Modification of fastNlMeansDenoising function for colored images
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength for luminance component. 
            Bigger h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise</param>
            <param name="hColor">The same as h but for color components. For most images value equals 10 will be enought 
            to remove colored noise and do not distort colors</param>
            <param name="templateWindowSize">
            Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">
            Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. 
            Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FastNlMeansDenoisingMulti(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
            <summary>
            Modification of fastNlMeansDenoising function for images sequence where consequtive images have been captured 
            in small period of time. For example video. This version of the function is for grayscale images or for manual manipulation with colorspaces.
            </summary>
            <param name="srcImgs">Input 8-bit 1-channel, 2-channel or 3-channel images sequence. All images should have the same type and size.</param>
            <param name="dst"> Output image with the same size and type as srcImgs images.</param>
            <param name="imgToDenoiseIndex">Target image to denoise index in srcImgs sequence</param>
            <param name="temporalWindowSize">Number of surrounding images to use for target image denoising. 
            Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 
            from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image.</param>
            <param name="h">Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise but also removes image details, 
            smaller h value preserves details but also preserves some noise</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. 
            Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FastNlMeansDenoisingColoredMulti(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Modification of fastNlMeansDenoisingMulti function for colored images sequences
            </summary>
            <param name="srcImgs">Input 8-bit 3-channel images sequence. All images should have the same type and size.</param>
            <param name="dst">Output image with the same size and type as srcImgs images.</param>
            <param name="imgToDenoiseIndex">Target image to denoise index in srcImgs sequence</param>
            <param name="temporalWindowSize">Number of surrounding images to use for target image denoising. Should be odd. 
            Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs 
            will be used to denoise srcImgs[imgToDenoiseIndex] image.</param>
            <param name="h">Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise 
            but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="hColor"> The same as h but for color components.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. 
            Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DenoiseTVL1(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.Mat,System.Double,System.Int32)">
            <summary>
            Primal-dual algorithm is an algorithm for solving special types of variational problems 
            (that is, finding a function to minimize some functional). As the image denoising, 
            in particular, may be seen as the variational problem, primal-dual algorithm then 
            can be used to perform denoising and this is exactly what is implemented.
            </summary>
            <param name="observations">This array should contain one or more noised versions 
            of the image that is to be restored.</param>
            <param name="result">Here the denoised image will be stored. There is no need to 
            do pre-allocation of storage space, as it will be automatically allocated, if necessary.</param>
            <param name="lambda">Corresponds to \f$\lambda\f$ in the formulas above. 
            As it is enlarged, the smooth (blurred) images are treated more favorably than 
            detailed (but maybe more noised) ones. Roughly speaking, as it becomes smaller, 
            the result will be more blur but more sever outliers will be removed.</param>
            <param name="niters"> Number of iterations that the algorithm will run. 
            Of course, as more iterations as better, but it is hard to quantitatively 
            refine this statement, so just use the default and increase it if the results are poor.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Decolor(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Transforms a color image to a grayscale image. It is a basic tool in digital 
            printing, stylized black-and-white photograph rendering, and in many single 
            channel image processing applications @cite CL12 .
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="grayscale">Output 8-bit 1-channel image.</param>
            <param name="colorBoost">Output 8-bit 3-channel image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.SeamlessClone(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.SeamlessCloneMethods)">
            <summary>
            Image editing tasks concern either global changes (color/intensity corrections, 
            filters, deformations) or local changes concerned to a selection. Here we are 
            interested in achieving local changes, ones that are restricted to a region 
            manually selected (ROI), in a seamless and effortless manner. The extent of 
            the changes ranges from slight distortions to complete replacement by novel 
            content @cite PM03 .
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="p">Point in dst image where object is placed.</param>
            <param name="blend">Output image with the same size and type as dst.</param>
            <param name="flags">Cloning method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ColorChange(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Given an original color image, two differently colored versions of this 
            image can be mixed seamlessly. Multiplication factor is between 0.5 to 2.5.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="redMul">R-channel multiply factor.</param>
            <param name="greenMul">G-channel multiply factor.</param>
            <param name="blueMul">B-channel multiply factor.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.IlluminationChange(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single)">
            <summary>
            Applying an appropriate non-linear transformation to the gradient field inside 
            the selection and then integrating back with a Poisson solver, modifies locally 
            the apparent illumination of an image.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="alpha">Value ranges between 0-2.</param>
            <param name="beta">Value ranges between 0-2.</param>
            <remarks>
            This is useful to highlight under-exposed foreground objects or to reduce specular reflections.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.TextureFlattening(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single,System.Int32)">
            <summary>
            By retaining only the gradients at edge locations, before integrating with the 
            Poisson solver, one washes out the texture of the selected region, giving its 
            contents a flat aspect. Here Canny Edge Detector is used.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="lowThreshold">Range from 0 to 100.</param>
            <param name="highThreshold">Value &gt; 100.</param>
            <param name="kernelSize">The size of the Sobel kernel to be used.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.EdgePreservingFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.EdgePreservingMethods,System.Single,System.Single)">
            <summary>
            Filtering is the fundamental operation in image and video processing. 
            Edge-preserving smoothing filters are used in many different applications @cite EM11 .
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output 8-bit 3-channel image.</param>
            <param name="flags">Edge preserving filters</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR">Range between 0 to 1.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.DetailEnhance(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single)">
            <summary>
            This filter enhances the details of a particular image.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR">Range between 0 to 1.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.PencilSketch(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Pencil-like non-photorealistic line drawing
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst1">Output 8-bit 1-channel image.</param>
            <param name="dst2">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR">Range between 0 to 1.</param>
            <param name="shadeFactor">Range between 0 to 0.1.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.Stylization(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single)">
            <summary>
            Stylization aims to produce digital imagery with a wide variety of effects 
            not focused on photorealism. Edge-aware filters are ideal for stylization, 
            as they can abstract regions of low contrast while preserving, or enhancing, 
            high-contrast features.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR">Range between 0 to 1.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateFrameSource_Empty">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateFrameSource_Video(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateFrameSource_Video_CUDA(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateFrameSource_Camera(System.Int32)">
            <summary>
            
            </summary>
            <param name="deviceId"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateSuperResolution_BTVL1">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateSuperResolution_BTVL1_CUDA">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateOptFlow_Farneback">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateOptFlow_Farneback_GPU">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateOptFlow_DualTVL1_GPU">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateOptFlow_Brox_GPU">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CreateOptFlow_PyrLK_GPU">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CamShift(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Rect@,ST4IVisionCoreNet.TermCriteria)">
            <summary>
            Finds an object center, size, and orientation.
            </summary>
            <param name="probImage">Back projection of the object histogram. </param>
            <param name="window">Initial search window.</param>
            <param name="criteria">Stop criteria for the underlying MeanShift() .</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.MeanShift(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Rect@,ST4IVisionCoreNet.TermCriteria)">
            <summary>
            Finds an object on a back projection image.
            </summary>
            <param name="probImage">Back projection of the object histogram.</param>
            <param name="window">Initial search window.</param>
            <param name="criteria">Stop criteria for the iterative search algorithm.</param>
            <returns>Number of iterations CAMSHIFT took to converge.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BuildOpticalFlowPyramid(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Size,System.Int32,System.Boolean,ST4IVisionCoreNet.BorderTypes,ST4IVisionCoreNet.BorderTypes,System.Boolean)">
            <summary>
            Constructs a pyramid which can be used as input for calcOpticalFlowPyrLK
            </summary>
            <param name="img">8-bit input image.</param>
            <param name="pyramid">output pyramid.</param>
            <param name="winSize">window size of optical flow algorithm. 
            Must be not less than winSize argument of calcOpticalFlowPyrLK(). 
            It is needed to calculate required padding for pyramid levels.</param>
            <param name="maxLevel">0-based maximal pyramid level number.</param>
            <param name="withDerivatives">set to precompute gradients for the every pyramid level. 
            If pyramid is constructed without the gradients then calcOpticalFlowPyrLK() will 
            calculate them internally.</param>
            <param name="pyrBorder">the border mode for pyramid layers.</param>
            <param name="derivBorder">the border mode for gradients.</param>
            <param name="tryReuseInputImage">put ROI of input image into the pyramid if possible. 
            You can pass false to force data copying.</param>
            <returns>number of levels in constructed pyramid. Can be less than maxLevel.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.BuildOpticalFlowPyramid(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Mat[]@,ST4IVisionCoreNet.Size,System.Int32,System.Boolean,ST4IVisionCoreNet.BorderTypes,ST4IVisionCoreNet.BorderTypes,System.Boolean)">
            <summary>
            Constructs a pyramid which can be used as input for calcOpticalFlowPyrLK
            </summary>
            <param name="img">8-bit input image.</param>
            <param name="pyramid">output pyramid.</param>
            <param name="winSize">window size of optical flow algorithm. 
            Must be not less than winSize argument of calcOpticalFlowPyrLK(). 
            It is needed to calculate required padding for pyramid levels.</param>
            <param name="maxLevel">0-based maximal pyramid level number.</param>
            <param name="withDerivatives">set to precompute gradients for the every pyramid level. 
            If pyramid is constructed without the gradients then calcOpticalFlowPyrLK() will 
            calculate them internally.</param>
            <param name="pyrBorder">the border mode for pyramid layers.</param>
            <param name="derivBorder">the border mode for gradients.</param>
            <param name="tryReuseInputImage">put ROI of input image into the pyramid if possible. 
            You can pass false to force data copying.</param>
            <returns>number of levels in constructed pyramid. Can be less than maxLevel.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalcOpticalFlowPyrLK(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Nullable{ST4IVisionCoreNet.Size},System.Int32,System.Nullable{ST4IVisionCoreNet.TermCriteria},ST4IVisionCoreNet.OpticalFlowFlags,System.Double)">
            <summary>
            computes sparse optical flow using multi-scale Lucas-Kanade algorithm
            </summary>
            <param name="prevImg"></param>
            <param name="nextImg"></param>
            <param name="prevPts"></param>
            <param name="nextPts"></param>
            <param name="status"></param>
            <param name="err"></param>
            <param name="winSize"></param>
            <param name="maxLevel"></param>
            <param name="criteria"></param>
            <param name="flags"></param>
            <param name="minEigThreshold"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalcOpticalFlowPyrLK(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[],ST4IVisionCoreNet.Point2f[]@,System.Byte[]@,System.Single[]@,System.Nullable{ST4IVisionCoreNet.Size},System.Int32,System.Nullable{ST4IVisionCoreNet.TermCriteria},ST4IVisionCoreNet.OpticalFlowFlags,System.Double)">
            <summary>
            computes sparse optical flow using multi-scale Lucas-Kanade algorithm
            </summary>
            <param name="prevImg"></param>
            <param name="nextImg"></param>
            <param name="prevPts"></param>
            <param name="nextPts"></param>
            <param name="status"></param>
            <param name="err"></param>
            <param name="winSize"></param>
            <param name="maxLevel"></param>
            <param name="criteria"></param>
            <param name="flags"></param>
            <param name="minEigThreshold"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.CalcOpticalFlowFarneback(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,ST4IVisionCoreNet.OpticalFlowFlags)">
            <summary>
            Computes a dense optical flow using the Gunnar Farneback's algorithm.
            </summary>
            <param name="prev">first 8-bit single-channel input image.</param>
            <param name="next">second input image of the same size and the same type as prev.</param>
            <param name="flow">computed flow image that has the same size as prev and type CV_32FC2.</param>
            <param name="pyrScale">parameter, specifying the image scale (&lt;1) to build pyramids for each image; 
            pyrScale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one.</param>
            <param name="levels">number of pyramid layers including the initial image; 
            levels=1 means that no extra layers are created and only the original images are used.</param>
            <param name="winsize">averaging window size; larger values increase the algorithm robustness to 
            image noise and give more chances for fast motion detection, but yield more blurred motion field.</param>
            <param name="iterations">number of iterations the algorithm does at each pyramid level.</param>
            <param name="polyN">size of the pixel neighborhood used to find polynomial expansion in each pixel; 
            larger values mean that the image will be approximated with smoother surfaces, 
            yielding more robust algorithm and more blurred motion field, typically poly_n =5 or 7.</param>
            <param name="polySigma">standard deviation of the Gaussian that is used to smooth derivatives used as 
            a basis for the polynomial expansion; for polyN=5, you can set polySigma=1.1, 
            for polyN=7, a good value would be polySigma=1.5.</param>
            <param name="flags">operation flags that can be a combination of OPTFLOW_USE_INITIAL_FLOW and/or OPTFLOW_FARNEBACK_GAUSSIAN</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.ComputeECC(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes the Enhanced Correlation Coefficient value between two images @cite EP08 .
            </summary>
            <param name="templateImage">single-channel template image; CV_8U or CV_32F array.</param>
            <param name="inputImage">single-channel input image to be warped to provide an image similar to templateImage, same type as templateImage.</param>
            <param name="inputMask">An optional mask to indicate valid values of inputImage.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindTransformECC(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.MotionTypes,ST4IVisionCoreNet.TermCriteria,ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Finds the geometric transform (warp) between two images in terms of the ECC criterion @cite EP08 .
            </summary>
            <param name="templateImage">single-channel template image; CV_8U or CV_32F array.</param>
            <param name="inputImage">single-channel input image which should be warped with the final warpMatrix in
            order to provide an image similar to templateImage, same type as templateImage.</param>
            <param name="warpMatrix">floating-point \f$2\times 3\f$ or \f$3\times 3\f$ mapping matrix (warp).</param>
            <param name="motionType">parameter, specifying the type of motion</param>
            <param name="criteria">parameter, specifying the termination criteria of the ECC algorithm;
            criteria.epsilon defines the threshold of the increment in the correlation coefficient between two
            iterations(a negative criteria.epsilon makes criteria.maxcount the only termination criterion).
            Default values are shown in the declaration above.</param>
            <param name="inputMask">An optional mask to indicate valid values of inputImage.</param>
            <param name="gaussFiltSize">An optional value indicating size of gaussian blur filter; (DEFAULT: 5)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Sv.FindTransformECC(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.MotionTypes,System.Nullable{ST4IVisionCoreNet.TermCriteria},ST4IVisionCoreNet.InputArray)">
            <summary>
            Finds the geometric transform (warp) between two images in terms of the ECC criterion @cite EP08 .
            </summary>
            <param name="templateImage">single-channel template image; CV_8U or CV_32F array.</param>
            <param name="inputImage">single-channel input image which should be warped with the final warpMatrix in
            order to provide an image similar to templateImage, same type as templateImage.</param>
            <param name="warpMatrix">floating-point \f$2\times 3\f$ or \f$3\times 3\f$ mapping matrix (warp).</param>
            <param name="motionType">parameter, specifying the type of motion</param>
            <param name="criteria">parameter, specifying the termination criteria of the ECC algorithm;
            criteria.epsilon defines the threshold of the increment in the correlation coefficient between two
            iterations(a negative criteria.epsilon makes criteria.maxcount the only termination criterion).
            Default values are shown in the declaration above.</param>
            <param name="inputMask">An optional mask to indicate valid values of inputImage.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.CvObject">
            <summary>
            A class which has a pointer of OpenCV structure
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CvObject.ptr">
            <summary>
            Data pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CvObject.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CvObject.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="P:ST4IVisionCoreNet.CvObject.CvPtr">
            <summary>
            Native pointer of OpenCV structure
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DisposableCvObject">
            <summary>
            DisposableObject + ICvPtrHolder
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DisposableCvObject.ptr">
            <summary>
            Data pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableCvObject.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableCvObject.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableCvObject.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="isEnabledDispose"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableCvObject.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
            <param name="isEnabledDispose"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableCvObject.DisposeUnmanaged">
            <summary>
            releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DisposableCvObject.CvPtr">
            <summary>
            Native pointer of OpenCV structure
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DisposableObject">
            <summary>
            Represents a class which manages its own memory. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DisposableObject.DataHandle">
            <summary>
            Gets or sets a handle which allocates using cvSetData.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DisposableObject.IsDisposed">
            <summary>
            Gets a value indicating whether this instance has been disposed.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DisposableObject.IsEnabledDispose">
            <summary>
            Gets or sets a value indicating whether you permit disposing this instance.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DisposableObject.AllocatedMemory">
            <summary>
            Gets or sets a memory address allocated by AllocMemory.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DisposableObject.AllocatedMemorySize">
            <summary>
            Gets or sets the byte length of the allocated memory
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="isEnabledDispose">true if you permit disposing this class by GC</param>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.Dispose">
            <summary>
            Releases the resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.AllocGCHandle(System.Object)">
            <summary>
            Pins the object to be allocated by cvSetData.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.AllocMemory(System.Int32)">
            <summary>
            Allocates the specified size of memory.
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.NotifyMemoryPressure(System.Int64)">
            <summary>
            Notifies the allocated size of memory.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DisposableObject.ThrowIfDisposed">
            <summary>
            If this object is disposed, then ObjectDisposedException is thrown.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ICvPtrHolder">
            <summary>
            Represents a OpenCV-based class which has a native pointer. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ICvPtrHolder.CvPtr">
            <summary>
            Unmanaged OpenCV data pointer
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MatMemoryManager`1">
            <summary>
            A MemoryManager over an OpenCvSharpMat
            </summary>
            <remarks>The pointer is assumed to be fully unmanaged, or externally pinned - no attempt will be made to pin this data</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.MatMemoryManager`1.#ctor(ST4IVisionCoreNet.Mat,System.Boolean)">
            <summary>
            Create a new UnmanagedMemoryManager instance at the given pointer and size
            </summary>
            <remarks>It is assumed that the span provided is already unmanaged or externally pinned</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.MatMemoryManager`1.GetSpan">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.MatMemoryManager`1.Pin(System.Int32)">
            <summary>
            Provides access to a pointer that represents the data (note: no actual pin occurs)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatMemoryManager`1.Unpin">
            <summary>
            Has no effect
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatMemoryManager`1.Dispose(System.Boolean)">
            <summary>
            Releases all resources associated with this object
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.OpenCVException">
            <summary>
            The default exception to be thrown by OpenCV 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.OpenCVException.Status">
            <summary>
            The numeric code for error status
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.OpenCVException.FuncName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.OpenCVException.ErrMsg">
            <summary>
            A description of the error
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.OpenCVException.FileName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.OpenCVException.Line">
            <summary>
            The line number in the source where error is encountered
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCVException.#ctor(ST4IVisionCoreNet.ErrorCode,System.String,System.String,System.String,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCVException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCVException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCVException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCVException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCVException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.OpenCvSharpException">
            <summary>
            The exception that is thrown by ST4IVisionCoreNet. 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCvSharpException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCvSharpException.#ctor(System.String)">
            <inheritdoc />
            <param name="message"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCvSharpException.#ctor(System.String,System.Exception)">
            <inheritdoc />
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.OpenCvSharpException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Ptr">
            <summary>
            Template class for smart reference-counting pointers
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Ptr.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Ptr.Get">
            <summary>
            Returns Ptr&lt;T&gt;.get() pointer
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ResourcesTracker">
            <summary>
            Used for managing the resources of OpenCVSharp, like Mat, MatExpr, etc.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ResourcesTracker.T``1(``0)">
            <summary>
            Trace the object obj, and return it
            </summary>
            <typeparam name="TCvObject"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ResourcesTracker.T``1(``0[])">
            <summary>
            Trace an array of objects , and return them
            </summary>
            <typeparam name="TCvObject"></typeparam>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ResourcesTracker.NewMat">
            <summary>
            Create a new Mat instance, and trace it
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ResourcesTracker.NewMat(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Scalar)">
            <summary>
             Create a new Mat instance, and trace it
            </summary>
            <param name="size">size</param>
            <param name="matType">matType</param>
            <param name="scalar">scalar</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ResourcesTracker.NewUMat">
            <summary>
            Create a new UMat instance, and trace it
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ResourcesTracker.NewUMat(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Scalar)">
            <summary>
             Create a new UMat instance, and trace it
            </summary>
            <param name="size">size</param>
            <param name="matType">matType</param>
            <param name="scalar">scalar</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ResourcesTracker.Dispose">
            <summary>
            Dispose all traced objects
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.ExceptionHandler">
            <summary>
            This static class defines one instance which than can be used by multiple threads to gather exception information from OpenCV
            Implemented as a singleton
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.ExceptionHandler.ErrorHandlerCallback">
            <summary>
            Callback function invoked by OpenCV when exception occurs 
            Stores the information locally for every thread
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.ExceptionHandler.RegisterExceptionCallback">
            <summary>
            Registers the callback function to OpenCV, so exception caught before the p/invoke boundary 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.ExceptionHandler.ThrowPossibleException">
            <summary>
            Throws appropriate exception if one happened
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.ExceptionHandler.CheckForException">
            <summary>
            Returns a boolean which indicates if an exception occured for the current thread
            Reading this value changes its state, so an exception is handled only once
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.ExceptionStatus">
            <summary>
            Whether native methods for P/Invoke raises an exception
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.NativeMethods">
            <summary>
            P/Invoke methods of OpenCV 2.x C++ interface
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.NativeMethods.tried">
            <summary>
            Is tried P/Invoke once
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.NativeMethods.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.NativeMethods.LoadLibraries(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load DLL files dynamically using Win32 LoadLibrary
            </summary>
            <param name="additionalPaths"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.NativeMethods.TryPInvoke">
            <summary>
            Checks whether PInvoke functions can be called
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.NativeMethods.IsWindows">
            <summary>
            Returns whether the OS is Windows or not
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.NativeMethods.IsUnix">
            <summary>
            Returns whether the OS is *nix or not
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.NativeMethods.IsMono">
            <summary>
            Returns whether the runtime is Mono or not
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.NativeMethods.IsWasm">
            <summary>
            Returns whether the architecture is Wasm or not
            </summary>
            <returns></returns>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.NativeMethods.ErrorHandlerThrowException">
            <summary>
            Custom error handler to be thrown by OpenCV
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.NativeMethods.ErrorHandlerIgnorance">
            <summary>
            Custom error handler to ignore all OpenCV errors
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.NativeMethods.ErrorHandlerDefault">
            <summary>
            Default error handler
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.StdString">
            <inheritdoc />
            <summary>
            C++ std::string
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.StdString.#ctor">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.StdString.#ctor(System.String)">
            <inheritdoc />
            <summary>
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.StdString.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.StdString.Size">
            <summary>
            string.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.StdString.ToString">
            <summary>
            Converts std::string to managed string
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Win32Api">
            <summary>
            Win32API Wrapper
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.WindowsLibraryLoader">
            <summary>
            Handles loading embedded dlls into memory, based on http://stackoverflow.com/questions/666799/embedding-unmanaged-dll-into-a-managed-c-sharp-dll.
            </summary>
            <remarks>This code is based on https://github.com/charlesw/tesseract </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.ProcessorArchitecture">
            <summary>
            The default base directory name to copy the assemblies too.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.processorArchitecturePlatforms">
            <summary>
            Map processor 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.processorArchitectureAddressWidthPlatforms">
            <summary>
            Used as a sanity check for the returned processor architecture to double check the returned value.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.AdditionalPaths">
            <summary>
            Additional user-defined DLL paths 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.IsLibraryLoaded(System.String)">
            <summary>
            
            </summary>
            <param name="dllName"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.IsCurrentPlatformSupported">
            <summary>
            Determine if the OS is Windows
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.IsDotNetCore">
            <summary>
            Determine if the runtime is .NET Core
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.LoadLibrary(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="dllName"></param>
            <param name="additionalPaths"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.GetProcessArchitecture">
            <summary>
            Get's the current process architecture while keeping track of any assumptions or possible errors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.FixUpDllFileName(System.String)">
            <summary>
            Determines if the dynamic link library file name requires a suffix
            and adds it if necessary.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.WindowsLibraryLoader.GetPlatformName(System.String)">
            <summary>
            Given the processor architecture, returns the name of the platform.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Util.ArrayAddress1`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ArrayAddress1`1.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Util.ArrayAddress2`1">
            <summary>
            Class to get address of specified jagged array 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ArrayAddress2`1.#ctor(`0[][])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ArrayAddress2`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            
            </summary>
            <param name="enumerable"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ArrayAddress2`1.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ArrayAddress2`1.GetPointer">
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ArrayAddress2`1.GetDim1Length">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ArrayAddress2`1.GetDim2Lengths">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.EnumerableExtensions.CastOrToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            enumerable as T[] ?? enumerable.ToArray()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Util.PInvokeHelper">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.PInvokeHelper.TryPInvoke">
            <summary>
            Checks whether PInvoke functions can be called
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.PInvokeHelper.DllImportError(System.Exception)">
            <summary>
            DllImportの際にDllNotFoundExceptionかBadImageFormatExceptionが発生した際に呼び出されるメソッド。
            エラーメッセージを表示して解決策をユーザに示す。
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.PInvokeHelper.CreateException(System.Exception)">
            <summary>
            
            </summary>
            <param name="ex"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Util.Platform">
            <summary>
            Provides information for the platform which the user is using 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.Util.Platform.OS">
            <summary>
            OS type
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Internal.Util.Platform.Runtime">
            <summary>
            Runtime type
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Util.ReadOnlyArray2D`1">
            <summary>
            Readonly rectangular array (T[,])
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ReadOnlyArray2D`1.#ctor(`0[0:,0:])">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Util.ReadOnlyArray2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="index0"></param>
            <param name="index1"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Util.ReadOnlyArray2D`1.Length">
            <summary>
            Gets the total number of elements in all the dimensions of the System.Array.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ReadOnlyArray2D`1.GetLength(System.Int32)">
            <summary>
            Gets a 32-bit integer that represents the number of elements in the specified dimension of the System.Array.
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ReadOnlyArray2D`1.GetBuffer">
            <summary>
            Returns internal buffer
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Util.ScopedGCHandle">
            <summary>
            Original GCHandle that implement IDisposable 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ScopedGCHandle.#ctor(System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ScopedGCHandle.#ctor(System.Object,System.Runtime.InteropServices.GCHandleType)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="type"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Util.ScopedGCHandle.#ctor(System.Runtime.InteropServices.GCHandle)">
            <summary>
            Constructor
            </summary>
            <param name="handle"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.IStdVector`1">
            <summary>
            Represents std::vector 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.IStdVector`1.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.IStdVector`1.ToArray">
            <summary>
            Convert std::vector&lt;T&gt; to managed array T[]
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfByte">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfByte.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfByte.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfByte.#ctor(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfByte.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfByte.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfByte.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfByte.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfDMatch">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDMatch.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDMatch.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDMatch.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.DMatch})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDMatch.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfDMatch.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfDMatch.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDMatch.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfDouble">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDouble.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDouble.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDouble.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDouble.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfDouble.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfDouble.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDouble.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesNode">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesNode.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesNode.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesNode.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesNode.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesNode.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesSplit">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesSplit.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesSplit.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesSplit.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesSplit.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfDTreesSplit.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfFloat">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfFloat.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfFloat.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfFloat.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfFloat.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfFloat.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfFloat.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfFloat.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfImageFeatures">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfImageFeatures.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfImageFeatures.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfImageFeatures.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfImageFeatures.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfInt32">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfInt32.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfInt32.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfInt32.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfInt32.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfInt32.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfInt32.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfInt32.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfKeyPoint">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfKeyPoint.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfKeyPoint.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfKeyPoint.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfKeyPoint.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfKeyPoint.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfKeyPoint.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfKeyPoint.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            Constructor
            </summary>
            <param name="mats"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfMat.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2d">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2d.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2d.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2d.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2d.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2d.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2f">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2f.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2f.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2f.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2f.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint2f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint3f">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint3f.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint3f.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint3f.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3f})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint3f.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint3f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint3f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfPoint3f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Rect})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect2d">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect2d.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect2d.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect2d.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Rect2d})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect2d.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect2d.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect2d.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRect2d.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfRotatedRect">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRotatedRect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRotatedRect.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRotatedRect.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.RotatedRect})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRotatedRect.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfRotatedRect.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfRotatedRect.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfRotatedRect.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfString">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfString.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfString.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfString.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfString.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfString.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec2f">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec2f.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec2f.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec2f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec2f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec2f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec2f.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has two float members (ex. CvLineSegmentPolar, CvPoint2D32f, PointF)</typeparam>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec3f">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec3f.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec3f.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec3f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec3f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec3f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec3f.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has two float members (ex. CvLineSegmentPolar, CvPoint2D32f, PointF)</typeparam>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4f">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4f.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4f.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec4f})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4f.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4f.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has four int members (ex. CvLineSegmentPoint, CvRect)</typeparam>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4i">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4i.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4i.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec4i})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4i.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4i.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4i.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4i.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec4i.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has four int members (ex. CvLineSegmentPoint, CvRect)</typeparam>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec6f">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec6f.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec6f.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec6f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec6f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec6f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVec6f.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has four int members (ex. CvLineSegmentPoint, CvRect)</typeparam>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorByte">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorByte.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorByte.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorByte.GetSize1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorByte.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorByte.GetSize2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorByte.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDMatch">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDMatch.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDMatch.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDMatch.GetSize1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDMatch.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDMatch.GetSize2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDMatch.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDouble">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDouble.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDouble.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDouble.GetSize1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDouble.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDouble.GetSize2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorDouble.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorInt32">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorInt32.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorInt32.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorInt32.GetSize1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorInt32.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorInt32.GetSize2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorInt32.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorKeyPoint">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorKeyPoint.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorKeyPoint.#ctor(ST4IVisionCoreNet.KeyPoint[][])">
            <summary>
            Constructor
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorKeyPoint.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorKeyPoint.GetSize1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorKeyPoint.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorKeyPoint.GetSize2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorKeyPoint.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint.#ctor(System.UIntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint.GetSize1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint.Size">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint.GetSize2">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint2f">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint2f.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint2f.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint2f.GetSize1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint2f.Size">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint2f.GetSize2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Internal.Vectors.VectorOfVectorPoint2f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Aruco.CvAruco">
            <summary>
            aruco module
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.CvAruco.DetectMarkers(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Aruco.Dictionary,ST4IVisionCoreNet.Point2f[][]@,System.Int32[]@,ST4IVisionCoreNet.Aruco.DetectorParameters,ST4IVisionCoreNet.Point2f[][]@)">
            <summary>
            Basic marker detection
            </summary>
            <param name="image">input image</param>
            <param name="dictionary">indicates the type of markers that will be searched</param>
            <param name="corners">vector of detected marker corners. 
            For each marker, its four corners are provided. For N detected markers,
             the dimensions of this array is Nx4.The order of the corners is clockwise.</param>
            <param name="ids">vector of identifiers of the detected markers. The identifier is of type int. 
            For N detected markers, the size of ids is also N. The identifiers have the same order than the markers in the imgPoints array.</param>
            <param name="parameters">marker detection parameters</param>
            <param name="rejectedImgPoints">contains the imgPoints of those squares whose inner code has not a 
            correct codification.Useful for debugging purposes.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.CvAruco.EstimatePoseSingleMarkers(ST4IVisionCoreNet.Point2f[][],System.Single,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Pose estimation for single markers
            </summary>
            <param name="corners">corners vector of already detected markers corners. 
            For each marker, its four corners are provided, (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt;&gt; ). 
            For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.</param>
            <param name="markerLength">the length of the markers' side. The returning translation vectors will 
            be in the same unit.Normally, unit is meters.</param>
            <param name="cameraMatrix">input 3x3 floating-point camera matrix 
            \f$A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$</param>
            <param name="distortionCoefficients">vector of distortion coefficients 
            \f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\f$ of 4, 5, 8 or 12 elements</param>
            <param name="rvec">array of output rotation vectors (@sa Rodrigues) (e.g. std::vector&lt;cv::Vec3d&gt;). 
            Each element in rvecs corresponds to the specific marker in imgPoints.</param>
            <param name="tvec">array of output translation vectors (e.g. std::vector&lt;cv::Vec3d&gt;).
            Each element in tvecs corresponds to the specific marker in imgPoints.</param>
            <param name="objPoints">array of object points of all the marker corners</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.CvAruco.DrawDetectedMarkers(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[][],System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Draw detected markers in image
            </summary>
            <param name="image">input/output image. It must have 1 or 3 channels. The number of channels is not altered.</param>
            <param name="corners">positions of marker corners on input image. 
            For N detected markers, the dimensions of this array should be Nx4.The order of the corners should be clockwise.</param>
            <param name="ids">vector of identifiers for markers in markersCorners. Optional, if not provided, ids are not painted.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.CvAruco.DrawDetectedMarkers(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[][],System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.Scalar)">
            <summary>
            Draw detected markers in image
            </summary>
            <param name="image">input/output image. It must have 1 or 3 channels. The number of channels is not altered.</param>
            <param name="corners">positions of marker corners on input image. 
            For N detected markers, the dimensions of this array should be Nx4.The order of the corners should be clockwise.</param>
            <param name="ids">vector of identifiers for markers in markersCorners. Optional, if not provided, ids are not painted.</param>
            <param name="borderColor">color of marker borders. Rest of colors (text color and first corner color)
             are calculated based on this one to improve visualization.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.CvAruco.GetPredefinedDictionary(ST4IVisionCoreNet.Aruco.PredefinedDictionaryName)">
            <summary>
            Returns one of the predefined dictionaries defined in PREDEFINED_DICTIONARY_NAME
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.CvAruco.DetectCharucoDiamond(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[][],System.Collections.Generic.IEnumerable{System.Int32},System.Single,ST4IVisionCoreNet.Point2f[][]@,ST4IVisionCoreNet.Vec4i[]@,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Detect ChArUco Diamond markers.
            </summary>
            <param name="image">input image necessary for corner subpixel.</param>
            <param name="markerCorners">list of detected marker corners from detectMarkers function.</param>
            <param name="markerIds">list of marker ids in markerCorners.</param>
            <param name="squareMarkerLengthRate">rate between square and marker length: squareMarkerLengthRate = squareLength/markerLength. The real units are not necessary.</param>
            <param name="diamondCorners">output list of detected diamond corners (4 corners per diamond). The order is the same than in marker corners: top left, top right, bottom right and bottom left. Similar format than the corners returned by detectMarkers (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt;&gt;).</param>
            <param name="diamondIds">ids of the diamonds in diamondCorners. The id of each diamond is in fact of type Vec4i, so each diamond has 4 ids, which are the ids of the aruco markers composing the diamond.</param>
            <param name="cameraMatrix">Optional camera calibration matrix.</param>
            <param name="distCoeffs">Optional camera distortion coefficients.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.CvAruco.DrawDetectedDiamonds(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[][],System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec4i})">
            <summary>
            Draw a set of detected ChArUco Diamond markers.
            </summary>
            <param name="image">input/output image. It must have 1 or 3 channels. The number of channels is not altered.</param>
            <param name="diamondCorners">positions of diamond corners in the same format returned by detectCharucoDiamond(). (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt;&gt;). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.</param>
            <param name="diamondIds">vector of identifiers for diamonds in diamondCorners, in the same format returned by detectCharucoDiamond() (e.g. std::vector&lt;Vec4i&gt;). Optional, if not provided, ids are not painted.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.CvAruco.DrawDetectedDiamonds(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[][],System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec4i},ST4IVisionCoreNet.Scalar)">
            <summary>
            Draw a set of detected ChArUco Diamond markers.
            </summary>
            <param name="image">input/output image. It must have 1 or 3 channels. The number of channels is not altered.</param>
            <param name="diamondCorners">positions of diamond corners in the same format returned by detectCharucoDiamond(). (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt;&gt;). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.</param>
            <param name="diamondIds">vector of identifiers for diamonds in diamondCorners, in the same format returned by detectCharucoDiamond() (e.g. std::vector&lt;Vec4i&gt;). Optional, if not provided, ids are not painted.</param>
            <param name="borderColor">color of marker borders. Rest of colors (text color and first corner color) are calculated based on this one.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.Aruco.DetectorParameters">
            <summary>
            Parameters for the detectMarker process
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AdaptiveThreshWinSizeMin">
            <summary>
            minimum window size for adaptive thresholding before finding contours (default 3).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AdaptiveThreshWinSizeMax">
            <summary>
            adaptiveThreshWinSizeMax: maximum window size for adaptive thresholding before finding contours(default 23).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AdaptiveThreshWinSizeStep">
            <summary>
            increments from adaptiveThreshWinSizeMin to adaptiveThreshWinSizeMax during the thresholding(default 10).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AdaptiveThreshConstant">
            <summary>
            constant for adaptive thresholding before finding contours (default 7)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MinMarkerPerimeterRate">
            <summary>
            determine minimum perimeter for marker contour to be detected. 
            This is defined as a rate respect to the maximum dimension of the input image(default 0.03).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MaxMarkerPerimeterRate">
            <summary>
             determine maximum perimeter for marker contour to be detected. 
            This is defined as a rate respect to the maximum dimension of the input image(default 4.0).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.PolygonalApproxAccuracyRate">
            <summary>
            minimum accuracy during the polygonal approximation process to determine which contours are squares.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MinCornerDistanceRate">
            <summary>
            minimum distance between corners for detected markers relative to its perimeter(default 0.05)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MinDistanceToBorder">
            <summary>
             minimum distance of any corner to the image border for detected markers (in pixels) (default 3)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MinMarkerDistanceRate">
            <summary>
            minimum mean distance between two marker corners to be considered similar, 
            so that the smaller one is removed.The rate is relative to the smaller perimeter of the two markers(default 0.05).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.CornerRefinementMethod">
            <summary>
            corner refinement method.
            (CORNER_REFINE_NONE, no refinement. CORNER_REFINE_SUBPIX, do subpixel refinement. CORNER_REFINE_CONTOUR use contour-Points)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.CornerRefinementWinSize">
            <summary>
            window size for the corner refinement process (in pixels) (default 5).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.CornerRefinementMaxIterations">
            <summary>
            maximum number of iterations for stop criteria of the corner refinement process(default 30).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.CornerRefinementMinAccuracy">
            <summary>
            minimum error for the stop criteria of the corner refinement process(default: 0.1)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MarkerBorderBits">
            <summary>
            number of bits of the marker border, i.e. marker border width (default 1).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.PerspectiveRemovePixelPerCell">
            <summary>
            number of bits (per dimension) for each cell of the marker when removing the perspective(default 8).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.PerspectiveRemoveIgnoredMarginPerCell">
            <summary>
            width of the margin of pixels on each cell not considered for the determination 
            of the cell bit.Represents the rate respect to the total  size of the cell, 
            i.e. perspectiveRemovePixelPerCell (default 0.13)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MaxErroneousBitsInBorderRate">
            <summary>
            maximum number of accepted erroneous bits in the border 
            (i.e. number of allowed white bits in the border). Represented as a rate respect to the total 
            number of bits per marker(default 0.35).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MinOtsuStdDev">
            <summary>
            minimun standard deviation in pixels values during the decodification step to
             apply Otsu thresholding(otherwise, all the bits are set to 0 or 1 depending on mean higher than 128 or not) (default 5.0)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.ErrorCorrectionRate">
            <summary>
            errorCorrectionRate error correction rate respect to the maximun error correction capability for each dictionary. (default 0.6).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AprilTagQuadDecimate">
            <summary>
            Detection of quads can be done on a lower-resolution image, improving speed at a cost of pose accuracy and a slight decrease in detection rate.
            Decoding the binary payload is still done at full resolution.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AprilTagQuadSigma">
            <summary>
            What Gaussian blur should be applied to the segmented image (used for quad detection?) Parameter is the standard deviation in pixels.
            Very noisy images benefit from non-zero values (e.g. 0.8).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AprilTagMinClusterPixels">
            <summary>
            reject quads containing too few pixels.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AprilTagMaxNmaxima">
            <summary>
            how many corner candidates to consider when segmenting a group of pixels into a quad.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AprilTagCriticalRad">
            <summary>
            Reject quads where pairs of edges have angles that are close to straight or close to 180 degrees. Zero means that no quads are rejected. (In radians).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AprilTagMaxLineFitMse">
            <summary>
            When fitting lines to the contours, what is the maximum mean squared error allowed?
            This is useful in rejecting contours that are far from being quad shaped; rejecting these quads "early" saves expensive decoding processing.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AprilTagMinWhiteBlackDiff">
            <summary>
            When we build our model of black &amp; white pixels, we add an extra check that the white model must be (overall) brighter than the black model.
            How much brighter? (in pixel values, [0,255]).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.AprilTagDeglitch">
            <summary>
            should the thresholded image be deglitched? Only useful for very noisy images
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.DetectInvertedMarker">
            <summary>
            to check if there is a white marker. In order to generate a "white" marker just invert a normal marker by using a tilde, ~markerImage. (default false)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.UseAruco3Detection">
            <summary>
            enable the new and faster Aruco detection strategy.
            Proposed in the paper:
            * Romero-Ramirez et al: Speeded up detection of squared fiducial markers (2018)
            * https://www.researchgate.net/publication/325787310_Speeded_Up_Detection_of_Squared_Fiducial_Markers
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MinSideLengthCanonicalImg">
            <summary>
            minimum side length of a marker in the canonical image. Latter is the binarized image in which contours are searched. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.DetectorParameters.MinMarkerLengthRatioOriginalImg">
            <summary>
            range [0,1], eq (2) from paper. The parameter tau_i has a direct influence on the processing speed.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.DetectorParameters.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Aruco.Dictionary">
            <summary>
            Dictionary/Set of markers. It contains the inner codification
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.Dictionary.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.Dictionary.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Aruco.Dictionary.BytesList">
            <summary>
            Marker code information
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Aruco.Dictionary.MarkerSize">
            <summary>
            Number of bits per dimension.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Aruco.Dictionary.MaxCorrectionBits">
            <summary>
            Maximum number of bits that can be corrected.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.Dictionary.Identify(ST4IVisionCoreNet.Mat,System.Int32@,System.Int32@,System.Double)">
            <summary>
            Given a matrix of bits. Returns whether if marker is identified or not.
            It returns by reference the correct id (if any) and the correct rotation
            </summary>
            <param name="onlyBits"></param>
            <param name="idx"></param>
            <param name="rotation"></param>
            <param name="maxCorrectionRate"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.Dictionary.GetDistanceToId(ST4IVisionCoreNet.InputArray,System.Int32,System.Boolean)">
            <summary>
            Returns the distance of the input bits to the specific id.
            If allRotations is true, the four possible bits rotation are considered
            </summary>
            <param name="bits"></param>
            <param name="id"></param>
            <param name="allRotations"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.Dictionary.GenerateImageMarker(System.Int32,System.Int32,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Generate a canonical marker image
            </summary>
            <param name="id"></param>
            <param name="sidePixels"></param>
            <param name="img"></param>
            <param name="borderBits"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.Dictionary.GetByteListFromBits(ST4IVisionCoreNet.Mat)">
            <summary>
            Transform matrix of bits to list of bytes in the 4 rotations
            </summary>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Aruco.Dictionary.GetBitsFromByteList(ST4IVisionCoreNet.Mat,System.Int32)">
            <summary>
            Transform list of bytes to matrix of bits
            </summary>
            <param name="byteList"></param>
            <param name="markerSize"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Aruco.CornerRefineMethod">
            <summary>
            corner refinement method
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.CornerRefineMethod.None">
            <summary>
            Tag and corners detection based on the ArUco approach.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.CornerRefineMethod.Subpix">
            <summary>
            ArUco approach and refine the corners locations using corner subpixel accuracy.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.CornerRefineMethod.Contour">
            <summary>
            ArUco approach and refine the corners locations using the contour-points line fitting.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Aruco.CornerRefineMethod.AprilTag">
            <summary>
            Tag and corners detection based on the AprilTag 2 approach
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Aruco.PredefinedDictionaryName">
            <summary>
            PredefinedDictionaryName
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.BackgroundSubtractorGMG">
            <summary>
            Background Subtractor module. Takes a series of images and returns a sequence of mask (8UC1)
            images of the same size, where 255 indicates Foreground and 0 represents Background.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BackgroundSubtractorGMG.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractorGMG.Create(System.Int32,System.Double)">
            <summary>
            Creates a GMG Background Subtractor
            </summary>
            <param name="initializationFrames">number of frames used to initialize the background models.</param>
            <param name="decisionThreshold">Threshold value, above which it is marked foreground, else background.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractorGMG.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.MaxFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.DefaultLearningRate">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.NumFrames">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.QuantizationLevels">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.BackgroundPrior">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.SmoothingRadius">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.DecisionThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.UpdateBackgroundModel">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.MinVal">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorGMG.MaxVal">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.BackgroundSubtractorMOG">
            <summary>
            Gaussian Mixture-based Backbround/Foreground Segmentation Algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BackgroundSubtractorMOG.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractorMOG.Create(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Creates mixture-of-gaussian background subtractor
            </summary>
            <param name="history">Length of the history.</param>
            <param name="nMixtures">Number of Gaussian mixtures.</param>
            <param name="backgroundRatio">Background ratio.</param>
            <param name="noiseSigma">Noise strength (standard deviation of the brightness or each color channel). 0 means some automatic value.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractorMOG.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG.History">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG.NMixtures">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG.BackgroundRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG.NoiseSigma">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CalibrationFlags">
            <summary>
            Different flags for cvCalibrateCamera2 and cvStereoCalibrate
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.UseIntrinsicGuess">
            <summary>
            The flag allows the function to optimize some or all of the intrinsic parameters, depending on the other flags, but the initial values are provided by the user
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixAspectRatio">
            <summary>
            fyk is optimized, but the ratio fxk/fyk is fixed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixPrincipalPoint">
            <summary>
            The principal points are fixed during the optimization.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.ZeroTangentDist">
            <summary>
            Tangential distortion coefficients are set to zeros and do not change during the optimization.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixFocalLength">
            <summary>
            fxk and fyk are fixed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixK1">
            <summary>
            The 0-th distortion coefficients (k1) are fixed 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixK2">
            <summary>
            The 1-th distortion coefficients (k2) are fixed 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixK3">
            <summary>
            The 4-th distortion coefficients (k3) are fixed 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixK4">
            <summary>
            Do not change the corresponding radial distortion coefficient during the optimization. 
            If CV_CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used, otherwise it is set to 0.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixK5">
            <summary>
            Do not change the corresponding radial distortion coefficient during the optimization. 
            If CV_CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used, otherwise it is set to 0.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixK6">
            <summary>
            Do not change the corresponding radial distortion coefficient during the optimization. 
            If CV_CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used, otherwise it is set to 0.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.RationalModel">
            <summary>
            Enable coefficients k4, k5 and k6. 
            To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function 
            use the rational model and return 8 coefficients. If the flag is not set, the function will compute only 5 distortion coefficients.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.ThinPrismModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixS1S2S3S4">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.FixIntrinsic">
            <summary>
            If it is set, camera_matrix1,2, as well as dist_coeffs1,2 are fixed, so that only extrinsic parameters are optimized.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.SameFocalLength">
            <summary>
            Enforces fx0=fx1 and fy0=fy1. CV_CALIB_ZERO_TANGENT_DIST - Tangential distortion coefficients for each camera are set to zeros and fixed there.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CalibrationFlags.ZeroDisparity">
            <summary>
            for stereo rectification
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ChessboardFlags">
            <summary>
            Various operation flags for cvFindChessboardCorners
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ChessboardFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ChessboardFlags.AdaptiveThresh">
            <summary>
            Use adaptive thresholding to convert the image to black-n-white, rather than a fixed threshold level (computed from the average image brightness).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ChessboardFlags.NormalizeImage">
            <summary>
            Normalize the image using cvNormalizeHist before applying fixed or adaptive thresholding.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ChessboardFlags.FilterQuads">
            <summary>
            Use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads
            that are extracted at the contour retrieval stage.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ChessboardFlags.FastCheck">
            <summary>
            Run a fast check on the image that looks for chessboard corners, and shortcut the call if none is found.
            This can drastically speed up the call in the degenerate condition when no chessboard is observed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ChessboardFlags.Exhaustive">
            <summary>
            Run an exhaustive search to improve detection rate.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ChessboardFlags.Accuracy">
            <summary>
            Up sample input image to improve sub-pixel accuracy due to aliasing effects.
            This should be used if an accurate camera calibration is required.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.EssentialMatMethod">
            <summary>
            Method for computing the essential matrix 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EssentialMatMethod.LMedS">
            <summary>
            for LMedS algorithm.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EssentialMatMethod.Ransac">
            <summary>
            for RANSAC algorithm.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FindCirclesGridFlags">
            <summary>
            Method for solving a PnP problem:
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FindCirclesGridFlags.SymmetricGrid">
            <summary>
            uses symmetric pattern of circles.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FindCirclesGridFlags.AsymmetricGrid">
            <summary>
            uses asymmetric pattern of circles.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FindCirclesGridFlags.Clustering">
            <summary>
            uses a special algorithm for grid detection. It is more robust to perspective distortions but much more sensitive to background clutter.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FundamentalMatMethods">
            <summary>
            Method for computing the fundamental matrix 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FundamentalMatMethods.Point7">
            <summary>
            for 7-point algorithm. N == 7 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FundamentalMatMethods.Point8">
            <summary>
            for 8-point algorithm. N >= 8 
            [CV_FM_8POINT]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FundamentalMatMethods.LMedS">
            <summary>
            for LMedS algorithm. N > 8 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FundamentalMatMethods.Ransac">
            <summary>
            for RANSAC algorithm. N > 8 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.HandEyeCalibrationMethod">
            <summary>
            method One of the implemented Hand-Eye calibration method
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HandEyeCalibrationMethod.TSAI">
            <summary>
            A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/Eye Calibration @cite Tsai89
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HandEyeCalibrationMethod.PARK">
            <summary>
            Robot Sensor Calibration: Solving AX = XB on the Euclidean Group @cite Park94
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HandEyeCalibrationMethod.HORAUD">
            <summary>
            Hand-eye Calibration @cite Horaud95
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HandEyeCalibrationMethod.ANDREFF">
            <summary>
            On-line Hand-Eye Calibration @cite Andreff99
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HandEyeCalibrationMethod.DANIILIDIS">
            <summary>
            Hand-Eye Calibration Using Dual Quaternions @cite Daniilidis98
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.HomographyMethods">
            <summary>
            The method used to computed homography matrix
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.None">
            <summary>
            Regular method using all the point pairs
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.LMedS">
            <summary>
            Least-Median robust method
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.Ransac">
            <summary>
            RANSAC-based robust method
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.Rho">
            <summary>
            RHO algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.USAC_DEFAULT">
            <summary>
            USAC algorithm, default settings
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.USAC_PARALLEL">
            <summary>
            USAC, parallel version
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.USAC_FM_8PTS">
            <summary>
            USAC, fundamental matrix 8 points
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.USAC_FAST">
            <summary>
            USAC, fast settings
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.USAC_ACCURATE">
            <summary>
            USAC, accurate settings
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.USAC_PROSAC">
            <summary>
            USAC, sorted points, runs PROSAC
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HomographyMethods.USAC_MAGSAC">
            <summary>
            USAC, runs MAGSAC++
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ProjectionType">
            <summary>
            cv::initWideAngleProjMap flags
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ProjectionType.SphericalOrtho">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ProjectionType.SphericalEqRect">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.RobotWorldHandEyeCalibrationMethod">
            <summary>
            One of the implemented Robot-World/Hand-Eye calibration method
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobotWorldHandEyeCalibrationMethod.SHAH">
            <summary>
            Solving the robot-world/hand-eye calibration problem using the kronecker product @cite Shah2013SolvingTR
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobotWorldHandEyeCalibrationMethod.LI">
            <summary>
            Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product @cite Li2010SimultaneousRA
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.RobustEstimationAlgorithms">
            <summary>
            type of the robust estimation algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.LMEDS">
            <summary>
            least-median of squares algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.RANSAC">
            <summary>
            RANSAC algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.RHO">
            <summary>
            RHO algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.USAC_DEFAULT">
            <summary>
            USAC algorithm, default settings
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.USAC_PARALLEL">
            <summary>
            USAC, parallel version
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.USAC_FM_8PTS">
            <summary>
            USAC, fundamental matrix 8 points
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.USAC_FAST">
            <summary>
            USAC, fast settings
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.USAC_ACCURATE">
            <summary>
            USAC, accurate settings
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.USAC_PROSAC">
            <summary>
            USAC, sorted points, runs PROSAC
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RobustEstimationAlgorithms.USAC_MAGSAC">
            <summary>
            USAC, runs MAGSAC++
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.SolvePnPFlags">
            <summary>
            Method for solving a PnP problem:
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolvePnPFlags.Iterative">
            <summary>
            Iterative method is based on Levenberg-Marquardt optimization. 
            In this case the function finds such a pose that minimizes reprojection error, 
            that is the sum of squared distances between the observed projections imagePoints and the projected (using projectPoints() ) objectPoints .
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolvePnPFlags.EPNP">
            <summary>
            Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the paper “EPnP: Efficient Perspective-n-Point Camera Pose Estimation”.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolvePnPFlags.P3P">
            <summary>
            Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang“Complete Solution Classification for 
            the Perspective-Three-Point Problem”. In this case the function requires exactly four object and image points.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolvePnPFlags.DLS">
            <summary>
            Joel A. Hesch and Stergios I. Roumeliotis. "A Direct Least-Squares (DLS) Method for PnP"
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolvePnPFlags.UPNP">
            <summary>
            A.Penate-Sanchez, J.Andrade-Cetto, F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length Estimation"
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.StereoRectificationFlags">
            <summary>
            The operation flags for cvStereoRectify
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.StereoRectificationFlags.None">
            <summary>
            Default value (=0).
            the function can shift one of the image in horizontal or vertical direction (depending on the orientation of epipolar lines) in order to maximise the useful image area. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.StereoRectificationFlags.ZeroDisparity">
            <summary>
            the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.StereoBM">
            <summary>
            Semi-Global Stereo Matching
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.StereoBM.#ctor(System.IntPtr)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.StereoBM.Create(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="numDisparities"></param>
            <param name="blockSize"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.StereoBM.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoBM.PreFilterType">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoBM.PreFilterSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoBM.PreFilterCap">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoBM.TextureThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoBM.UniquenessRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoBM.SmallerBlockSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoBM.ROI1">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoBM.ROI2">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.StereoMatcher">
            <summary>
            The base class for stereo correspondence algorithms.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.StereoMatcher.#ctor(System.IntPtr)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.StereoMatcher.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Computes disparity map for the specified stereo pair
            </summary>
            <param name="left">Left 8-bit single-channel image.</param>
            <param name="right">Right image of the same size and the same type as the left one.</param>
            <param name="disparity">Output disparity map. It has the same size as the input images. Some algorithms, 
            like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map(where each disparity value has 4 fractional bits), 
            whereas other algorithms output 32 - bit floating - point disparity map.</param>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoMatcher.MinDisparity">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoMatcher.NumDisparities">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoMatcher.BlockSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoMatcher.SpeckleWindowSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoMatcher.SpeckleRange">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoMatcher.Disp12MaxDiff">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.StereoSGBMMode">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.StereoSGBM">
            <summary>
            Semi-Global Stereo Matching
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.StereoSGBM.#ctor(System.IntPtr)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.StereoSGBM.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.StereoSGBMMode)">
            <summary>
            
            </summary>
            <param name="minDisparity"></param>
            <param name="numDisparities"></param>
            <param name="blockSize"></param>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="disp12MaxDiff"></param>
            <param name="preFilterCap"></param>
            <param name="uniquenessRatio"></param>
            <param name="speckleWindowSize"></param>
            <param name="speckleRange"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.StereoSGBM.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoSGBM.PreFilterCap">
            <summary>
            Truncation value for the prefiltered image pixels. The algorithm first
            computes x-derivative at each pixel and clips its value by [-preFilterCap, preFilterCap] interval.
            The result values are passed to the Birchfield-Tomasi pixel cost function.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoSGBM.UniquenessRatio">
            <summary>
            Margin in percentage by which the best (minimum) computed cost function
            value should "win" the second best value to consider the found match correct. Normally, a value
            within the 5-15 range is good enough.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoSGBM.P1">
            <summary>
            The first parameter controlling the disparity smoothness. See P2 description.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoSGBM.P2">
            <summary>
            The second parameter controlling the disparity smoothness. The larger the values are,
            the smoother the disparity is. P1 is the penalty on the disparity change by plus or minus 1
            between neighbor pixels. P2 is the penalty on the disparity change by more than 1 between neighbor
            pixels. The algorithm requires P2 \> P1 . See stereo_match.cpp sample where some reasonably good
            P1 and P2 values are shown (like 8\*number_of_image_channels\*SADWindowSize\*SADWindowSize and
            32\*number_of_image_channels\*SADWindowSize\*SADWindowSize , respectively).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.StereoSGBM.Mode">
            <summary>
            Set it to StereoSGBM::MODE_HH to run the full-scale two-pass dynamic programming
            algorithm. It will consume O(W\*H\*numDisparities) bytes, which is large for 640x480 stereo and
            huge for HD-size pictures. By default, it is set to false .
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Algorithm">
            <summary>
            Base class for high-level OpenCV algorithms
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Algorithm.Write(ST4IVisionCoreNet.FileStorage)">
            <summary>
            Stores algorithm parameters in a file storage
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Algorithm.Read(ST4IVisionCoreNet.FileNode)">
            <summary>
            Reads algorithm parameters from a file storage
            </summary>
            <param name="fn"></param>
        </member>
        <member name="P:ST4IVisionCoreNet.Algorithm.Empty">
            <summary>
            Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Algorithm.Save(System.String)">
            <summary>
            Saves the algorithm to a file.
            In order to make this method work, the derived class must 
            implement Algorithm::write(FileStorage fs).
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Algorithm.GetDefaultName">
            <summary>
            Returns the algorithm string identifier.
            This string is used as top level xml/yml node tag when the object 
            is saved to a file or string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.CvErrorCallback">
            <summary>
            Error Handler
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Pointer to the user data. Ignored by the standard handlers</param>
        </member>
        <member name="T:ST4IVisionCoreNet.AccessFlag">
            <summary>
            cv::AccessFlag
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.AlgorithmParamType">
            <summary>
            cv::Algorithm parameter type
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.BorderTypes">
             <summary>
             Type of the border to create around the copied source image rectangle
             </summary>
             <remarks>
            https://github.com/opencv/opencv/blob/fc1a15626226609babd128e043cf7c4e32f567ca/modules/core/include/opencv2/core/base.hpp#L268
             </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.BorderTypes.Constant">
            <summary>
            Border is filled with the fixed value, passed as last parameter of the function.
            `iiiiii|abcdefgh|iiiiiii`  with some specified `i`
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BorderTypes.Replicate">
            <summary>
            The pixels from the top and bottom rows, the left-most and right-most columns are replicated to fill the border.
            `aaaaaa|abcdefgh|hhhhhhh`
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BorderTypes.Reflect">
            <summary>
            `fedcba|abcdefgh|hgfedcb`
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BorderTypes.Wrap">
            <summary>
            `cdefgh|abcdefgh|abcdefg`
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BorderTypes.Reflect101">
            <summary>
            `gfedcb|abcdefgh|gfedcba`
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BorderTypes.Transparent">
            <summary>
            `uvwxyz|absdefgh|ijklmno`
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BorderTypes.Default">
            <summary>
            same as BORDER_REFLECT_101
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BorderTypes.Isolated">
            <summary>
            do not look outside of ROI
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CmpType">
            <summary>
            The flag specifying the relation between the elements to be checked
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CmpType.EQ">
            <summary>
            src1(I) "equal to" src2(I)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CmpType.GT">
            <summary>
            src1(I) "greater than" src2(I)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CmpType.GE">
            <summary>
            src1(I) "greater or equal" src2(I)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CmpType.LT">
            <summary>
            src1(I) "less than" src2(I)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CmpType.LE">
            <summary>
            src1(I) "less or equal" src2(I)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CmpType.NE">
            <summary>
            src1(I) "not equal to" src2(I)
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CovarFlags">
            <summary>
            Operation flags for Covariation 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CovarFlags.Scrambled">
            <summary>
            scale * [vects[0]-avg,vects[1]-avg,...]^T * [vects[0]-avg,vects[1]-avg,...]   
            that is, the covariation matrix is count×count. Such an unusual covariation matrix is used for fast PCA of a set of very large vectors
            (see, for example, Eigen Faces technique for face recognition). Eigenvalues of this "scrambled" matrix will match to the eigenvalues of
            the true covariation matrix and the "true" eigenvectors can be easily calculated from the eigenvectors of the "scrambled" covariation matrix.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CovarFlags.Normal">
            <summary>
            scale * [vects[0]-avg,vects[1]-avg,...]*[vects[0]-avg,vects[1]-avg,...]^T   
            that is, cov_mat will be a usual covariation matrix with the same linear size as the total number of elements in every input vector. 
            One and only one of CV_COVAR_SCRAMBLED and CV_COVAR_NORMAL must be specified
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CovarFlags.UseAvg">
            <summary>
            If the flag is specified, the function does not calculate avg from the input vectors, 
            but, instead, uses the passed avg vector. This is useful if avg  has been already calculated somehow, 
            or if the covariation matrix is calculated by parts - in this case, avg is not a mean vector of the input sub-set of vectors, 
            but rather the mean vector of the whole set.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CovarFlags.Scale">
            <summary>
            If the flag is specified, the covariation matrix is scaled by the number of input vectors.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CovarFlags.Rows">
            <summary>
            Means that all the input vectors are stored as rows of a single matrix, vects[0].count is ignored in this case, 
            and avg should be a single-row vector of an appropriate size.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CovarFlags.Cols">
            <summary>
            Means that all the input vectors are stored as columns of a single matrix, vects[0].count is ignored in this case, 
            and avg should be a single-column vector of an appropriate size. 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CpuFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CriteriaTypes">
            <summary>
            Type of termination criteria 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CriteriaTypes.Count">
            <summary>
            the maximum number of iterations or elements to compute
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CriteriaTypes.MaxIter">
            <summary>
            the maximum number of iterations or elements to compute
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CriteriaTypes.Eps">
            <summary>
            the desired accuracy or change in parameters at which the iterative algorithm stops
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DctFlags">
            <summary>
            Transformation flags for cv::dct
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DctFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DctFlags.Inverse">
            <summary>
            Do inverse 1D or 2D transform.
            (Forward and Inverse are mutually exclusive, of course.)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DctFlags.Rows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. 
            This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead 
            (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc. 
            [CV_DXT_ROWS]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DecompTypes">
            <summary>
            Inversion methods
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DecompTypes.LU">
            <summary>
            Gaussian elimination with the optimal pivot element chosen.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DecompTypes.SVD">
            <summary>
            singular value decomposition (SVD) method; 
            the system can be over-defined and/or the matrix src1 can be singular
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DecompTypes.Eig">
            <summary>
            eigenvalue decomposition; the matrix src1 must be symmetrical
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DecompTypes.Cholesky">
            <summary>
            Cholesky \f$LL^T\f$ factorization; the matrix src1 must be symmetrical 
            and positively defined
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DecompTypes.QR">
            <summary>
            QR factorization; the system can be over-defined and/or the matrix 
            src1 can be singular 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DecompTypes.Normal">
            <summary>
            while all the previous flags are mutually exclusive, 
            this flag can be used together with any of the previous
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DftFlags">
            <summary>
            Transformation flags for cvDFT
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DftFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DftFlags.Inverse">
            <summary>
            Do inverse 1D or 2D transform. The result is not scaled. 
            (Forward and Inverse are mutually exclusive, of course.)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DftFlags.Scale">
            <summary>
            Scale the result: divide it by the number of array elements. Usually, it is combined with Inverse.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DftFlags.Rows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. 
            This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead
            (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DftFlags.ComplexOutput">
            <summary>
            performs a forward transformation of 1D or 2D real array; the result, 
            though being a complex array, has complex-conjugate symmetry (*CCS*, 
            see the function description below for details), and such an array can 
            be packed into a real array of the same size as input, which is the fastest 
            option and which is what the function does by default; however, you may 
            wish to get a full complex array (for simpler spectrum analysis, and so on) - 
            pass the flag to enable the function to produce a full-size complex output array.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DftFlags.RealOutput">
            <summary>
            performs an inverse transformation of a 1D or 2D complex array; 
            the result is normally a complex array of the same size, however, 
            if the input array has conjugate-complex symmetry (for example, 
            it is a result of forward transformation with DFT_COMPLEX_OUTPUT flag), 
            the output is a real array; while the function itself does not 
            check whether the input is symmetrical or not, you can pass the flag 
            and then the function will assume the symmetry and produce the real 
            output array (note that when the input is packed into a real array 
            and inverse transformation is executed, the function treats the input 
            as a packed complex-conjugate symmetrical array, and the output 
            will also be a real array).
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DistributionType">
            <summary>
            Distribution type for cvRandArr, etc.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistributionType.Uniform">
            <summary>
            Uniform distribution
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistributionType.Normal">
            <summary>
            Normal or Gaussian distribution
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ErrorCode">
            <summary>
            Error status codes
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsOk">
            <summary>
            everithing is ok [CV_StsOk]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsBackTrace">
            <summary>
            pseudo error for back trace [CV_StsBackTrace]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsError">
            <summary>
            unknown /unspecified error [CV_StsError]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsInternal">
            <summary>
            internal error (bad state)  [CV_StsInternal]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsNoMem">
            <summary>
            insufficient memory [CV_StsNoMem]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsBadArg">
            <summary>
            function arg/param is bad [CV_StsBadArg]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsBadFunc">
            <summary>
            unsupported function [CV_StsBadFunc]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsNoConv">
            <summary>
            iter. didn't converge [CV_StsNoConv]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsAutoTrace">
            <summary>
            tracing [CV_StsAutoTrace]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.HeaderIsNull">
            <summary>
            image header is NULL [CV_HeaderIsNull]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadImageSize">
            <summary>
            image size is invalid [CV_BadImageSize]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadOffset">
            <summary>
            offset is invalid [CV_BadOffset]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadDataPtr">
            <summary>
            [CV_BadOffset]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadStep">
            <summary>
            [CV_BadStep]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadModelOrChSeq">
            <summary>
            [CV_BadModelOrChSeq]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadNumChannels">
            <summary>
            [CV_BadNumChannels]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadNumChannel1U">
            <summary>
            [CV_BadNumChannel1U]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadDepth">
            <summary>
            [CV_BadDepth]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadAlphaChannel">
            <summary>
            [CV_BadAlphaChannel]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadOrder">
            <summary>
            [CV_BadOrder]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadOrigin">
            <summary>
            [CV_BadOrigin]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadAlign">
            <summary>
            [CV_BadAlign]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadCallBack">
            <summary>
            [CV_BadCallBack]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadTileSize">
            <summary>
            [CV_BadTileSize]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadCOI">
            <summary>
            [CV_BadCOI]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.BadROISize">
            <summary>
            [CV_BadROISize]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.MaskIsTiled">
            <summary>
            [CV_MaskIsTiled]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsNullPtr">
            <summary>
            null pointer [CV_StsNullPtr]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsVecLengthErr">
            <summary>
            incorrect vector length [CV_StsVecLengthErr]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsFilterStructContentErr">
            <summary>
            incorr. filter structure content [CV_StsFilterStructContentErr]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsKernelStructContentErr">
            <summary>
            incorr. transform kernel content [CV_StsKernelStructContentErr]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsFilterOffsetErr">
            <summary>
            incorrect filter ofset value [CV_StsFilterOffsetErr]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsBadSize">
            <summary>
            the input/output structure size is incorrect [CV_StsBadSize]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsDivByZero">
            <summary>
            division by zero [CV_StsDivByZero]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsInplaceNotSupported">
            <summary>
            in-place operation is not supported [CV_StsInplaceNotSupported]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsObjectNotFound">
            <summary>
            request can't be completed [CV_StsObjectNotFound]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsUnmatchedFormats">
            <summary>
            formats of input/output arrays differ [CV_StsUnmatchedFormats]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsBadFlag">
            <summary>
            flag is wrong or not supported [CV_StsBadFlag]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsBadPoint">
            <summary>
            bad CvPoint [CV_StsBadPoint]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsBadMask">
            <summary>
            bad format of mask (neither 8uC1 nor 8sC1) [CV_StsBadMask]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsUnmatchedSizes">
            <summary>
            sizes of input/output structures do not match [CV_StsUnmatchedSizes]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsUnsupportedFormat">
            <summary>
            the data format/type is not supported by the function [CV_StsUnsupportedFormat]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsOutOfRange">
            <summary>
            some of parameters are out of range [CV_StsOutOfRange]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsParseError">
            <summary>
            invalid syntax/structure of the parsed file [CV_StsParseError]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsNotImplemented">
            <summary>
            the requested function/feature is not implemented [CV_StsNotImplemented]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsBadMemBlock">
            <summary>
            an allocated block has been corrupted [CV_StsBadMemBlock]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ErrorCode.StsAssert">
            <summary>
            assertion failed
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FormatType">
            <summary>
            Output string format of Mat.Dump()
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FormatType.Default">
            <summary>
            Default format. 
            [1, 2, 3, 4, 5, 6; \n
            7, 8, 9, ... ]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FormatType.MATLAB">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FormatType.CSV">
            <summary>
            CSV format. 
            1, 2, 3, 4, 5, 6\n
            7, 8, 9, ...
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FormatType.Python">
            <summary>
            Python format. 
            [[[1, 2, 3], [4, 5, 6]], \n
            [[7, 8, 9], ... ]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FormatType.NumPy">
            <summary>
            NumPy format. 
            array([[[1, 2, 3], [4, 5, 6]], \n
            [[7, 8, 9], .... ]]], type='uint8');
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FormatType.C">
            <summary>
            C language format. 
            {1, 2, 3, 4, 5, 6, \n
            7, 8, 9, ...}; 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.GemmFlags">
            <summary>
            The operation flags for cv::GEMM
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GemmFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GemmFlags.A_T">
            <summary>
            Transpose src1
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GemmFlags.B_T">
            <summary>
            Transpose src2
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GemmFlags.C_T">
            <summary>
            Transpose src3
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.HersheyFonts">
            <summary>
            Font name identifier. 
            Only a subset of Hershey fonts (http://sources.isc.org/utils/misc/hershey-font.txt) are supported now.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.HersheySimplex">
            <summary>
            normal size sans-serif font
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.HersheyPlain">
            <summary>
            small size sans-serif font
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.HersheyDuplex">
            <summary>
            normal size sans-serif font (more complex than HERSHEY_SIMPLEX)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.HersheyComplex">
            <summary>
            normal size serif font
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.HersheyTriplex">
            <summary>
            normal size serif font (more complex than HERSHEY_COMPLEX)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.HersheyComplexSmall">
            <summary>
            smaller version of HERSHEY_COMPLEX
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.HersheyScriptSimplex">
            <summary>
            hand-writing style font
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.HersheyScriptComplex">
            <summary>
            more complex variant of HERSHEY_SCRIPT_SIMPLEX
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HersheyFonts.Italic">
            <summary>
            flag for italic font
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.InOutArrayKind">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.KMeansFlags">
            <summary>
            Miscellaneous flags for cv::kmeans
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KMeansFlags.RandomCenters">
            <summary>
            Select random initial centers in each attempt.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KMeansFlags.PpCenters">
            <summary>
            Use kmeans++ center initialization by Arthur and Vassilvitskii [Arthur2007].
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KMeansFlags.UseInitialLabels">
            <summary>
            During the first (and possibly the only) attempt, use the
            user-supplied labels instead of computing them from the initial centers. 
            For the second and further attempts, use the random or semi-random centers. 
            Use one of KMEANS_\*_CENTERS flag to specify the exact method.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MatDiagType">
            <summary>
            diagonal type
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatDiagType.Upper">
            <summary>
            a diagonal from the upper half
            [&lt; 0]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatDiagType.Main">
            <summary>
            Main diagonal
            [= 0]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatDiagType.Lower">
            <summary>
            a diagonal from the lower half
            [&gt; 0]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.NormTypes">
            <summary>
            Type of norm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NormTypes.INF">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NormTypes.L1">
            <summary>
            The L1-norm (sum of absolute values) of the array is normalized.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NormTypes.L2">
            <summary>
            The (Euclidean) L2-norm of the array is normalized.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NormTypes.L2SQR">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NormTypes.Hamming">
             <summary>
            
             </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NormTypes.Hamming2">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NormTypes.Relative">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NormTypes.MinMax">
            <summary>
            The array values are scaled and shifted to the specified range.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ReduceDimension">
            <summary>
            The dimension index along which the matrix is reduce.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ReduceDimension.Row">
            <summary>
            The matrix is reduced to a single row.
            [= 0]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ReduceDimension.Column">
            <summary>
            The matrix is reduced to a single column.
            [= 1]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ReduceDimension.Auto">
            <summary>
            The dimension is chosen automatically by analysing the dst size. 
            [= -1]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ReduceTypes">
             <summary>
             The reduction operations for cvReduce
             </summary>
             <remarks>
            https://github.com/opencv/opencv/blob/37c12db3668a1fbbfdb286be59f662c67cfbfea1/modules/core/include/opencv2/core.hpp#L231
             </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.ReduceTypes.Sum">
            <summary>
            The output is the sum of all the matrix rows/columns.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ReduceTypes.Avg">
            <summary>
            The output is the mean vector of all the matrix rows/columns.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ReduceTypes.Max">
            <summary>
            The output is the maximum (column/row-wise) of all the matrix rows/columns.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ReduceTypes.Min">
            <summary>
            The output is the minimum (column/row-wise) of all the matrix rows/columns.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.RotateFlags">
            <summary>
            an enum to specify how to rotate the array.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RotateFlags.Rotate90Clockwise">
            <summary>
            Rotate 90 degrees clockwise
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RotateFlags.Rotate180">
            <summary>
            Rotate 180 degrees clockwise
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RotateFlags.Rotate90Counterclockwise">
            <summary>
            Rotate 270 degrees clockwise
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.SolveLPResult">
            <summary>
            return codes for cv::solveLP() function
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolveLPResult.Unbounded">
            <summary>
            problem is unbounded (target function can achieve arbitrary high values)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolveLPResult.Unfeasible">
            <summary>
            problem is unfeasible (there are no points that satisfy all the constraints imposed)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolveLPResult.Single">
            <summary>
            there is only one maximum for target function
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SolveLPResult.Multi">
            <summary>
            there are multiple maxima for target function - the arbitrary one is returned
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.SortFlags">
            <summary>
            Signals an error and raises the exception.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SortFlags.EveryRow">
            <summary>
            each matrix row is sorted independently
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SortFlags.EveryColumn">
            <summary>
            each matrix column is sorted independently; 
            this flag and the previous one are mutually exclusive.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SortFlags.Ascending">
            <summary>
            each matrix row is sorted in the ascending order.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SortFlags.Descending">
            <summary>
            each matrix row is sorted in the descending order; 
            this flag and the previous one are also mutually exclusive.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.UMatUsageFlags">
            <summary>
            cv::UMatUsageFlags
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FileNode">
            <summary>
            File Storage Node class
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.#ctor(System.IntPtr)">
            <summary>
            Initializes from cv::FileNode*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.op_Explicit(ST4IVisionCoreNet.FileNode)~System.Int32">
            <summary>
            Returns the node content as an integer. If the node stores floating-point number, it is rounded.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ToInt32">
            <summary>
            Returns the node content as an integer. If the node stores floating-point number, it is rounded.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.op_Explicit(ST4IVisionCoreNet.FileNode)~System.Single">
            <summary>
            Returns the node content as float
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ToSingle">
            <summary>
            Returns the node content as System.Single
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.op_Explicit(ST4IVisionCoreNet.FileNode)~System.Double">
            <summary>
            Returns the node content as double
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ToDouble">
            <summary>
            Returns the node content as double
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.op_Explicit(ST4IVisionCoreNet.FileNode)~System.String">
            <summary>
            Returns the node content as text string
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ToString">
            <summary>
            Returns the node content as text string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.op_Explicit(ST4IVisionCoreNet.FileNode)~ST4IVisionCoreNet.Mat">
            <summary>
            Returns the node content as OpenCV Mat
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ToMat">
            <summary>
            Returns the node content as OpenCV Mat
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.Item(System.String)">
            <summary>
            returns element of a mapping node
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.Item(System.Int32)">
            <summary>
            returns element of a sequence node
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.Empty">
            <summary>
            Returns true if the node is empty
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.IsNone">
            <summary>
            Returns true if the node is a "none" object
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.IsSeq">
            <summary>
            Returns true if the node is a sequence
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.IsMap">
            <summary>
            Returns true if the node is a mapping
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.IsInt">
            <summary>
            Returns true if the node is an integer
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.IsReal">
            <summary>
            Returns true if the node is a floating-point number
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.IsString">
            <summary>
            Returns true if the node is a text string
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.IsNamed">
            <summary>
            Returns true if the node has a name
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.Name">
            <summary>
            Returns the node name or an empty string if the node is nameless
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.Size">
            <summary>
            Returns the number of elements in the node, if it is a sequence or mapping, or 1 otherwise.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNode.Type">
            <summary>
            Returns type of the node.
            </summary>
            <returns>Type of the node.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.Begin">
            <summary>
            returns iterator pointing to the first node element
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.End">
            <summary>
            returns iterator pointing to the element following the last node element
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.GetEnumerator">
            <summary>
            Get FileNode iterator 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadRaw(System.String,System.IntPtr,System.Int64)">
            <summary>
            Reads node elements to the buffer with the specified format
            </summary>
            <param name="fmt"></param>
            <param name="vec"></param>
            <param name="len"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadInt(System.Int32)">
            <summary>
            Reads the node element as Int32 (int)
            </summary>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadFloat(System.Single)">
            <summary>
            Reads the node element as Single (float)
            </summary>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadDouble(System.Double)">
            <summary>
            Reads the node element as Double
            </summary>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadString(System.String)">
            <summary>
            Reads the node element as String
            </summary>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadMat(ST4IVisionCoreNet.Mat)">
            <summary>
            Reads the node element as Mat
            </summary>
            <param name="defaultMat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadSparseMat(ST4IVisionCoreNet.SparseMat)">
            <summary>
            Reads the node element as SparseMat
            </summary>
            <param name="defaultMat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadKeyPoints">
            <summary>
            Reads the node element as KeyPoint[]
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadDMatches">
            <summary>
            Reads the node element as DMatch[]
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadRange">
            <summary>
            Reads the node element as Range
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadKeyPoint">
            <summary>
            Reads the node element as KeyPoint
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadDMatch">
            <summary>
            Reads the node element as DMatch
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadPoint">
            <summary>
            Reads the node element as Point
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadPoint2f">
            <summary>
            Reads the node element as Point2f
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadPoint2d">
            <summary>
            Reads the node element as Point2d
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadPoint3i">
            <summary>
            Reads the node element as Point3i
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadPoint3f">
            <summary>
            Reads the node element as Point3f
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadPoint3d">
            <summary>
            Reads the node element as Point3d
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadSize">
            <summary>
            Reads the node element as Size
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadSize2f">
            <summary>
            Reads the node element as Size2f
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadSize2d">
            <summary>
            Reads the node element as Size2d
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadRect">
            <summary>
            Reads the node element as Rect
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadRect2f">
            <summary>
            Reads the node element as Rect2f
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadRect2d">
            <summary>
            Reads the node element as Rect2d
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadScalar">
            <summary>
            Reads the node element as Scalar
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec2i">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec3i">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec4i">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec6i">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec2d">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec3d">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec4d">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec6d">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec2f">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec3f">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec4f">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec6f">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec2b">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec3b">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec4b">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec6b">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec2s">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec3s">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec4s">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec6s">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec2w">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec3w">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec4w">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNode.ReadVec6w">
            <summary>
            Reads the node element as Vector
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.FileNode.Types">
            <summary>
            type of the file storage node
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.None">
            <summary>
            empty node
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Int">
            <summary>
            an integer
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Real">
            <summary>
            floating-point number
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Float">
            <summary>
            synonym or REAL
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Str">
            <summary>
            text string in UTF-8 encoding
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.String">
            <summary>
            synonym for STR
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Seq">
            <summary>
            sequence
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Map">
            <summary>
            mapping
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.TypeMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Flow">
            <summary>
            compact representation of a sequence or mapping. Used only by YAML writer
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Uniform">
            <summary>
            if set, means that all the collection elements are numbers of the same type (real's or int's).
            UNIFORM is used only when reading FileStorage; FLOW is used only when writing. So they share the same bit
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Empty">
            <summary>
            empty structure (sequence or mapping)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileNode.Types.Named">
            <summary>
            the node has a name (i.e. it is element of a mapping)
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FileNodeIterator">
            <inheritdoc cref="T:ST4IVisionCoreNet.DisposableCvObject" />
            <summary>
            File Storage Node class
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNodeIterator.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNodeIterator.#ctor(System.IntPtr)">
            <summary>
            Initializes from cv::FileNode*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNodeIterator.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNodeIterator.ReadRaw(System.String,System.IntPtr,System.Int64)">
            <summary>
            Reads node elements to the buffer with the specified format. 
            Usually it is more convenient to use operator `>>` instead of this method.
            </summary>
            <param name="fmt">Specification of each array element.See @ref format_spec "format specification"</param>
            <param name="vec">Pointer to the destination array.</param>
            <param name="maxCount">Number of elements to read. If it is greater than number of remaining elements then all of them will be read.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileNodeIterator.Current">
            <summary>
            *iterator
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNodeIterator.Reset">
            <summary>
            IEnumerable&lt;T&gt;.Reset
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNodeIterator.MoveNext">
            <summary>
            iterator++
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNodeIterator.MoveNext(System.Int32)">
            <summary>
            iterator += ofs
            </summary>
            <param name="ofs"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileNodeIterator.ReadRaw(System.String,System.Byte[],System.Int64)">
            <summary>
            Reads node elements to the buffer with the specified format. 
            Usually it is more convenient to use operator `>>` instead of this method.
            </summary>
            <param name="fmt">Specification of each array element.See @ref format_spec "format specification"</param>
            <param name="vec">Pointer to the destination array.</param>
            <param name="maxCount">Number of elements to read. If it is greater than number of remaining elements then all of them will be read.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.FileStorage">
            <summary>
            XML/YAML File Storage Class.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.#ctor">
            <summary>
            Default constructor.
            You should call FileStorage::open() after initialization.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.#ctor(System.String,ST4IVisionCoreNet.FileStorage.Modes,System.String)">
            <summary>
            The full constructor
            </summary>
            <param name="source">Name of the file to open or the text string to read the data from. 
            Extension of the file (.xml or .yml/.yaml) determines its format 
            (XML or YAML respectively). Also you can append .gz to work with 
            compressed files, for example myHugeMatrix.xml.gz. 
            If both FileStorage::WRITE and FileStorage::MEMORY flags are specified, 
            source is used just to specify the output file format 
            (e.g. mydata.xml, .yml etc.).</param>
            <param name="flags"></param>
            <param name="encoding">Encoding of the file. Note that UTF-16 XML encoding is not supported 
            currently and you should use 8-bit encoding instead of it.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FileStorage.Item(System.String)">
            <summary>
            Returns the specified element of the top-level mapping
            </summary>
            <param name="nodeName"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.FileStorage.ElName">
            <summary>
            the currently written element
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FileStorage.State">
            <summary>
            the writer state
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Open(System.String,ST4IVisionCoreNet.FileStorage.Modes,System.String)">
            <summary>
            operator that performs PCA. The previously stored data, if any, is released
            </summary>
            <param name="fileName">Name of the file to open or the text string to read the data from.
            Extension of the file (.xml, .yml/.yaml or .json) determines its format (XML, YAML or JSON respectively).
            Also you can append .gz to work with compressed files, for example myHugeMatrix.xml.gz.
            If both FileStorage::WRITE and FileStorage::MEMORY flags are specified, source is used just to specify the output file format (e.g. mydata.xml, .yml etc.).
            A file name can also contain parameters. You can use this format, "*?base64" (e.g. "file.json?base64" (case sensitive)),
            as an alternative to FileStorage::BASE64 flag.</param>
            <param name="flags">Mode of operation.</param>
            <param name="encoding">Encoding of the file. Note that UTF-16 XML encoding is not supported 
            currently and you should use 8-bit encoding instead of it.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.IsOpened">
            <summary>
            Returns true if the object is associated with currently opened file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Release">
            <summary>
            Closes the file and releases all the memory buffers
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.ReleaseAndGetString">
            <summary>
            Closes the file, releases all the memory buffers and returns the text string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.GetFirstTopLevelNode">
            <summary>
            Returns the first element of the top-level mapping
            </summary>
            <returns>The first element of the top-level mapping.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Root(System.Int32)">
            <summary>
            Returns the top-level mapping. YAML supports multiple streams
            </summary>
            <param name="streamIdx"> Zero-based index of the stream. In most cases there is only one stream in the file.
            However, YAML supports multiple streams and so there can be several.</param>
            <returns>The top-level mapping.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.WriteRaw(System.String,System.IntPtr,System.Int32)">
            <summary>
            Writes one or more numbers of the specified format to the currently written structure
            </summary>
            <param name="fmt">Specification of each array element, see @ref format_spec "format specification"</param>
            <param name="vec">Pointer to the written array.</param>
            <param name="len">Number of the uchar elements to write.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.WriteComment(System.String,System.Boolean)">
            <summary>
            Writes a comment.
            The function writes a comment into file storage. The comments are skipped when the storage is read.
            </summary>
            <param name="comment">The written comment, single-line or multi-line</param>
            <param name="append">If true, the function tries to put the comment at the end of current line.
            Else if the comment is multi-line, or if it does not fit at the end of the current line, the comment starts a new line.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.StartWriteStruct(System.String,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="flags"></param>
            <param name="typeName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.EndWriteStruct">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.GetDefaultObjectName(System.String)">
            <summary>
            Returns the normalized object name for the specified file name
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Write(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Write(System.String,System.Single)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Write(System.String,System.Double)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Write(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Write(System.String,ST4IVisionCoreNet.Mat)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Write(System.String,ST4IVisionCoreNet.SparseMat)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Write(System.String,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint})">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Write(System.String,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.DMatch})">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.WriteScalar(System.Int32)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.WriteScalar(System.Single)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.WriteScalar(System.Double)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.WriteScalar(System.String)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(System.String)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(System.Int32)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(System.Single)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(System.Double)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Mat)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.SparseMat)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Range)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.KeyPoint)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.DMatch)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint})">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.DMatch})">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Point)">
            <summary>
            /Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Point2f)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Point2d)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Point3i)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Point3f)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Point3d)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Size)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Size2f)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Size2d)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Rect)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Rect2f)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Rect2d)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Scalar)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec2i)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec3i)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec4i)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec6i)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec2d)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec3d)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec4d)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec6d)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec2f)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec3f)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec4f)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec6f)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec2b)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec3b)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec4b)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec6b)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec2s)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec3s)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec4s)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec6s)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec2w)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec3w)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec4w)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FileStorage.Add(ST4IVisionCoreNet.Vec6w)">
            <summary>
            Writes data to a file storage.
            </summary>
            <param name="val"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.FileStorage.States">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.States.Undefined">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.States.ValueExpected">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.States.NameExpected">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.States.InsideMap">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FileStorage.Modes">
            <summary>
            File storage mode
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.Read">
            <summary>
            The storage is open for reading
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.Write">
            <summary>
            The storage is open for writing
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.Append">
            <summary>
            The storage is open for appending
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.Memory">
            <summary>
            flag, read data from source or write data to the internal buffer
            (which is returned by FileStorage::release)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.FormatAuto">
            <summary>
            flag, auto format
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.FormatXml">
            <summary>
            flag, XML format
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.FormatYaml">
            <summary>
            flag, YAML format
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.Base64">
            <summary>
            flag, write rawdata in Base64 by default. (consider using WRITE_BASE64)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FileStorage.Modes.WriteBase64">
            <summary>
            flag, enable both WRITE and BASE64
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.InputArray">
            <summary>
            Proxy data type for passing Mat's and vector&lt;&gt;'s as input parameters
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(ST4IVisionCoreNet.Mat)">
            <summary>
            Constructor
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(ST4IVisionCoreNet.UMat)">
            <summary>
            Constructor
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(ST4IVisionCoreNet.MatExpr)">
            <summary>
            Constructor
            </summary>
            <param name="expr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(ST4IVisionCoreNet.Scalar)">
            <summary>
            Constructor
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="vec"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.Int16[])">
            <summary>
            Constructor
            </summary>
            <param name="vec"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.UInt16[])">
            <summary>
            Constructor
            </summary>
            <param name="vec"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.Int32[])">
            <summary>
            Constructor
            </summary>
            <param name="vec"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.Single[])">
            <summary>
            Constructor
            </summary>
            <param name="vec"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.Double[])">
            <summary>
            Constructor
            </summary>
            <param name="vec"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create(ST4IVisionCoreNet.Mat)">
            <summary>
            Creates a proxy class of the specified Mat
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create(ST4IVisionCoreNet.UMat)">
            <summary>
            Creates a proxy class of the specified Mat
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create(ST4IVisionCoreNet.MatExpr)">
            <summary>
            Creates a proxy class of the specified MatExpr
            </summary>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create(ST4IVisionCoreNet.Scalar)">
            <summary>
            Creates a proxy class of the specified Scalar
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create(System.Double)">
            <summary>
            Creates a proxy class of the specified double
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            Creates a proxy class of the specified array of Mat 
            </summary>
            <param name="matVector"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="enumerable">Array object</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create``1(System.Collections.Generic.IEnumerable{``0},ST4IVisionCoreNet.MatType)">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="enumerable">Array object</param>
            <param name="type">Matrix depth and channels for converting array to cv::Mat</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create``1(``0[])">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="array">Array object</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create``1(``0[],ST4IVisionCoreNet.MatType)">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="array">Array object</param>
            <param name="type">Matrix depth and channels for converting array to cv::Mat</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create``1(``0[0:,0:])">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="array">Array object</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create``1(``0[0:,0:],ST4IVisionCoreNet.MatType)">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="array">Array object</param>
            <param name="type">Matrix depth and channels for converting array to cv::Mat</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Create(ST4IVisionCoreNet.IVec)">
            <summary>
            Creates a proxy class of the specified Vec*b
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.EstimateType(System.Type)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.GetMat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.GetMatVector">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.GetUMat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.GetFlags">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.GetObj">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.GetSz">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Kind">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Dims(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Cols(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Rows(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Size(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.SizeND(System.Int32[],System.Int32)">
            <summary>
            
            </summary>
            <param name="sz"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.SameSize(ST4IVisionCoreNet.InputArray)">
            <summary>
            
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Total(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Type(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Depth(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Channels(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsContinuous(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsSubmatrix(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Empty">
             <summary>
            
             
             </summary>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.CopyTo(ST4IVisionCoreNet.OutputArray)">
            <summary>
            
            </summary>
            <param name="arr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.CopyTo(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            
            </summary>
            <param name="arr"></param>
            <param name="mask"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Offset(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.Step(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsUMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsMatVector">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsUMatVector">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsMatx">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsVector">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputArray.IsGpuMatVector">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.InputOutputArray">
            <summary>
            Proxy data type for passing Mat's and vector&lt;&gt;'s as input parameters.
            Synonym for OutputArray.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.InputOutputArray.#ctor(ST4IVisionCoreNet.Mat)">
            <summary>
            Constructor
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputOutputArray.#ctor(ST4IVisionCoreNet.UMat)">
            <summary>
            Constructor
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputOutputArray.Create(ST4IVisionCoreNet.Mat)">
            <summary>
            Creates a proxy class of the specified Mat
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputOutputArray.Create(ST4IVisionCoreNet.UMat)">
            <summary>
            Creates a proxy class of the specified UMat
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.InputOutputArray.op_Implicit(ST4IVisionCoreNet.Mat)~ST4IVisionCoreNet.InputOutputArray">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.InputOutputArray.op_Implicit(ST4IVisionCoreNet.UMat)~ST4IVisionCoreNet.InputOutputArray">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.LDA">
            <inheritdoc />
            <summary>
            Linear Discriminant Analysis
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.#ctor(System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="numComponents"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.#ctor(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Initializes and performs a Discriminant Analysis with Fisher's 
            Optimization Criterion on given data in src and corresponding labels 
            in labels.If 0 (or less) number of components are given, they are 
            automatically determined for given data in computation.
            </summary>
            <param name="src"></param>
            <param name="labels"></param>
            <param name="numComponents"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Eigenvectors">
            <summary>
            Returns the eigenvectors of this LDA.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Eigenvalues">
            <summary>
            Returns the eigenvalues of this LDA.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Save(System.String)">
            <summary>
            Serializes this object to a given filename.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Load(System.String)">
            <summary>
            Deserializes this object from a given filename.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Save(ST4IVisionCoreNet.FileStorage)">
            <summary>
            Serializes this object to a given cv::FileStorage.
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Load(ST4IVisionCoreNet.FileStorage)">
            <summary>
            Deserializes this object from a given cv::FileStorage.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Compute the discriminants for data in src (row aligned) and labels.
            </summary>
            <param name="src"></param>
            <param name="labels"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Project(ST4IVisionCoreNet.InputArray)">
            <summary>
            Projects samples into the LDA subspace.
            src may be one or more row aligned samples.
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.Reconstruct(ST4IVisionCoreNet.InputArray)">
            <summary>
            Reconstructs projections from the LDA subspace.
            src may be one or more row aligned projections.
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.SubspaceProject(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            
            </summary>
            <param name="w"></param>
            <param name="mean"></param>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LDA.SubspaceReconstruct(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            
            </summary>
            <param name="w"></param>
            <param name="mean"></param>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.MatExpr">
            <summary>
            Matrix expression
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.#ctor(ST4IVisionCoreNet.Mat)">
            <summary>
            Constructor
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.op_Implicit(ST4IVisionCoreNet.MatExpr)~ST4IVisionCoreNet.Mat">
            <summary>
            Convert to cv::Mat
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.ToMat">
            <summary>
            Convert to cv::Mat
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.op_Implicit(ST4IVisionCoreNet.Mat)~ST4IVisionCoreNet.MatExpr">
            <summary>
            Convert cv::Mat to cv::MatExpr
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.FromMat(ST4IVisionCoreNet.Mat)">
            <summary>
            Convert cv::Mat to cv::MatExpr
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.MatExpr.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.MatExpr.Item(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.MatExpr.Item(ST4IVisionCoreNet.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Row(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row.
            </summary>
            <param name="y">A 0-based row index.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Col(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Diag(ST4IVisionCoreNet.MatDiagType)">
            <summary>
            Extracts a diagonal from a matrix
            </summary>
            <param name="d">d index of the diagonal, with the following values:
            - d=0 is the main diagonal.
            - d&lt;0 is a diagonal from the lower half. For example, d=-1 means the diagonal is set immediately below the main one.
            - d&gt;0 is a diagonal from the upper half. For example, d=1 means the diagonal is set immediately above the main one.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.SubMat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.SubMat(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.SubMat(ST4IVisionCoreNet.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.T">
            <summary>
            Transposes a matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Inv(ST4IVisionCoreNet.DecompTypes)">
            <summary>
            Inverses a matrix.
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Mul(ST4IVisionCoreNet.MatExpr,System.Double)">
            <summary>
            Performs an element-wise multiplication or division of the two matrices.
            </summary>
            <param name="e">Another array of the same type and the same size as this, or a matrix expression.</param>
            <param name="scale">Optional scale factor.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Mul(ST4IVisionCoreNet.Mat,System.Double)">
            <summary>
            Performs an element-wise multiplication or division of the two matrices.
            </summary>
            <param name="m">Another array of the same type and the same size as this, or a matrix expression.</param>
            <param name="scale">Optional scale factor.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Cross(ST4IVisionCoreNet.Mat)">
            <summary>
            Computes a cross-product of two 3-element vectors.
            </summary>
            <param name="m">Another cross-product operand.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Dot(ST4IVisionCoreNet.Mat)">
            <summary>
            Computes a dot-product of two vectors.
            </summary>
            <param name="m">another dot-product operand.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Size">
            <summary>
            Returns the size of a matrix element.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Type">
            <summary>
            Returns the type of a matrix element.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExpr.Abs">
            <summary>
            Computes absolute value of each matrix element
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.MatExprRowColIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MatExprRowColIndexer.Parent">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExprRowColIndexer.#ctor(ST4IVisionCoreNet.MatExpr)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:ST4IVisionCoreNet.MatExprRowColIndexer.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatExprRowColIndexer.Get(System.Int32)">
            <summary>
            
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Mat">
            <summary>
            OpenCV C++ n-dimensional dense array class (cv::Mat)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Mat.TypeMap">
            <summary>
            typeof(T) -> MatType
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(ST4IVisionCoreNet.Mat)">
            <inheritdoc />
            <summary>
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.String,ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Loads an image from a file. (cv::imread)
            </summary>
            <param name="fileName">Name of file to be loaded.</param>
            <param name="flags">Specifies color type of the loaded image</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType.CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.Int32,System.Int32,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Scalar)">
            <summary>
            constructs 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Scalar)">
            <summary>
            constructs 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Range,System.Nullable{ST4IVisionCoreNet.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.Int32,System.Int32,ST4IVisionCoreNet.MatType,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically de-allocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.Int32,System.Int32,ST4IVisionCoreNet.MatType,System.Array,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically de-allocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.MatType,System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically de-allocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.MatType,System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically de-allocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.MatType)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Scalar)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Release">
            <summary>
            Releases the resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.DisposeUnmanaged">
            <inheritdoc />
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FromStream(System.IO.Stream,ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Creates the Mat instance from System.IO.Stream
            </summary>
            <param name="stream"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ImDecode(System.Byte[],ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Creates the Mat instance from image data (using cv::decode) 
            </summary>
            <param name="imageBytes"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ImDecode(System.ReadOnlySpan{System.Byte},ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="span">The input slice of bytes.</param>
            <param name="mode">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FromImageData(System.Byte[],ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Creates the Mat instance from image data (using cv::decode) 
            </summary>
            <param name="imageBytes"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FromImageData(System.ReadOnlySpan{System.Byte},ST4IVisionCoreNet.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="span">The input slice of bytes.</param>
            <param name="mode">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Diag(ST4IVisionCoreNet.Mat)">
            <summary>
            Extracts a diagonal from a matrix, or creates a diagonal matrix.
            </summary>
            <param name="d">One-dimensional matrix that represents the main diagonal.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Zeros(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Zeros(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Zeros(ST4IVisionCoreNet.MatType,System.Int32[])">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="type">Created matrix type.</param>
            <param name="sizes"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ones(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ones(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ones(ST4IVisionCoreNet.MatType,System.Int32[])">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="type">Created matrix type.</param>
            <param name="sizes">Array of integers specifying the array shape.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Eye(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns an identity matrix of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Eye(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns an identity matrix of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FromArray``1(``0[])">
            <summary>
            Initializes as N x 1 matrix and copies array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FromArray``1(``0[0:,0:])">
            <summary>
            Initializes as M x N matrix and copies array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FromArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Initializes as N x 1 matrix and copies array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.LessThan(ST4IVisionCoreNet.Mat)">
            <summary>
            operator &lt;
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.LessThan(System.Double)">
            <summary>
            operator &lt;
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.LessThanOrEqual(ST4IVisionCoreNet.Mat)">
            <summary>
            operator &lt;=
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.LessThanOrEqual(System.Double)">
            <summary>
            operator &lt;=
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Equals(ST4IVisionCoreNet.Mat)">
            <summary>
            operator ==
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Equals(System.Double)">
            <summary>
            operator ==
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.NotEquals(ST4IVisionCoreNet.Mat)">
            <summary>
            operator !=
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.NotEquals(System.Double)">
            <summary>
            operator !=
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GreaterThan(ST4IVisionCoreNet.Mat)">
            <summary>
            operator &gt;
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GreaterThan(System.Double)">
            <summary>
            operator &gt;
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GreaterThanOrEqual(ST4IVisionCoreNet.Mat)">
            <summary>
            operator &gt;=
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GreaterThanOrEqual(System.Double)">
            <summary>
            operator &gt;=
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Item(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included. 
            To select all the rows, use Range.All().</param>
            <param name="colRange">Start and end column of the extracted submatrix. 
            The upper boundary is not included. To select all the columns, use Range.All().</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Item(ST4IVisionCoreNet.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Item(ST4IVisionCoreNet.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GetUMat(ST4IVisionCoreNet.AccessFlag,ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            Retrieve UMat from Mat
            </summary>
            <param name="accessFlags"></param>
            <param name="usageFlags"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Col(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ColRange(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="startCol">An inclusive 0-based start index of the column span.</param>
            <param name="endCol"> An exclusive 0-based ending index of the column span.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ColRange(ST4IVisionCoreNet.Range)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Row(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row.
            </summary>
            <param name="y">A 0-based row index.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.RowRange(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified row span.
            </summary>
            <param name="startRow"></param>
            <param name="endRow"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.RowRange(ST4IVisionCoreNet.Range)">
            <summary>
             Creates a matrix header for the specified row span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Diag(ST4IVisionCoreNet.MatDiagType)">
            <summary>
            Single-column matrix that forms a diagonal matrix or index of the diagonal, with the following values:
            </summary>
            <param name="d">Single-column matrix that forms a diagonal matrix or index of the diagonal, with the following values:</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Clone">
            <summary>
            Creates a full copy of the matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Clone(ST4IVisionCoreNet.Rect)">
            <summary>
            Returns the partial Mat of the specified Mat
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CopyTo(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Copies the matrix to another one.
            </summary>
            <param name="m">Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CopyTo(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.InputArray)">
            <summary>
            Copies the matrix to another one.
            </summary>
            <param name="m">Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConvertTo(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">desired output matrix type or, rather, the depth since the number of channels are the same as the input has; 
            if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">optional scale factor.</param>
            <param name="beta">optional delta added to the scaled values.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.AssignTo(ST4IVisionCoreNet.Mat,System.Nullable{ST4IVisionCoreNet.MatType})">
            <summary>
            Provides a functional form of convertTo.
            </summary>
            <param name="m">Destination array.</param>
            <param name="type">Desired destination array depth (or -1 if it should be the same as the source type).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SetTo(ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Mat)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SetTo(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Mat)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Reshape(System.Int32,System.Int32[])">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="newDims">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.T">
            <summary>
            Transposes a matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Inv(ST4IVisionCoreNet.DecompTypes)">
            <summary>
            Inverses a matrix.
            </summary>
            <param name="method">Matrix inversion method</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Mul(ST4IVisionCoreNet.InputArray,System.Double)">
            <summary>
            Performs an element-wise multiplication or division of the two matrices.
            </summary>
            <param name="m"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Cross(ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes a cross-product of two 3-element vectors.
            </summary>
            <param name="m">Another cross-product operand.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Dot(ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes a dot-product of two vectors.
            </summary>
            <param name="m">another dot-product operand.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Create(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Create(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="size">Alternative new matrix size specification: Size(cols, rows)</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Create(ST4IVisionCoreNet.MatType,System.Int32[])">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="sizes">Array of integers specifying a new array shape.</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Reserve(System.Int32)">
             <summary>
             Reserves space for the certain number of rows.
            
             The method reserves space for sz rows. If the matrix already has enough space to store sz rows,
             nothing happens. If the matrix is reallocated, the first Mat::rows rows are preserved. The method
             emulates the corresponding method of the STL vector class.
             </summary>
             <param name="sz">Number of rows.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ReserveBuffer(System.Int32)">
             <summary>
             Reserves space for the certain number of bytes.
            
             The method reserves space for sz bytes. If the matrix already has enough space to store sz bytes,
             nothing happens. If matrix has to be reallocated its previous content could be lost.
             </summary>
             <param name="sz">Number of bytes.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Resize(System.Int32)">
            <summary>
            Changes the number of matrix rows.
            </summary>
            <param name="sz">New number of rows.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Resize(System.Int32,ST4IVisionCoreNet.Scalar)">
            <summary>
            Changes the number of matrix rows.
            </summary>
            <param name="sz">New number of rows.</param>
            <param name="s">Value assigned to the newly added elements.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PopBack(System.Int32)">
            <summary>
            removes several hyper-planes from bottom of the matrix (Mat.pop_back)
            </summary>
            <param name="nElems"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(System.Byte)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(System.SByte)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(System.UInt16)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(System.Int16)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(System.Int32)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(System.Single)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(System.Double)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec2b)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec3b)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec4b)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec6b)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec2w)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec3w)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec4w)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec6w)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec2s)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec3s)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec4s)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec6s)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec2i)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec3i)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec4i)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec6i)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec2f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec3f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec4f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec6f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec2d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec3d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec4d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Vec6d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Point)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Point2d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Point2f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Point3i)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Point3d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Point3f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Size)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Size2d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Size2f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Rect)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Rect2d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Rect2f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PushBack(ST4IVisionCoreNet.Mat)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat.push_back)
            </summary>
            <param name="m">Added line(s)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.LocateROI(ST4IVisionCoreNet.Size@,ST4IVisionCoreNet.Point@)">
            <summary>
            Locates the matrix header within a parent matrix.
            </summary>
            <param name="wholeSize">Output parameter that contains the size of the whole matrix containing *this as a part.</param>
            <param name="ofs">Output parameter that contains an offset of *this inside the whole matrix.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.AdjustROI(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adjusts a submatrix size and position within the parent matrix.
            </summary>
            <param name="dtop">Shift of the top submatrix boundary upwards.</param>
            <param name="dbottom">Shift of the bottom submatrix boundary downwards.</param>
            <param name="dleft">Shift of the left submatrix boundary to the left.</param>
            <param name="dright">Shift of the right submatrix boundary to the right.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SubMat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SubMat(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included.
            To select all the rows, use Range::all().</param>
            <param name="colRange">Start and end column of the extracted submatrix. The upper boundary is not included.
            To select all the columns, use Range::all().</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SubMat(ST4IVisionCoreNet.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SubMat(ST4IVisionCoreNet.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.IsContinuous">
            <summary>
            Reports whether the matrix is continuous or not.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.IsSubmatrix">
            <summary>
            Returns whether this matrix is a part of other matrix or not.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ElemSize">
            <summary>
            Returns the matrix element size in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ElemSize1">
            <summary>
            Returns the size of each matrix element channel in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Type">
            <summary>
            Returns the type of a matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Depth">
            <summary>
            Returns the depth of a matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Channels">
            <summary>
            Returns the number of matrix channels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Step1(System.Int32)">
            <summary>
            Returns a normalized step.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Empty">
            <summary>
            Returns true if the array has no elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Total">
            <summary>
            Returns the total number of array elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Total(System.Int32,System.Int32)">
            <summary>
            Returns the total number of array elements.
            The method returns the number of elements within a certain sub-array slice with startDim &lt;= dim &lt; endDim
            </summary>
            <param name="startDim"></param>
            <param name="endDim"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CheckVector(System.Int32,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="elemChannels">Number of channels or number of columns the matrix should have.
            For a 2-D matrix, when the matrix has only 1 column, then it should have
            elemChannels channels; When the matrix has only 1 channel,
            then it should have elemChannels columns. For a 3-D matrix, it should have only one channel.
            Furthermore, if the number of planes is not one, then the number of rows within every
            plane has to be 1; if the number of rows within every plane is not 1,
            then the number of planes has to be 1.</param>
            <param name="depth">The depth the matrix should have. Set it to -1 when any depth is fine.</param>
            <param name="requireContinuous">Set it to true to require the matrix to be continuous</param>
            <returns>-1 if the requirement is not satisfied.
            Otherwise, it returns the number of elements in the matrix. Note that an element may have multiple channels.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ptr(System.Int32)">
            <summary>
            Returns a pointer to the specified matrix row.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ptr(System.Int32,System.Int32)">
            <summary>
            Returns a pointer to the specified matrix element.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ptr(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a pointer to the specified matrix element.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ptr(System.Int32[])">
            <summary>
            Returns a pointer to the specified matrix element.
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Flags">
            <summary>
            includes several bit-fields:
            - the magic signature
            - continuity flag
            - depth
            - number of channels
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Dims">
            <summary>
            the array dimensionality, >= 2
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Rows">
            <summary>
            the number of rows or -1 when the array has more than 2 dimensions
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Height">
            <summary>
            the number of rows or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Cols">
            <summary>
            the number of columns or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Width">
            <summary>
            the number of columns or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Data">
            <summary>
            pointer to the data
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.DataPointer">
            <summary>
            unsafe pointer to the data
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.DataStart">
            <summary>
            The pointer that is possible to compute a relative sub-array position in the main container array using locateROI()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.DataEnd">
            <summary>
            The pointer that is possible to compute a relative sub-array position in the main container array using locateROI()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.DataLimit">
            <summary>
            The pointer that is possible to compute a relative sub-array position in the main container array using locateROI()
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Size">
            <summary>
            Returns a matrix size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Size(System.Int32)">
            <summary>
            Returns a matrix size.
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Step">
            <summary>
            Returns number of bytes each matrix row occupies.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Step(System.Int32)">
            <summary>
            Returns number of bytes each matrix row occupies.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ToString">
            <summary>
            Returns a string that represents this Mat.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Dump(ST4IVisionCoreNet.FormatType)">
            <summary>
            Returns a string that represents each element value of Mat.
            This method corresponds to std::ostream &lt;&lt; Mat
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.EmptyClone">
            <summary>
            Makes a Mat that have the same size, depth and channels as this image
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GetGenericIndexer``1">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GetUnsafeGenericIndexer``1">
            <summary>
            Gets a type-specific unsafe indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Mat.Indexer`1">
            <summary>
            Mat Indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Indexer`1.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Indexer`1.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Indexer`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.Indexer`1.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Mat.UnsafeIndexer`1">
            <summary>
            Mat Indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.UnsafeIndexer`1.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.UnsafeIndexer`1.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.UnsafeIndexer`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat.UnsafeIndexer`1.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Get``1(System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Get``1(System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Get``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Get``1(System.Int32[])">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.At``1(System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.At``1(System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.At``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.At``1(System.Int32[])">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Set``1(System.Int32,``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Set``1(System.Int32,System.Int32,``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Set``1(System.Int32,System.Int32,System.Int32,``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Set``1(System.Int32[],``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GetArray``1(``0[]@)">
             <summary>
             Get the data of this matrix as array
             </summary>
             <param name="data">Primitive or Vec array to be copied</param>
             <returns>Length of copied bytes</returns>
             <example>
             using var m1 = new Mat(1, 1, MatType.CV_8UC1);
             m1.GetArray(out byte[] array);
            
             using var m2 = new Mat(1, 1, MatType.CV_32SC1);
             m2.GetArray(out int[] array);
            
             using var m3 = new Mat(1, 1, MatType.CV_8UC(6));
             m3.GetArray(out Vec6b[] array);
            
             using var m4 = new Mat(1, 1, MatType.CV_64FC4);
             m4.GetArray(out Vec4d[] array);
             </example>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GetRectangularArray``1(``0[0:,0:]@)">
             <summary>
             Get the data of this matrix as array
             </summary>
             <param name="data">Primitive or Vec array to be copied</param>
             <returns>Length of copied bytes</returns>
             <example>
             using var m1 = new Mat(1, 1, MatType.CV_8UC1);
             m1.GetRectangularArray(out byte[,] array);
            
             using var m2 = new Mat(1, 1, MatType.CV_32SC1);
             m2.GetRectangularArray(out int[,] array);
            
             using var m3 = new Mat(1, 1, MatType.CV_8UC(6));
             m3.GetRectangularArray(out Vec6b[,] array);
            
             using var m4 = new Mat(1, 1, MatType.CV_64FC4);
             m4.GetRectangularArray(out Vec4d[,] array);
             </example>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SetArray``1(``0[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="data">Primitive or Vec array to be copied</param>
            <returns>Length of copied bytes</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SetRectangularArray``1(``0[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="data">Primitive or Vec array to be copied</param>
            <returns>Length of copied bytes</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ToBytes(System.String,System.Int32[])">
            <summary>
            Encodes an image into a memory buffer.
            </summary>
            <param name="ext">Encodes an image into a memory buffer.</param>
            <param name="prms">Format-specific parameters.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ToBytes(System.String,ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Encodes an image into a memory buffer.
            </summary>
            <param name="ext">Encodes an image into a memory buffer.</param>
            <param name="prms">Format-specific parameters.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ToMemoryStream(System.String,ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Converts Mat to System.IO.MemoryStream
            </summary>
            <param name="ext"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.WriteToStream(System.IO.Stream,System.String,ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Writes image data encoded from this Mat to System.IO.Stream
            </summary>
            <param name="stream"></param>
            <param name="ext"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Alignment(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Cast``1">
            <summary>
            Creates type-specific Mat instance from this.
            </summary>
            <typeparam name="TMat"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsByte(ST4IVisionCoreNet.MatForeachFunctionByte)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec2b(ST4IVisionCoreNet.MatForeachFunctionVec2b)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec3b(ST4IVisionCoreNet.MatForeachFunctionVec3b)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec4b(ST4IVisionCoreNet.MatForeachFunctionVec4b)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec6b(ST4IVisionCoreNet.MatForeachFunctionVec6b)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsInt16(ST4IVisionCoreNet.MatForeachFunctionInt16)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec2s(ST4IVisionCoreNet.MatForeachFunctionVec2s)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec3s(ST4IVisionCoreNet.MatForeachFunctionVec3s)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec4s(ST4IVisionCoreNet.MatForeachFunctionVec4s)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec6s(ST4IVisionCoreNet.MatForeachFunctionVec6s)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsInt32(ST4IVisionCoreNet.MatForeachFunctionInt32)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec2i(ST4IVisionCoreNet.MatForeachFunctionVec2i)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec3i(ST4IVisionCoreNet.MatForeachFunctionVec3i)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec4i(ST4IVisionCoreNet.MatForeachFunctionVec4i)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec6i(ST4IVisionCoreNet.MatForeachFunctionVec6i)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsFloat(ST4IVisionCoreNet.MatForeachFunctionFloat)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec2f(ST4IVisionCoreNet.MatForeachFunctionVec2f)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec3f(ST4IVisionCoreNet.MatForeachFunctionVec3f)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec4f(ST4IVisionCoreNet.MatForeachFunctionVec4f)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec6f(ST4IVisionCoreNet.MatForeachFunctionVec6f)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsDouble(ST4IVisionCoreNet.MatForeachFunctionDouble)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec2d(ST4IVisionCoreNet.MatForeachFunctionVec2d)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec3d(ST4IVisionCoreNet.MatForeachFunctionVec3d)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec4d(ST4IVisionCoreNet.MatForeachFunctionVec4d)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ForEachAsVec6d(ST4IVisionCoreNet.MatForeachFunctionVec6d)">
            <summary>
            Runs the given functor over all matrix elements in parallel.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.AsSpan``1">
            <summary>
            Creates a new span over the Mat.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Abs">
            <summary>
            Computes absolute value of each matrix element
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConvertScaleAbs(System.Double,System.Double)">
            <summary>
            Scales, computes absolute values and converts the result to 8-bit.
            </summary>
            <param name="alpha">The optional scale factor. [By default this is 1]</param>
            <param name="beta">The optional delta added to the scaled values. [By default this is 0]</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.LUT(ST4IVisionCoreNet.InputArray)">
            <summary>
            transforms array of numbers using a lookup table: dst(i)=lut(src(i))
            </summary>
            <param name="lut">Look-up table of 256 elements. 
            In the case of multi-channel source array, the table should either have 
            a single channel (in this case the same table is used for all channels)
             or the same number of channels as in the source array</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.LUT(System.Byte[])">
            <summary>
            transforms array of numbers using a lookup table: dst(i)=lut(src(i))
            </summary>
            <param name="lut">Look-up table of 256 elements. 
            In the case of multi-channel source array, the table should either have 
            a single channel (in this case the same table is used for all channels)
             or the same number of channels as in the source array</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Sum">
            <summary>
            computes sum of array elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CountNonZero">
            <summary>
            computes the number of nonzero array elements
            </summary>
            <returns>number of non-zero elements in mtx</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FindNonZero">
            <summary>
            returns the list of locations of non-zero pixels
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Mean(ST4IVisionCoreNet.InputArray)">
            <summary>
            computes mean value of selected array elements
            </summary>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MeanStdDev(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes mean value and standard deviation of all or selected array elements
            </summary>
            <param name="mean">The output parameter: computed mean value</param>
            <param name="stddev">The output parameter: computed standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Norm(ST4IVisionCoreNet.NormTypes,ST4IVisionCoreNet.InputArray)">
            <summary>
            computes norm of the selected array part
            </summary>
            <param name="normType">Type of the norm</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Normalize(System.Double,System.Double,ST4IVisionCoreNet.NormTypes,System.Int32,ST4IVisionCoreNet.InputArray)">
            <summary>
            scales and shifts array elements so that either the specified norm (alpha) 
            or the minimum (alpha) and maximum (beta) array values get the specified values
            </summary>
            <param name="alpha">The norm value to normalize to or the lower range boundary 
            in the case of range normalization</param>
            <param name="beta">The upper range boundary in the case of range normalization; 
            not used for norm normalization</param>
            <param name="normType">The normalization type</param>
            <param name="dtype">When the parameter is negative, 
            the destination array will have the same type as src, 
            otherwise it will have the same number of channels as src and the depth =CV_MAT_DEPTH(rtype)</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MinMaxLoc(System.Double@,System.Double@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MinMaxLoc(ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.Point@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MinMaxLoc(System.Double@,System.Double@,ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.InputArray)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask used to select a sub-array</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MinMaxIdx(System.Double@,System.Double@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MinMaxIdx(System.Int32[],System.Int32[])">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minIdx"></param>
            <param name="maxIdx"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MinMaxIdx(System.Double@,System.Double@,System.Int32[],System.Int32[],ST4IVisionCoreNet.InputArray)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minIdx"></param>
            <param name="maxIdx"></param>
            <param name="mask"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Reduce(ST4IVisionCoreNet.ReduceDimension,ST4IVisionCoreNet.ReduceTypes,System.Int32)">
            <summary>
            transforms 2D matrix to 1D row or column vector by taking sum, minimum, maximum or mean value over all the rows
            </summary>
            <param name="dim">The dimension index along which the matrix is reduced. 
            0 means that the matrix is reduced to a single row and 1 means that the matrix is reduced to a single column</param>
            <param name="rtype"></param>
            <param name="dtype">When it is negative, the destination vector will have 
            the same type as the source matrix, otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), mtx.channels())</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Split">
            <summary>
            Copies each plane of a multi-channel array to a dedicated array
            </summary>
            <returns>The number of arrays must match mtx.channels() . 
            The arrays themselves will be reallocated if needed</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ExtractChannel(System.Int32)">
            <summary>
            extracts a single channel from src (coi is 0-based index)
            </summary>
            <param name="coi"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.InsertChannel(ST4IVisionCoreNet.InputOutputArray,System.Int32)">
            <summary>
            inserts a single channel to dst (coi is 0-based index)
            </summary>
            <param name="dst"></param>
            <param name="coi"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Flip(ST4IVisionCoreNet.FlipMode)">
            <summary>
            reverses the order of the rows, columns or both in a matrix
            </summary>
            <param name="flipCode">Specifies how to flip the array: 
            0 means flipping around the x-axis, positive (e.g., 1) means flipping around y-axis, 
            and negative (e.g., -1) means flipping around both axes. See also the discussion below for the formulas.</param>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Repeat(System.Int32,System.Int32)">
            <summary>
            replicates the input matrix the specified number of times in the horizontal and/or vertical direction
            </summary>
            <param name="ny">How many times the src is repeated along the vertical axis</param>
            <param name="nx">How many times the src is repeated along the horizontal axis</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.InRange(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Checks if array elements lie between the elements of two other arrays.
            </summary>
            <param name="lowerb">inclusive lower boundary array or a scalar.</param>
            <param name="upperb">inclusive upper boundary array or a scalar.</param>
            <returns>The destination array, will have the same size as src and CV_8U type</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.InRange(ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Scalar)">
            <summary>
            Checks if array elements lie between the elements of two other arrays.
            </summary>
            <param name="lowerb">inclusive lower boundary array or a scalar.</param>
            <param name="upperb">inclusive upper boundary array or a scalar.</param>
            <returns>The destination array, will have the same size as src and CV_8U type</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Sqrt">
            <summary>
            computes square root of each matrix element (dst = src**0.5)
            </summary>
            <returns>The destination array; will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Pow(System.Double)">
            <summary>
            raises the input matrix elements to the specified power (b = a**power)
            </summary>
            <param name="power">The exponent of power</param>
            <returns>The destination array; will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Exp">
            <summary>
            computes exponent of each matrix element (dst = e**src)
            </summary>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Log">
            <summary>
            computes natural logarithm of absolute value of each matrix element: dst = log(abs(src))
            </summary>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CheckRange(System.Boolean)">
            <summary>
            checks that each matrix element is within the specified range.
            </summary>
            <param name="quiet">The flag indicating whether the functions quietly 
            return false when the array elements are out of range, 
            or they throw an exception.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CheckRange(System.Boolean,ST4IVisionCoreNet.Point@,System.Double,System.Double)">
            <summary>
            checks that each matrix element is within the specified range.
            </summary>
            <param name="quiet">The flag indicating whether the functions quietly 
            return false when the array elements are out of range, 
            or they throw an exception.</param>
            <param name="pos">The optional output parameter, where the position of 
            the first outlier is stored.</param>
            <param name="minVal">The inclusive lower boundary of valid values range</param>
            <param name="maxVal">The exclusive upper boundary of valid values range</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PatchNaNs(System.Double)">
            <summary>
            converts NaN's to the given number
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MulTransposed(System.Boolean,ST4IVisionCoreNet.InputArray,System.Double,System.Int32)">
            <summary>
            multiplies matrix by its transposition from the left or from the right
            </summary>
            <param name="aTa">Specifies the multiplication ordering; see the description below</param>
            <param name="delta">The optional delta matrix, subtracted from src before the 
            multiplication. When the matrix is empty ( delta=Mat() ), it’s assumed to be 
            zero, i.e. nothing is subtracted, otherwise if it has the same size as src, 
            then it’s simply subtracted, otherwise it is "repeated" to cover the full src 
            and then subtracted. Type of the delta matrix, when it's not empty, must be the 
            same as the type of created destination matrix, see the rtype description</param>
            <param name="scale">The optional scale factor for the matrix product</param>
            <param name="dtype">When it’s negative, the destination matrix will have the 
            same type as src . Otherwise, it will have type=CV_MAT_DEPTH(rtype), 
            which should be either CV_32F or CV_64F</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Transpose">
            <summary>
            transposes the matrix
            </summary>
            <returns>The destination array of the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Transform(ST4IVisionCoreNet.InputArray)">
            <summary>
            performs affine transformation of each element of multi-channel input matrix
            </summary>
            <param name="m">The transformation matrix</param>
            <returns>The destination array; will have the same size and depth as src and as many channels as mtx.rows</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PerspectiveTransform(ST4IVisionCoreNet.InputArray)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CompleteSymm(System.Boolean)">
            <summary>
            extends the symmetrical matrix from the lower half or from the upper half
            </summary>
            <param name="lowerToUpper">If true, the lower half is copied to the upper half, 
            otherwise the upper half is copied to the lower half</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SetIdentity(System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            initializes scaled identity matrix (not necessarily square). 
            </summary>
            <param name="s">The value to assign to the diagonal elements</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Determinant">
            <summary>
            computes determinant of a square matrix.
            The input matrix must have CV_32FC1 or CV_64FC1 type and square size.
            </summary>
            <returns>determinant of the specified matrix.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Trace">
            <summary>
            computes trace of a matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Sort(ST4IVisionCoreNet.SortFlags)">
            <summary>
            sorts independently each matrix row or each matrix column
            </summary>
            <param name="flags">The operation flags, a combination of the SortFlag values</param>
            <returns>The destination array of the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SortIdx(ST4IVisionCoreNet.SortFlags)">
            <summary>
            sorts independently each matrix row or each matrix column
            </summary>
            <param name="flags">The operation flags, a combination of SortFlag values</param>
            <returns>The destination integer array of the same size as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Dft(ST4IVisionCoreNet.DftFlags,System.Int32)">
            <summary>
            Performs a forward Discrete Fourier transform of 1D or 2D floating-point array.
            </summary>
            <param name="flags">Transformation flags, a combination of the DftFlag2 values</param>
            <param name="nonzeroRows">When the parameter != 0, the function assumes that 
            only the first nonzeroRows rows of the input array ( DFT_INVERSE is not set) 
            or only the first nonzeroRows of the output array ( DFT_INVERSE is set) contain non-zeros, 
            thus the function can handle the rest of the rows more efficiently and 
            thus save some time. This technique is very useful for computing array cross-correlation 
            or convolution using DFT</param>
            <returns>The destination array, which size and type depends on the flags</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Idft(ST4IVisionCoreNet.DftFlags,System.Int32)">
            <summary>
            Performs an inverse Discrete Fourier transform of 1D or 2D floating-point array.
            </summary>
            <param name="flags">Transformation flags, a combination of the DftFlag2 values</param>
            <param name="nonzeroRows">When the parameter != 0, the function assumes that 
            only the first nonzeroRows rows of the input array ( DFT_INVERSE is not set) 
            or only the first nonzeroRows of the output array ( DFT_INVERSE is set) contain non-zeros, 
            thus the function can handle the rest of the rows more efficiently and 
            thus save some time. This technique is very useful for computing array cross-correlation 
            or convolution using DFT</param>
            <returns>The destination array, which size and type depends on the flags</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Dct(ST4IVisionCoreNet.DctFlags)">
            <summary>
            performs forward or inverse 1D or 2D Discrete Cosine Transformation
            </summary>
            <param name="flags">Transformation flags, a combination of DctFlag2 values</param>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Idct(ST4IVisionCoreNet.DctFlags)">
            <summary>
            performs inverse 1D or 2D Discrete Cosine Transformation
            </summary>
            <param name="flags">Transformation flags, a combination of DctFlag2 values</param>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Randu(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            fills array with uniformly-distributed random numbers from the range [low, high)
            </summary>
            <param name="low">The inclusive lower boundary of the generated random numbers</param>
            <param name="high">The exclusive upper boundary of the generated random numbers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Randu(ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Scalar)">
            <summary>
            fills array with uniformly-distributed random numbers from the range [low, high)
            </summary>
            <param name="low">The inclusive lower boundary of the generated random numbers</param>
            <param name="high">The exclusive upper boundary of the generated random numbers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Randn(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            fills array with normally-distributed random numbers with the specified mean and the standard deviation
            </summary>
            <param name="mean">The mean value (expectation) of the generated random numbers</param>
            <param name="stddev">The standard deviation of the generated random numbers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Randn(ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Scalar)">
            <summary>
            fills array with normally-distributed random numbers with the specified mean and the standard deviation
            </summary>
            <param name="mean">The mean value (expectation) of the generated random numbers</param>
            <param name="stddev">The standard deviation of the generated random numbers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.RandShuffle(System.Double)">
            <summary>
            shuffles the input array elements
            </summary>
            <param name="iterFactor">The scale factor that determines the number of random swap operations.</param>
            <returns>The input/output numerical 1D array</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.RandShuffle(System.Double,ST4IVisionCoreNet.RNG@)">
            <summary>
            shuffles the input array elements
            </summary>
            <param name="iterFactor">The scale factor that determines the number of random swap operations.</param>
            <param name="rng">The optional random number generator used for shuffling. 
            If it is null, theRng() is used instead.</param>
            <returns>The input/output numerical 1D array</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Line(System.Int32,System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws a line segment connecting two points
            </summary>
            <param name="pt1X">First point's x-coordinate of the line segment. </param>
            <param name="pt1Y">First point's y-coordinate of the line segment. </param>
            <param name="pt2X">Second point's x-coordinate of the line segment. </param>
            <param name="pt2Y">Second point's y-coordinate of the line segment. </param>
            <param name="color">Line color. </param>
            <param name="thickness">Line thickness. [By default this is 1]</param>
            <param name="lineType">Type of the line. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Line(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws a line segment connecting two points
            </summary>
            <param name="pt1">First point of the line segment. </param>
            <param name="pt2">Second point of the line segment. </param>
            <param name="color">Line color. </param>
            <param name="thickness">Line thickness. [By default this is 1]</param>
            <param name="lineType">Type of the line. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Rectangle(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="pt1">One of the rectangle vertices. </param>
            <param name="pt2">Opposite rectangle vertex. </param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Rectangle(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="rect">Rectangle.</param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Circle(System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws a circle
            </summary>
            <param name="centerX">X-coordinate of the center of the circle. </param>
            <param name="centerY">Y-coordinate of the center of the circle. </param>
            <param name="radius">Radius of the circle. </param>
            <param name="color">Circle color. </param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn. [By default this is 1]</param>
            <param name="lineType">Type of the circle boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Circle(ST4IVisionCoreNet.Point,System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws a circle
            </summary>
            <param name="center">Center of the circle. </param>
            <param name="radius">Radius of the circle. </param>
            <param name="color">Circle color. </param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn. [By default this is 1]</param>
            <param name="lineType">Type of the circle boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ellipse(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Size,System.Double,System.Double,System.Double,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Draws simple or thick elliptic arc or fills ellipse sector
            </summary>
            <param name="center">Center of the ellipse. </param>
            <param name="axes">Length of the ellipse axes. </param>
            <param name="angle">Rotation angle. </param>
            <param name="startAngle">Starting angle of the elliptic arc. </param>
            <param name="endAngle">Ending angle of the elliptic arc. </param>
            <param name="color">Ellipse color. </param>
            <param name="thickness">Thickness of the ellipse arc. [By default this is 1]</param>
            <param name="lineType">Type of the ellipse boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values. [By default this is 0]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Ellipse(ST4IVisionCoreNet.RotatedRect,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes)">
            <summary>
            Draws simple or thick elliptic arc or fills ellipse sector
            </summary>
            <param name="box">The enclosing box of the ellipse drawn </param>
            <param name="color">Ellipse color. </param>
            <param name="thickness">Thickness of the ellipse boundary. [By default this is 1]</param>
            <param name="lineType">Type of the ellipse boundary. [By default this is LineType.Link8]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.DrawMarker(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.MarkerTypes,System.Int32,System.Int32,ST4IVisionCoreNet.LineTypes)">
             <summary>
             Draws a marker on a predefined position in an image.
            
             The function cv::drawMarker draws a marker on a given position in the image.For the moment several
             marker types are supported, see #MarkerTypes for more information.
             </summary>
             <param name="position">The point where the crosshair is positioned.</param>
             <param name="color">Line color.</param>
             <param name="markerType">The specific type of marker you want to use.</param>
             <param name="markerSize">The length of the marker axis [default = 20 pixels]</param>
             <param name="thickness">Line thickness.</param>
             <param name="lineType">Type of the line.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FillConvexPoly(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            Fills a convex polygon.
            </summary>
            <param name="pts">The polygon vertices</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FillPoly(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point}},ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.LineTypes,System.Int32,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Fills the area bounded by one or more polygons
            </summary>
            <param name="pts">Array of polygons, each represented as an array of points</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
            <param name="offset"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Polylines(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point}},System.Boolean,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Int32)">
            <summary>
            draws one or more polygonal curves
            </summary>
            <param name="pts"></param>
            <param name="isClosed"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="shift"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PutText(System.String,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.HersheyFonts,System.Double,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Boolean)">
            <summary>
            renders text string in the image
            </summary>
            <param name="text"></param>
            <param name="org"></param>
            <param name="fontFace"></param>
            <param name="fontScale"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="bottomLeftOrigin"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ImEncode(System.String,System.Int32[])">
            <summary>
            Encodes an image into a memory buffer.
            </summary>
            <param name="ext">Encodes an image into a memory buffer.</param>
            <param name="prms">Format-specific parameters.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ImEncode(System.String,ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Encodes an image into a memory buffer.
            </summary>
            <param name="ext">Encodes an image into a memory buffer.</param>
            <param name="prms">Format-specific parameters.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ImWrite(System.String,System.Int32[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ImWrite(System.String,ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SaveImage(System.String,System.Int32[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SaveImage(System.String,ST4IVisionCoreNet.ImageEncodingParam[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CopyMakeBorder(System.Int32,System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Forms a border around the image
            </summary>
            <param name="top">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="bottom">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="left">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="right">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="borderType">The border type</param>
            <param name="value">The border value if borderType == Constant</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MedianBlur(System.Int32)">
            <summary>
            Smoothes image using median filter.
            The source image must have 1-, 3- or 4-channel and 
            its depth should be CV_8U , CV_16U or CV_32F. 
            </summary>
            <param name="ksize">The aperture linear size. It must be odd and more than 1, i.e. 3, 5, 7 ...</param>
            <returns>The destination array; will have the same size and the same type as src.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GaussianBlur(ST4IVisionCoreNet.Size,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Blurs an image using a Gaussian filter.
            The input image can have any number of channels, which are processed independently, 
            but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
            </summary>
            <param name="ksize">Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. 
            Or, they can be zero’s and then they are computed from sigma* .</param>
            <param name="sigmaX">Gaussian kernel standard deviation in X direction.</param>
            <param name="sigmaY">Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, 
            if both sigmas are zeros, they are computed from ksize.width and ksize.height, 
            respectively (see getGaussianKernel() for details); to fully control the result 
            regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</param>
            <param name="borderType">pixel extrapolation method</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.BilateralFilter(System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Applies bilateral filter to the image
            The source image must be a 8-bit or floating-point, 1-channel or 3-channel image.
            </summary>
            <param name="d">The diameter of each pixel neighborhood, that is used during filtering. 
            If it is non-positive, it's computed from sigmaSpace</param>
            <param name="sigmaColor">Filter sigma in the color space. 
            Larger value of the parameter means that farther colors within the pixel neighborhood 
            will be mixed together, resulting in larger areas of semi-equal color</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. 
            Larger value of the parameter means that farther pixels will influence each other 
            (as long as their colors are close enough; see sigmaColor). Then d>0 , it specifies 
            the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace</param>
            <param name="borderType"></param>
            <returns>The destination image; will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.BoxFilter(ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Size,System.Nullable{ST4IVisionCoreNet.Point},System.Boolean,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Smoothes image using box filter
            </summary>
            <param name="ddepth"></param>
            <param name="ksize">The smoothing kernel size</param>
            <param name="anchor">The anchor point. The default value Point(-1,-1) means that the anchor is at the kernel center</param>
            <param name="normalize">Indicates, whether the kernel is normalized by its area or not</param>
            <param name="borderType">The border mode used to extrapolate pixels outside of the image</param>
            <returns>The destination image; will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Blur(ST4IVisionCoreNet.Size,System.Nullable{ST4IVisionCoreNet.Point},ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Smoothes image using normalized box filter
            </summary>
            <param name="ksize">The smoothing kernel size</param>
            <param name="anchor">The anchor point. The default value Point(-1,-1) means that the anchor is at the kernel center</param>
            <param name="borderType">The border mode used to extrapolate pixels outside of the image</param>
            <returns>The destination image; will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Filter2D(ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Convolves an image with the kernel
            </summary>
            <param name="ddepth">The desired depth of the destination image. If it is negative, it will be the same as src.depth()</param>
            <param name="kernel">Convolution kernel (or rather a correlation kernel), 
            a single-channel floating point matrix. If you want to apply different kernels to 
            different channels, split the image into separate color planes using split() and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of 
            a filtered point within the kernel. The anchor should lie within the kernel. 
            The special default value (-1,-1) means that the anchor is at the kernel center</param>
            <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>The destination image. It will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.SepFilter2D(ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Applies separable linear filter to an image
            </summary>
            <param name="ddepth">The destination image depth</param>
            <param name="kernelX">The coefficients for filtering each row</param>
            <param name="kernelY">The coefficients for filtering each column</param>
            <param name="anchor">The anchor position within the kernel; The default value (-1, 1) means that the anchor is at the kernel center</param>
            <param name="delta">The value added to the filtered results before storing them</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>The destination image; will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Sobel(ST4IVisionCoreNet.MatType,System.Int32,System.Int32,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Calculates the first, second, third or mixed image derivatives using an extended Sobel operator
            </summary>
            <param name="ddepth">The destination image depth</param>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="ksize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7</param>
            <param name="scale">The optional scale factor for the computed derivative values (by default, no scaling is applied</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>The destination image; will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Scharr(ST4IVisionCoreNet.MatType,System.Int32,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Calculates the first x- or y- image derivative using Scharr operator
            </summary>
            <param name="ddepth">The destination image depth</param>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="scale">The optional scale factor for the computed derivative values (by default, no scaling is applie</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>The destination image; will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Laplacian(ST4IVisionCoreNet.MatType,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Calculates the Laplacian of an image
            </summary>
            <param name="ddepth">The desired depth of the destination image</param>
            <param name="ksize">The aperture size used to compute the second-derivative filters</param>
            <param name="scale">The optional scale factor for the computed Laplacian values (by default, no scaling is applied</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>Destination image; will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Canny(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Finds edges in an image using Canny algorithm.
            </summary>
            <param name="threshold1">The first threshold for the hysteresis procedure</param>
            <param name="threshold2">The second threshold for the hysteresis procedure</param>
            <param name="apertureSize">Aperture size for the Sobel operator [By default this is ApertureSize.Size3]</param>
            <param name="L2gradient">Indicates, whether the more accurate L2 norm should be used to compute the image gradient magnitude (true), or a faster default L1 norm is enough (false). [By default this is false]</param>
            <returns>The output edge map. It will have the same size and the same type as image</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CornerEigenValsAndVecs(System.Int32,System.Int32,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            computes both eigenvalues and the eigenvectors of 2x2 derivative covariation matrix  at each pixel. The output is stored as 6-channel matrix.
            </summary>
            <param name="blockSize"></param>
            <param name="ksize"></param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PreCornerDetect(System.Int32,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            computes another complex cornerness criteria at each pixel
            </summary>
            <param name="ksize"></param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CornerSubPix(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.TermCriteria)">
            <summary>
            adjusts the corner locations with sub-pixel accuracy to maximize the certain cornerness criteria
            </summary>
            <param name="inputCorners">Initial coordinates of the input corners and refined coordinates provided for output.</param>
            <param name="winSize">Half of the side length of the search window.</param>
            <param name="zeroZone">Half of the size of the dead region in the middle of the search zone 
            over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities 
            of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such a size.</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. 
            That is, the process of corner position refinement stops either after criteria.maxCount iterations 
            or when the corner position moves by less than criteria.epsilon on some iteration.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GoodFeaturesToTrack(System.Int32,System.Double,System.Double,ST4IVisionCoreNet.InputArray,System.Int32,System.Boolean,System.Double)">
            <summary>
            Finds the strong enough corners where the cornerMinEigenVal() or cornerHarris() report the local maxima.
            Input matrix must be 8-bit or floating-point 32-bit, single-channel image.
            </summary>
            <param name="maxCorners">Maximum number of corners to return. If there are more corners than are found, 
            the strongest of them is returned.</param>
            <param name="qualityLevel">Parameter characterizing the minimal accepted quality of image corners. 
            The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue 
            or the Harris function response (see cornerHarris() ). The corners with the quality measure less than 
            the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01, 
            then all the corners with the quality measure less than 15 are rejected.</param>
            <param name="minDistance">Minimum possible Euclidean distance between the returned corners.</param>
            <param name="mask">Optional region of interest. If the image is not empty
             (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region 
            in which the corners are detected.</param>
            <param name="blockSize">Size of an average block for computing a derivative covariation matrix over each pixel neighborhood.</param>
            <param name="useHarrisDetector">Parameter indicating whether to use a Harris detector</param>
            <param name="k">Free parameter of the Harris detector.</param>
            <returns>Output vector of detected corners.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.HoughLines(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines in a binary image using standard Hough transform.
            The input matrix must be 8-bit, single-channel, binary source image. 
            This image may be modified by the function.
            </summary>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">The accumulator threshold parameter. Only those lines are returned that get enough votes ( &gt; threshold )</param>
            <param name="srn">For the multi-scale Hough transform it is the divisor for the distance resolution rho. [By default this is 0]</param>
            <param name="stn">For the multi-scale Hough transform it is the divisor for the distance resolution theta. [By default this is 0]</param>
            <returns>The output vector of lines. Each line is represented by a two-element vector (rho, theta) . 
            rho is the distance from the coordinate origin (0,0) (top-left corner of the image) and theta is the line rotation angle in radians</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.HoughLinesP(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines segments in a binary image using probabilistic Hough transform.
            </summary>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">The accumulator threshold parameter. Only those lines are returned that get enough votes ( &gt; threshold )</param>
            <param name="minLineLength">The minimum line length. Line segments shorter than that will be rejected. [By default this is 0]</param>
            <param name="maxLineGap">The maximum allowed gap between points on the same line to link them. [By default this is 0]</param>
            <returns>The output lines. Each line is represented by a 4-element vector (x1, y1, x2, y2)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.HoughCircles(ST4IVisionCoreNet.HoughModes,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in a grayscale image using a Hough transform.
            The input matrix must be 8-bit, single-channel and grayscale.
            </summary>
            <param name="method">The available methods are HoughMethods.Gradient and HoughMethods.GradientAlt</param>
            <param name="dp">The inverse ratio of the accumulator resolution to the image resolution. </param>
            <param name="minDist">Minimum distance between the centers of the detected circles. </param>
            <param name="param1">The first method-specific parameter. [By default this is 100]</param>
            <param name="param2">The second method-specific parameter. [By default this is 100]</param>
            <param name="minRadius">Minimum circle radius. [By default this is 0]</param>
            <param name="maxRadius">Maximum circle radius. [By default this is 0] </param>
            <returns>The output vector found circles. Each vector is encoded as 3-element floating-point vector (x, y, radius)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Dilate(ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Int32,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Dilates an image by using a specific structuring element.
            </summary>
            <param name="element">The structuring element used for dilation. If element=new Mat() , a 3x3 rectangular structuring element is used</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">The number of times dilation is applied. [By default this is 1]</param>
            <param name="borderType">The pixel extrapolation method. [By default this is BorderTypes.Constant]</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
            <returns>The destination image. It will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Erode(ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Int32,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Erodes an image by using a specific structuring element.
            </summary>
            <param name="element">The structuring element used for dilation. If element=new Mat(), a 3x3 rectangular structuring element is used</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">The number of times erosion is applied</param>
            <param name="borderType">The pixel extrapolation method</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
            <returns>The destination image. It will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MorphologyEx(ST4IVisionCoreNet.MorphTypes,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point},System.Int32,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Performs advanced morphological transformations
            </summary>
            <param name="op">Type of morphological operation</param>
            <param name="element">Structuring element</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">Number of times erosion and dilation are applied. [By default this is 1]</param>
            <param name="borderType">The pixel extrapolation method. [By default this is BorderTypes.Constant]</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
            <returns>Destination image. It will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Resize(ST4IVisionCoreNet.Size,System.Double,System.Double,ST4IVisionCoreNet.InterpolationFlags)">
            <summary>
            Resizes an image.
            </summary>
            <param name="dsize">output image size; if it equals zero, it is computed as: 
            dsize = Size(round(fx*src.cols), round(fy*src.rows))
            Either dsize or both fx and fy must be non-zero.</param>
            <param name="fx">scale factor along the horizontal axis; when it equals 0, 
            it is computed as: (double)dsize.width/src.cols</param>
            <param name="fy">scale factor along the vertical axis; when it equals 0, 
            it is computed as: (double)dsize.height/src.rows</param>
            <param name="interpolation">interpolation method</param>
            <returns>output image; it has the size dsize (when it is non-zero) or the size computed 
            from src.size(), fx, and fy; the type of dst is the same as of src.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.WarpAffine(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InterpolationFlags,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Applies an affine transformation to an image.
            </summary>
            <returns>output image that has the size dsize and the same type as src.</returns>
            <param name="m">2x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods and the optional flag 
            WARP_INVERSE_MAP that means that M is the inverse transformation (dst -> src) .</param>
            <param name="borderMode">pixel extrapolation method; when borderMode=BORDER_TRANSPARENT, 
            it means that the pixels in the destination image corresponding to the "outliers" 
            in the source image are not modified by the function.</param>
            <param name="borderValue">value used in case of a constant border; by default, it is 0.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.WarpPerspective(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InterpolationFlags,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Applies a perspective transformation to an image.
            </summary>
            <param name="m">3x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) 
            and the optional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (dst -> src).</param>
            <param name="borderMode">pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).</param>
            <param name="borderValue">value used in case of a constant border; by default, it equals 0.</param>
            <returns>output image that has the size dsize and the same type as src.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Remap(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InterpolationFlags,ST4IVisionCoreNet.BorderTypes,System.Nullable{ST4IVisionCoreNet.Scalar})">
            <summary>
            Applies a generic geometrical transformation to an image.
            </summary>
            <param name="map1">The first map of either (x,y) points or just x values having the type CV_16SC2, CV_32FC1, or CV_32FC2.</param>
            <param name="map2">The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively.</param>
            <param name="interpolation">Interpolation method. The method INTER_AREA is not supported by this function.</param>
            <param name="borderMode">Pixel extrapolation method. When borderMode=BORDER_TRANSPARENT, 
            it means that the pixels in the destination image that corresponds to the "outliers" in 
            the source image are not modified by the function.</param>
            <param name="borderValue">Value used in case of a constant border. By default, it is 0.</param>
            <returns>Destination image. It has the same size as map1 and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.InvertAffineTransform">
            <summary>
            Inverts an affine transformation.
            </summary>
            <returns>Output reverse affine transformation.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GetRectSubPix(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Point2f,System.Int32)">
            <summary>
            Retrieves a pixel rectangle from an image with sub-pixel accuracy.
            </summary>
            <param name="patchSize">Size of the extracted patch.</param>
            <param name="center">Floating point coordinates of the center of the extracted rectangle 
            within the source image. The center must be inside the image.</param>
            <param name="patchType">Depth of the extracted pixels. By default, they have the same depth as src.</param>
            <returns>Extracted patch that has the size patchSize and the same number of channels as src .</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Accumulate(ST4IVisionCoreNet.InputArray)">
            <summary>
            Adds an image to the accumulator.
            </summary>
            <param name="mask">Optional operation mask.</param>
            <returns>Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.AccumulateSquare(ST4IVisionCoreNet.InputArray)">
            <summary>
            Adds the square of a source image to the accumulator.
            </summary>
            <param name="mask">Optional operation mask.</param>
            <returns>Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CreateHanningWindow(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Computes a Hanning window coefficients in two dimensions.
            </summary>
            <param name="winSize">The window size specifications</param>
            <param name="type">Created array type</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Threshold(System.Double,System.Double,ST4IVisionCoreNet.ThresholdTypes)">
            <summary>
            Applies a fixed-level threshold to each array element.
            The input matrix must be single-channel, 8-bit or 32-bit floating point.
            </summary>
            <param name="thresh">threshold value.</param>
            <param name="maxval">maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types.</param>
            <param name="type">thresholding type (see the details below).</param>
            <returns>output array of the same size and type as src.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.AdaptiveThreshold(System.Double,ST4IVisionCoreNet.AdaptiveThresholdTypes,ST4IVisionCoreNet.ThresholdTypes,System.Int32,System.Double)">
            <summary>
            Applies an adaptive threshold to an array.
            Source matrix must be 8-bit single-channel image.
            </summary>
            <param name="maxValue">Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.</param>
            <param name="adaptiveMethod">Adaptive thresholding algorithm to use, ADAPTIVE_THRESH_MEAN_C or ADAPTIVE_THRESH_GAUSSIAN_C .</param>
            <param name="thresholdType">Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV .</param>
            <param name="blockSize">Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</param>
            <param name="c">Constant subtracted from the mean or weighted mean (see the details below). 
            Normally, it is positive but may be zero or negative as well.</param>
            <returns>Destination image of the same size and the same type as src.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PyrDown(System.Nullable{ST4IVisionCoreNet.Size},ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Blurs an image and downsamples it.
            </summary>
            <param name="dstSize">size of the output image; by default, it is computed as Size((src.cols+1)/2</param>
            <param name="borderType"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PyrUp(System.Nullable{ST4IVisionCoreNet.Size},ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Upsamples an image and then blurs it.
            </summary>
            <param name="dstSize">size of the output image; by default, it is computed as Size(src.cols*2, (src.rows*2)</param>
            <param name="borderType"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Undistort(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            corrects lens distortion for the given camera matrix and distortion coefficients
            </summary>
            <param name="cameraMatrix"> Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, 
            or 8 elements. If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="newCameraMatrix">Camera matrix of the distorted image. 
            By default, it is the same as cameraMatrix but you may additionally scale 
            and shift the result by using a different matrix.</param>
            <returns>Output (corrected) image that has the same size and type as src .</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GetDefaultNewCameraMatrix(System.Nullable{ST4IVisionCoreNet.Size},System.Boolean)">
            <summary>
            returns the default new camera matrix (by default it is the same as cameraMatrix unless centerPricipalPoint=true)
            </summary>
            <param name="imgSize">Camera view image size in pixels.</param>
            <param name="centerPrincipalPoint">Location of the principal point in the new camera matrix. 
            The parameter indicates whether this location should be at the image center or not.</param>
            <returns>the camera matrix that is either an exact copy of the input cameraMatrix 
            (when centerPrinicipalPoint=false), or the modified one (when centerPrincipalPoint=true).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.UndistortPoints(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes the ideal point coordinates from the observed point coordinates.
            Input matrix is an observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).
            </summary>
            <param name="cameraMatrix">Camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="r">Rectification transformation in the object space (3x3 matrix). 
            R1 or R2 computed by stereoRectify() can be passed here. 
            If the matrix is empty, the identity transformation is used.</param>
            <param name="p">New camera matrix (3x3) or new projection matrix (3x4). 
            P1 or P2 computed by stereoRectify() can be passed here. If the matrix is empty, 
            the identity new camera matrix is used.</param>
            <returns>Output ideal point coordinates after undistortion and reverse perspective transformation. 
            If matrix P is identity or omitted, dst will contain normalized point coordinates.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.EqualizeHist">
            <summary>
            Normalizes the grayscale image brightness and contrast by normalizing its histogram.
            The source matrix is 8-bit single channel image.
            </summary>
            <returns>The destination image; will have the same size and the same type as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Watershed(ST4IVisionCoreNet.InputOutputArray)">
            <summary>
            Performs a marker-based image segmentation using the watershed algorithm.
            Input matrix is 8-bit 3-channel image.
            </summary>
            <param name="markers">Input/output 32-bit single-channel image (map) of markers. 
            It should have the same size as image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PyrMeanShiftFiltering(System.Double,System.Double,System.Int32,System.Nullable{ST4IVisionCoreNet.TermCriteria})">
            <summary>
            Performs initial step of meanshift segmentation of an image.
            The source matrix is 8-bit, 3-channel image.
            </summary>
            <param name="sp">The spatial window radius.</param>
            <param name="sr">The color window radius.</param>
            <param name="maxLevel">Maximum level of the pyramid for the segmentation.</param>
            <param name="termcrit">Termination criteria: when to stop meanshift iterations.</param>
            <returns>The destination image of the same format and the same size as the source.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.GrabCut(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputOutputArray,System.Int32,ST4IVisionCoreNet.GrabCutModes)">
            <summary>
            Segments the image using GrabCut algorithm.
            The input is 8-bit 3-channel image.
            </summary>
            <param name="mask">Input/output 8-bit single-channel mask. 
            The mask is initialized by the function when mode is set to GC_INIT_WITH_RECT. 
            Its elements may have Sv.GC_BGD / Sv.GC_FGD / Sv.GC_PR_BGD / Sv.GC_PR_FGD</param>
            <param name="rect">ROI containing a segmented object. The pixels outside of the ROI are 
            marked as "obvious background". The parameter is only used when mode==GC_INIT_WITH_RECT.</param>
            <param name="bgdModel">Temporary array for the background model. Do not modify it while you are processing the same image.</param>
            <param name="fgdModel">Temporary arrays for the foreground model. Do not modify it while you are processing the same image.</param>
            <param name="iterCount">Number of iterations the algorithm should make before returning the result. 
            Note that the result can be refined with further calls with mode==GC_INIT_WITH_MASK or mode==GC_EVAL .</param>
            <param name="mode">Operation mode that could be one of GrabCutFlag value.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FloodFill(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar)">
            <summary>
            Fills a connected component with the given color.
            Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.
            </summary>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FloodFill(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Rect@,System.Nullable{ST4IVisionCoreNet.Scalar},System.Nullable{ST4IVisionCoreNet.Scalar},ST4IVisionCoreNet.FloodFillFlags)">
            <summary>
            Fills a connected component with the given color.
            Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.
            </summary>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <param name="rect">Optional output parameter set by the function to the 
            minimum bounding rectangle of the repainted domain.</param>
            <param name="loDiff">Maximal lower brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="upDiff">Maximal upper brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="flags">Operation flags. Lower bits contain a connectivity value, 
            4 (default) or 8, used within the function. Connectivity determines which 
            neighbors of a pixel are considered. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FloodFill(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar)">
            <summary>
            Fills a connected component with the given color.
            Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.
            </summary>
            <param name="mask">(For the second function only) Operation mask that should be a single-channel 8-bit image, 
            2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of 
            initializing the mask content. Flood-filling cannot go across non-zero pixels in the mask. For example, 
            an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask 
            in multiple calls to the function to make sure the filled area does not overlap.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FloodFill(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Rect@,System.Nullable{ST4IVisionCoreNet.Scalar},System.Nullable{ST4IVisionCoreNet.Scalar},ST4IVisionCoreNet.FloodFillFlags)">
            <summary>
            Fills a connected component with the given color.
            Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.
            </summary>
            <param name="mask">(For the second function only) Operation mask that should be a single-channel 8-bit image, 
            2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of 
            initializing the mask content. Flood-filling cannot go across non-zero pixels in the mask. For example, 
            an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask 
            in multiple calls to the function to make sure the filled area does not overlap.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <param name="rect">Optional output parameter set by the function to the 
            minimum bounding rectangle of the repainted domain.</param>
            <param name="loDiff">Maximal lower brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="upDiff">Maximal upper brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="flags">Operation flags. Lower bits contain a connectivity value, 
            4 (default) or 8, used within the function. Connectivity determines which 
            neighbors of a pixel are considered. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.CvtColor(ST4IVisionCoreNet.ColorConversionCodes,System.Int32)">
            <summary>
            Converts image from one color space to another
            </summary>
            <param name="code">The color space conversion code</param>
            <param name="dstCn">The number of channels in the destination image; if the parameter is 0, the number of the channels will be derived automatically from src and the code</param>
            <returns>The destination image; will have the same size and the same depth as src</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.Moments(System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            The input is a raster image (single-channel, 8-bit or floating-point 2D array).
            </summary>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MatchTemplate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.TemplateMatchModes,ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes the proximity map for the raster template and the image where the template is searched for
            The input is Image where the search is running; should be 8-bit or 32-bit floating-point.
            </summary>
            <param name="templ">Searched template; must be not greater than the source image and have the same data type</param>
            <param name="method">Specifies the comparison method</param>
            <param name="mask">Mask of searched template. It must have the same datatype and size with templ. It is not set by default.</param>
            <returns>A map of comparison results; will be single-channel 32-bit floating-point. 
            If image is WxH and templ is wxh then result will be (W-w+1) x (H-h+1).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConnectedComponents(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled image</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConnectedComponents(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity,ST4IVisionCoreNet.MatType)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled image</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConnectedComponents(System.Int32[0:,0:]@,ST4IVisionCoreNet.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled rectangular array</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConnectedComponentsWithStats(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled image</param>
            <param name="stats">statistics output for each label, including the background label, 
            see below for available statistics. Statistics are accessed via stats(label, COLUMN) 
            where COLUMN is one of cv::ConnectedComponentsTypes</param>
            <param name="centroids">floating point centroid (x,y) output for each label, 
            including the background label</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConnectedComponentsWithStats(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.PixelConnectivity,ST4IVisionCoreNet.MatType)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled image</param>
            <param name="stats">statistics output for each label, including the background label, 
            see below for available statistics. Statistics are accessed via stats(label, COLUMN) 
            where COLUMN is one of cv::ConnectedComponentsTypes</param>
            <param name="centroids">floating point centroid (x,y) output for each label, 
            including the background label</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConnectedComponentsEx(ST4IVisionCoreNet.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FindContours(ST4IVisionCoreNet.Point[][]@,ST4IVisionCoreNet.HierarchyIndex[]@,ST4IVisionCoreNet.RetrievalModes,ST4IVisionCoreNet.ContourApproximationModes,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds contours in a binary image.
            The source is an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary. The function modifies this image while extracting the contours.
            </summary>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology. 
            It has as many elements as the number of contours. For each i-th contour contours[i], 
            the members of the elements hierarchy[i] are set to 0-based indices in contours of the next 
            and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. 
            If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.</param>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FindContours(ST4IVisionCoreNet.Mat[]@,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.RetrievalModes,ST4IVisionCoreNet.ContourApproximationModes,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds contours in a binary image.
            The source is an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary. The function modifies this image while extracting the contours.
            </summary>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology. 
            It has as many elements as the number of contours. For each i-th contour contours[i], 
            the members of the elements hierarchy[i] are set to 0-based indices in contours of the next 
            and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. 
            If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.</param>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FindContoursAsArray(ST4IVisionCoreNet.RetrievalModes,ST4IVisionCoreNet.ContourApproximationModes,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds contours in a binary image.
            The source is an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary. The function modifies this image while extracting the contours.
            </summary>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
            <returns>Detected contours. Each contour is stored as a vector of points.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FindContoursAsMat(ST4IVisionCoreNet.RetrievalModes,ST4IVisionCoreNet.ContourApproximationModes,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Finds contours in a binary image.
            The source is an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary. The function modifies this image while extracting the contours.
            </summary>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
            <returns>Detected contours. Each contour is stored as a vector of points.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.DrawContours(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point}},System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.HierarchyIndex},System.Int32,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Draws contours in the image
            </summary>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours.</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative (for example, thickness=CV_FILLED ), 
            the contour interiors are drawn.</param>
            <param name="lineType">Line connectivity. </param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="maxLevel">Maximal level for drawn contours. If it is 0, only the specified contour is drawn. 
            If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, 
            all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account 
            when there is hierarchy available.</param>
            <param name="offset">Optional contour shift parameter. Shift all the drawn contours by the specified offset = (dx, dy)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.DrawContours(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Int32,ST4IVisionCoreNet.Scalar,System.Int32,ST4IVisionCoreNet.LineTypes,ST4IVisionCoreNet.Mat,System.Int32,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Draws contours in the image
            </summary>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours.</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative (for example, thickness=CV_FILLED ), 
            the contour interiors are drawn.</param>
            <param name="lineType">Line connectivity. </param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="maxLevel">Maximal level for drawn contours. If it is 0, only the specified contour is drawn. 
            If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, 
            all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account 
            when there is hierarchy available.</param>
            <param name="offset">Optional contour shift parameter. Shift all the drawn contours by the specified offset = (dx, dy)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ApproxPolyDP(System.Double,System.Boolean)">
            <summary>
            Approximates contour or a curve using Douglas-Peucker algorithm.
            The input is the polygon or curve to approximate and 
            it must be 1 x N or N x 1 matrix of type CV_32SC2 or CV_32FC2.
            </summary>
            <param name="epsilon">Specifies the approximation accuracy. 
            This is the maximum distance between the original curve and its approximation.</param>
            <param name="closed">The result of the approximation; 
            The type should match the type of the input curve</param>
            <returns>The result of the approximation; 
            The type should match the type of the input curve</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ArcLength(System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <param name="closed">Indicates, whether the curve is closed or not</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.BoundingRect">
            <summary>
            Calculates the up-right bounding rectangle of a point set.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <returns>Minimal up-right bounding rectangle for the specified point set.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ContourArea(System.Boolean)">
            <summary>
            Calculates the contour area.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <param name="oriented"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MinAreaRect">
            <summary>
            Finds the minimum area rotated rectangle enclosing a 2D point set.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.MinEnclosingCircle(ST4IVisionCoreNet.Point2f@,System.Single@)">
            <summary>
            Finds the minimum area circle enclosing a 2D point set.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <param name="center">The output center of the circle</param>
            <param name="radius">The output radius of the circle</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConvexHull(System.Boolean,System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <param name="returnPoints"></param>
            <returns>The output convex hull. It is either a vector of points that form the 
            hull (must have the same type as the input points), or a vector of 0-based point 
            indices of the hull points in the original array (since the set of convex hull 
            points is a subset of the original point set).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConvexHullPoints(System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of points that form the 
            hull (must have the same type as the input points).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConvexHullFloatPoints(System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of points that form the 
            hull (must have the same type as the input points).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConvexHullIndices(System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of 0-based point 
            indices of the hull points in the original array (since the set of convex hull 
            points is a subset of the original point set).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConvexityDefects(ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <returns>The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.ConvexityDefectsAsVec(ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <returns>The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.IsContourConvex">
            <summary>
            Returns true if the contour is convex. 
            Does not support contours with self-intersection
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FitEllipse">
            <summary>
            Fits ellipse to the set of 2D points.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FitLine2D(ST4IVisionCoreNet.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 2D points using M-estimator algorithm.
            The input is vector of 2D points.
            </summary>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.FitLine3D(ST4IVisionCoreNet.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 3D points using M-estimator algorithm.
            The input is vector of 3D points.
            </summary>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.PointPolygonTest(ST4IVisionCoreNet.Point2f,System.Boolean)">
            <summary>
            Checks if the point is inside the contour. 
            Optionally computes the signed distance from the point to the contour boundary.
            </summary>
            <param name="pt">Point tested against the contour.</param>
            <param name="measureDist">If true, the function estimates the signed distance 
            from the point to the nearest contour edge. Otherwise, the function only checks 
            if the point is inside a contour or not.</param>
            <returns>Positive (inside), negative (outside), or zero (on an edge) value.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat.DistanceTransform(ST4IVisionCoreNet.DistanceTypes,ST4IVisionCoreNet.DistanceTransformMasks)">
            <summary>
            Computes the distance transform map
            </summary>
            <param name="distanceType"></param>
            <param name="maskSize"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.MatIndexer`1">
            <summary>
            Abstract definition of Mat indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:ST4IVisionCoreNet.MatIndexer`1.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.MatIndexer`1.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.MatIndexer`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.MatIndexer`1.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.MatIndexer`1.Parent">
            <summary>
            Parent matrix object
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MatIndexer`1.Steps">
            <summary>
            Step byte length for each dimension
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatIndexer`1.#ctor(ST4IVisionCoreNet.Mat)">
            <summary>
            Constructor
            </summary>
            <param name="parent"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Mat`1">
            <summary>
            Type-specific abstract matrix 
            </summary>
            <typeparam name="TElem">Element Type</typeparam>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(ST4IVisionCoreNet.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(ST4IVisionCoreNet.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.Int32,System.Int32,ST4IVisionCoreNet.Scalar)">
            <summary>
            constructs 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Scalar)">
            <summary>
            constructs 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(ST4IVisionCoreNet.Mat{`0},ST4IVisionCoreNet.Range,System.Nullable{ST4IVisionCoreNet.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(ST4IVisionCoreNet.Mat{`0},ST4IVisionCoreNet.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(ST4IVisionCoreNet.Mat{`0},ST4IVisionCoreNet.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically de-allocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.Int32,System.Int32,System.Array,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically de-allocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically de-allocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically de-allocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.#ctor(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.Scalar)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:ST4IVisionCoreNet.Mat`1.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat`1.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat`1.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat`1.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat`1.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.GetEnumerator">
            <summary>
            Gets read-only enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.Wrap(ST4IVisionCoreNet.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.Clone">
            <summary>
            Creates a full copy of the matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.Reshape(System.Int32)">
            <summary>
            Changes the shape of channels of a 2D matrix without copying the data.
            </summary>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.Reshape(System.Int32[])">
            <summary>
            Changes the shape of a 2D matrix without copying the data.
            </summary>
            <param name="newDims">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.T">
            <summary>
            Transposes a matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.SubMat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.SubMat(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included. 
            To select all the rows, use Range.All().</param>
            <param name="colRange">Start and end column of the extracted submatrix. 
            The upper boundary is not included. To select all the columns, use Range.All().</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.SubMat(ST4IVisionCoreNet.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Mat`1.SubMat(ST4IVisionCoreNet.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat`1.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat`1.Item(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included. 
            To select all the rows, use Range.All().</param>
            <param name="colRange">Start and end column of the extracted submatrix. 
            The upper boundary is not included. To select all the columns, use Range.All().</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat`1.Item(ST4IVisionCoreNet.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Mat`1.Item(ST4IVisionCoreNet.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.UMat">
            <summary>
            OpenCV C++ n-dimensional dense array class (cv::Mat)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.UMat.TypeMap">
            <summary>
            typeof(T) -> MatType
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(ST4IVisionCoreNet.UMat)">
            <inheritdoc />
            <summary>
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(System.Int32,System.Int32,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="usageFlags">usage flags for allocator</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType.CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="usageFlags">usage flags for allocator</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(System.Int32,System.Int32,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            constructs 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
            <param name="usageFlags">usage flags for allocator</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            constructs 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
            <param name="usageFlags">usage flags for allocator</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(ST4IVisionCoreNet.UMat,ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range,ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
            <param name="usageFlags">usage flags for allocator</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(ST4IVisionCoreNet.UMat,ST4IVisionCoreNet.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(ST4IVisionCoreNet.UMat,ST4IVisionCoreNet.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.MatType)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.Scalar)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Release">
            <summary>
            Releases the resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.DisposeUnmanaged">
            <inheritdoc />
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Diag(ST4IVisionCoreNet.UMat)">
            <summary>
            Extracts a diagonal from a matrix, or creates a diagonal matrix.
            </summary>
            <param name="d">One-dimensional matrix that represents the main diagonal.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Zeros(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Zeros(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Zeros(ST4IVisionCoreNet.MatType,System.Int32[])">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="type">Created matrix type.</param>
            <param name="sizes"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Ones(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Ones(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Ones(ST4IVisionCoreNet.MatType,System.Int32[])">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="type">Created matrix type.</param>
            <param name="sizes">Array of integers specifying the array shape.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Eye(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns an identity matrix of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Eye(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            Returns an identity matrix of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Item(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included. 
            To select all the rows, use Range.All().</param>
            <param name="colRange">Start and end column of the extracted submatrix. 
            The upper boundary is not included. To select all the columns, use Range.All().</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Item(ST4IVisionCoreNet.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Item(ST4IVisionCoreNet.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.GetMat(ST4IVisionCoreNet.AccessFlag)">
            <summary>
            Returns the UMat data as a Mat.
            </summary>
            <param name="accessFlags">AccessFlag determining the mode in which the data is to be acquired</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Col(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.ColRange(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="startCol">An inclusive 0-based start index of the column span.</param>
            <param name="endCol"> An exclusive 0-based ending index of the column span.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.ColRange(ST4IVisionCoreNet.Range)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Row(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row.
            </summary>
            <param name="y">A 0-based row index.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.RowRange(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified row span.
            </summary>
            <param name="startRow"></param>
            <param name="endRow"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.RowRange(ST4IVisionCoreNet.Range)">
            <summary>
             Creates a matrix header for the specified row span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Diag(ST4IVisionCoreNet.MatDiagType)">
            <summary>
            Single-column matrix that forms a diagonal matrix or index of the diagonal, with the following values:
            </summary>
            <param name="d">Single-column matrix that forms a diagonal matrix or index of the diagonal, with the following values:</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Clone">
            <summary>
            Creates a full copy of the matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Clone(ST4IVisionCoreNet.Rect)">
            <summary>
            Returns the partial Mat of the specified Mat
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.CopyTo(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Copies the matrix to another one.
            </summary>
            <param name="m">Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.CopyTo(ST4IVisionCoreNet.UMat,ST4IVisionCoreNet.InputArray)">
            <summary>
            Copies the matrix to another one.
            </summary>
            <param name="m">Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.ConvertTo(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">desired output matrix type or, rather, the depth since the number of channels are the same as the input has; 
            if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">optional scale factor.</param>
            <param name="beta">optional delta added to the scaled values.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.AssignTo(ST4IVisionCoreNet.UMat,System.Nullable{ST4IVisionCoreNet.MatType})">
            <summary>
            Provides a functional form of convertTo.
            </summary>
            <param name="m">Destination array.</param>
            <param name="type">Desired destination array depth (or -1 if it should be the same as the source type).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.SetTo(ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.UMat)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.SetTo(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.UMat)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Reshape(System.Int32,System.Int32[])">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="newDims">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.T">
            <summary>
            Transposes a matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Inv(ST4IVisionCoreNet.DecompTypes)">
            <summary>
            Inverses a matrix.
            </summary>
            <param name="method">Matrix inversion method</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Mul(ST4IVisionCoreNet.InputArray,System.Double)">
            <summary>
            Performs an element-wise multiplication or division of the two matrices.
            </summary>
            <param name="m"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Dot(ST4IVisionCoreNet.InputArray)">
            <summary>
            Computes a dot-product of two vectors.
            </summary>
            <param name="m">another dot-product operand.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Create(System.Int32,System.Int32,ST4IVisionCoreNet.MatType)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Create(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.MatType)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="size">Alternative new matrix size specification: Size(cols, rows)</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Create(ST4IVisionCoreNet.MatType,System.Int32[])">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="sizes">Array of integers specifying a new array shape.</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.LocateROI(ST4IVisionCoreNet.Size@,ST4IVisionCoreNet.Point@)">
            <summary>
            Locates the matrix header within a parent matrix.
            </summary>
            <param name="wholeSize">Output parameter that contains the size of the whole matrix containing *this as a part.</param>
            <param name="ofs">Output parameter that contains an offset of *this inside the whole matrix.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.AdjustROI(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adjusts a submatrix size and position within the parent matrix.
            </summary>
            <param name="dtop">Shift of the top submatrix boundary upwards.</param>
            <param name="dbottom">Shift of the bottom submatrix boundary downwards.</param>
            <param name="dleft">Shift of the left submatrix boundary to the left.</param>
            <param name="dright">Shift of the right submatrix boundary to the right.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.SubMat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.SubMat(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included.
            To select all the rows, use Range::all().</param>
            <param name="colRange">Start and end column of the extracted submatrix. The upper boundary is not included.
            To select all the columns, use Range::all().</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.SubMat(ST4IVisionCoreNet.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.SubMat(ST4IVisionCoreNet.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.IsContinuous">
            <summary>
            Reports whether the matrix is continuous or not.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.IsSubmatrix">
            <summary>
            Returns whether this matrix is a part of other matrix or not.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.ElemSize">
            <summary>
            Returns the matrix element size in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.ElemSize1">
            <summary>
            Returns the size of each matrix element channel in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Type">
            <summary>
            Returns the type of a matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Depth">
            <summary>
            Returns the depth of a matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Channels">
            <summary>
            Returns the number of matrix channels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Step1(System.Int32)">
            <summary>
            Returns a normalized step.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Empty">
            <summary>
            Returns true if the array has no elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Total">
            <summary>
            Returns the total number of array elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.CheckVector(System.Int32,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="elemChannels">Number of channels or number of columns the matrix should have.
            For a 2-D matrix, when the matrix has only 1 column, then it should have
            elemChannels channels; When the matrix has only 1 channel,
            then it should have elemChannels columns. For a 3-D matrix, it should have only one channel.
            Furthermore, if the number of planes is not one, then the number of rows within every
            plane has to be 1; if the number of rows within every plane is not 1,
            then the number of planes has to be 1.</param>
            <param name="depth">The depth the matrix should have. Set it to -1 when any depth is fine.</param>
            <param name="requireContinuous">Set it to true to require the matrix to be continuous</param>
            <returns>-1 if the requirement is not satisfied.
            Otherwise, it returns the number of elements in the matrix. Note that an element may have multiple channels.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Flags">
            <summary>
            includes several bit-fields:
            - the magic signature
            - continuity flag
            - depth
            - number of channels
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Dims">
            <summary>
            the array dimensionality, >= 2
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Rows">
            <summary>
            the number of rows or -1 when the array has more than 2 dimensions
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Height">
            <summary>
            the number of rows or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Cols">
            <summary>
            the number of columns or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.UMat.Width">
            <summary>
            the number of columns or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Size">
            <summary>
            Returns a matrix size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Size(System.Int32)">
            <summary>
            Returns a matrix size.
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Step">
            <summary>
            Returns number of bytes each matrix row occupies.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Step(System.Int32)">
            <summary>
            Returns number of bytes each matrix row occupies.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.ToString">
            <summary>
            Returns a string that represents this Mat.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.EmptyClone(ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            Makes a Mat that have the same size, depth and channels as this image
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.UMat.Alignment(System.Int32,ST4IVisionCoreNet.UMatUsageFlags)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <param name="usageFlags">usage flags for allocator</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.OutputArray">
            <summary>
            Proxy datatype for passing Mat's and List&lt;&gt;'s as output parameters
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.#ctor(ST4IVisionCoreNet.Mat)">
            <summary>
            Constructor
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.#ctor(ST4IVisionCoreNet.UMat)">
            <summary>
            Constructor
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            Constructor
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.op_Implicit(ST4IVisionCoreNet.Mat)~ST4IVisionCoreNet.OutputArray">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.op_Implicit(ST4IVisionCoreNet.UMat)~ST4IVisionCoreNet.OutputArray">
            <summary>
            
            </summary>
            <param name="umat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.IsMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.IsUMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.GetMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.IsVectorOfMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.GetVectorOfMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.AssignResult">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.Fix">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.IsReady">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.ThrowIfNotReady">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.Create(ST4IVisionCoreNet.Mat)">
            <summary>
            Creates a proxy class of the specified matrix
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.Create(ST4IVisionCoreNet.UMat)">
            <summary>
            Creates a proxy class of the specified matrix
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.Create``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArray.Create(System.Collections.Generic.List{ST4IVisionCoreNet.Mat})">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.OutputArrayOfMatList">
            <summary>
            Proxy datatype for passing Mat's and List&lt;&gt;'s as output parameters
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArrayOfMatList.#ctor(System.Collections.Generic.List{ST4IVisionCoreNet.Mat})">
            <summary>
            
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArrayOfMatList.GetVectorOfMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArrayOfMatList.AssignResult">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.OutputArrayOfStructList`1">
            <summary>
            Proxy datatype for passing Mat's and List&lt;&gt;'s as output parameters
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArrayOfStructList`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.OutputArrayOfStructList`1.AssignResult">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.PCA">
            <summary>
            Principal Component Analysis
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.#ctor">
             <summary>
             default constructor.
            
             The default constructor initializes an empty PCA structure.
             The other constructors initialize the structure and call PCA::operator()().
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.#ctor(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.PCA.Flags,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="data">input samples stored as matrix rows or matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (@c noArray()), the mean is computed from the data.</param>
            <param name="flags">operation flags; currently the parameter is only used to specify the data layout (PCA::Flags)</param>
            <param name="maxComponents">maximum number of components that PCA should retain; by default, all the components are retained.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.#ctor(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.PCA.Flags,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="data">input samples stored as matrix rows or matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
            <param name="flags">operation flags; currently the parameter is only used to specify the data layout (PCA::Flags)</param>
            <param name="retainedVariance">Percentage of variance that PCA should retain.
            Using this parameter will let the PCA decided how many components to retain but it will always keep at least 2.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.PCA.Eigenvectors">
            <summary>
            eigenvalues of the covariation matrix
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.PCA.Eigenvalues">
            <summary>
            eigenvalues of the covariation matrix
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.PCA.Mean">
            <summary>
            mean value subtracted before the projection and added after the back projection
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.PCA.Flags,System.Int32)">
             <summary>
             Performs PCA.
            
             The operator performs %PCA of the supplied dataset. It is safe to reuse
             the same PCA structure for multiple datasets. That is, if the structure
             has been previously used with another dataset, the existing internal
             data is reclaimed and the new @ref eigenvalues, @ref eigenvectors and @ref
             mean are allocated and computed.
            
             The computed @ref eigenvalues are sorted from the largest to the smallest and
             the corresponding @ref eigenvectors are stored as eigenvectors rows.
             </summary>
             <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
             <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
             <param name="flags">operation flags; currently the parameter is only used to specify the data layout. (Flags)</param>
             <param name="maxComponents">maximum number of components that PCA should retain;
             by default, all the components are retained.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.ComputeVar(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.PCA.Flags,System.Double)">
             <summary>
             Performs PCA.
            
             The operator performs %PCA of the supplied dataset. It is safe to reuse
             the same PCA structure for multiple datasets. That is, if the structure
             has been previously used with another dataset, the existing internal
             data is reclaimed and the new @ref eigenvalues, @ref eigenvectors and @ref
             mean are allocated and computed.
            
             The computed @ref eigenvalues are sorted from the largest to the smallest and
             the corresponding @ref eigenvectors are stored as eigenvectors rows.
             </summary>
             <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
             <param name="mean">optional mean value; if the matrix is empty (noArray()),
             the mean is computed from the data.</param>
             <param name="flags">operation flags; currently the parameter is only used to
             specify the data layout. (PCA::Flags)</param>
             <param name="retainedVariance">Percentage of variance that %PCA should retain.
             Using this parameter will let the %PCA decided how many components to
             retain but it will always keep at least 2.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.Project(ST4IVisionCoreNet.InputArray)">
             <summary>
             Projects vector(s) to the principal component subspace.
            
             The methods project one or more vectors to the principal component
             subspace, where each vector projection is represented by coefficients in
             the principal component basis. The first form of the method returns the
             matrix that the second form writes to the result. So the first form can
             be used as a part of expression while the second form can be more
             efficient in a processing loop.
             </summary>
             <param name="vec">input vector(s); must have the same dimensionality and the
             same layout as the input data used at %PCA phase, that is, if
             DATA_AS_ROW are specified, then `vec.cols==data.cols`
             (vector dimensionality) and `vec.rows` is the number of vectors to
             project, and the same is true for the PCA::DATA_AS_COL case.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.Project(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Projects vector(s) to the principal component subspace.
            </summary>
            <param name="vec">input vector(s); must have the same dimensionality and the
            same layout as the input data used at PCA phase, that is, if DATA_AS_ROW are
            specified, then `vec.cols==data.cols` (vector dimensionality) and `vec.rows`
            is the number of vectors to project, and the same is true for the PCA::DATA_AS_COL case.</param>
            <param name="result">output vectors; in case of PCA::DATA_AS_COL, the
            output matrix has as many columns as the number of input vectors, this
            means that `result.cols==vec.cols` and the number of rows match the
            number of principal components (for example, `maxComponents` parameter
            passed to the constructor).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.BackProject(ST4IVisionCoreNet.InputArray)">
             <summary>
             Reconstructs vectors from their PC projections.
            
             The methods are inverse operations to PCA::project. They take PC
             coordinates of projected vectors and reconstruct the original vectors.
             Unless all the principal components have been retained, the
             reconstructed vectors are different from the originals. But typically,
             the difference is small if the number of components is large enough (but
             still much smaller than the original vector dimensionality). As a result, PCA is used.
             </summary>
             <param name="vec">coordinates of the vectors in the principal component subspace,
             the layout and size are the same as of PCA::project output vectors.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.BackProject(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
             <summary>
             Reconstructs vectors from their PC projections.
            
             The methods are inverse operations to PCA::project. They take PC
             coordinates of projected vectors and reconstruct the original vectors.
             Unless all the principal components have been retained, the
             reconstructed vectors are different from the originals. But typically,
             the difference is small if the number of components is large enough (but
             still much smaller than the original vector dimensionality). As a result, PCA is used.
             </summary>
             <param name="vec">coordinates of the vectors in the principal component subspace,
             the layout and size are the same as of PCA::project output vectors.</param>
             <param name="result">reconstructed vectors; the layout and size are the same as 
             of PCA::project input vectors.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.Write(ST4IVisionCoreNet.FileStorage)">
            <summary>
            Write PCA objects.
            Writes @ref eigenvalues @ref eigenvectors and @ref mean to specified FileStorage
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.PCA.Read(ST4IVisionCoreNet.FileNode)">
            <summary>
            Load PCA objects.
            Loads @ref eigenvalues @ref eigenvectors and @ref mean from specified FileNode
            </summary>
            <param name="fn"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.PCA.Flags">
            <summary>
            Flags for PCA operations
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.PCA.Flags.DataAsRow">
            <summary>
            The vectors are stored as rows (i.e. all the components of a certain vector are stored continously)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.PCA.Flags.DataAsCol">
            <summary>
            The vectors are stored as columns (i.e. values of a certain vector component are stored continuously)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.PCA.Flags.UseAvg">
            <summary>
            Use pre-computed average vector
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.RNG">
            <summary>
            Random Number Generator.
            The class implements RNG using Multiply-with-Carry algorithm.
            </summary>
            <remarks>operations.hpp</remarks>
        </member>
        <member name="P:ST4IVisionCoreNet.RNG.State">
            <summary> 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.#ctor(System.UInt64)">
            <summary>
            Constructor
            </summary>
            <param name="state">64-bit value used to initialize the RNG.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Explicit(ST4IVisionCoreNet.RNG)~System.Byte">
            <summary>
            (byte)RNG.next()
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.ToByte">
            <summary>
            (byte)RNG.next()
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Explicit(ST4IVisionCoreNet.RNG)~System.SByte">
            <summary>
            (sbyte)RNG.next()
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.ToSByte">
            <summary>
            (sbyte)RNG.next()
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Explicit(ST4IVisionCoreNet.RNG)~System.UInt16">
            <summary>
            (ushort)RNG.next()
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.ToUInt16">
            <summary>
            (ushort)RNG.next()
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Explicit(ST4IVisionCoreNet.RNG)~System.Int16">
            <summary>
            (short)RNG.next()
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.ToInt16">
            <summary>
            (short)RNG.next()
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Explicit(ST4IVisionCoreNet.RNG)~System.UInt32">
            <summary>
            (uint)RNG.next()
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.ToUInt32">
            <summary>
            (uint)RNG.next()
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Explicit(ST4IVisionCoreNet.RNG)~System.Int32">
            <summary>
            (int)RNG.next()
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.ToInt32">
            <summary>
            (int)RNG.next()
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Explicit(ST4IVisionCoreNet.RNG)~System.Single">
            <summary>
            returns a next random value as float (System.Single)
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.ToSingle">
            <summary>
            returns a next random value as float (System.Single)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Explicit(ST4IVisionCoreNet.RNG)~System.Double">
            <summary>
            returns a next random value as double (System.Double)
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.ToDouble">
            <summary>
            returns a next random value as double (System.Double)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Next">
            <summary>
            updates the state and returns the next 32-bit unsigned integer random number
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Run(System.UInt32)">
            <summary>
            returns a random integer sampled uniformly from [0, N).
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Run">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Uniform(System.Int32,System.Int32)">
            <summary>
            returns uniformly distributed integer random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Uniform(System.Single,System.Single)">
            <summary>
            returns uniformly distributed floating-point random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Uniform(System.Double,System.Double)">
            <summary>
            returns uniformly distributed double-precision floating-point random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Fill(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.DistributionType,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            Fills arrays with random numbers.
            </summary>
            <param name="mat">2D or N-dimensional matrix; currently matrices with more than
            4 channels are not supported by the methods, use Mat::reshape as a possible workaround.</param>
            <param name="distType">distribution type, RNG::UNIFORM or RNG::NORMAL.</param>
            <param name="a">first distribution parameter; in case of the uniform distribution,
            this is an inclusive lower boundary, in case of the normal distribution, this is a mean value.</param>
            <param name="b">second distribution parameter; in case of the uniform distribution, this is
            a non-inclusive upper boundary, in case of the normal distribution, this is a standard deviation
            (diagonal of the standard deviation matrix or the full standard deviation matrix).</param>
            <param name="saturateRange">pre-saturation flag; for uniform distribution only;
            if true, the method will first convert a and b to the acceptable value range (according to the
            mat datatype) and then will generate uniformly distributed random numbers within the range
            [saturate(a), saturate(b)), if saturateRange=false, the method will generate uniformly distributed
            random numbers in the original range [a, b) and then will saturate them, it means, for example, that
            theRNG().fill(mat_8u, RNG::UNIFORM, -DBL_MAX, DBL_MAX) will likely produce array mostly filled
            with 0's and 255's, since the range (0, 255) is significantly smaller than [-DBL_MAX, DBL_MAX).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Gaussian(System.Double)">
             <summary>
             Returns the next random number sampled from the Gaussian distribution.
            
             The method transforms the state using the MWC algorithm and returns the  next random number
             from the Gaussian distribution N(0,sigma) . That is, the mean value of the returned random
             numbers is zero and the standard deviation is the specified sigma.
             </summary>
             <param name="sigma">standard deviation of the distribution.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.Equals(ST4IVisionCoreNet.RNG)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Equality(ST4IVisionCoreNet.RNG,ST4IVisionCoreNet.RNG)">
            <summary> 
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG.op_Inequality(ST4IVisionCoreNet.RNG,ST4IVisionCoreNet.RNG)">
            <summary> 
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.RNG_MT19937">
            <summary>
            Mersenne Twister random number generator
            </summary>
            <remarks>operations.hpp</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.#ctor(System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.op_Explicit(ST4IVisionCoreNet.RNG_MT19937)~System.UInt32">
            <summary> 
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.ToUInt32">
            <summary> 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.op_Explicit(ST4IVisionCoreNet.RNG_MT19937)~System.Int32">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.ToInt32">
            <summary> 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.op_Explicit(ST4IVisionCoreNet.RNG_MT19937)~System.Single">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.ToSingle">
            <summary> 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.op_Explicit(ST4IVisionCoreNet.RNG_MT19937)~System.Double">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.ToDouble">
            <summary> 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.Seed(System.UInt32)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.Next">
            <summary>
            updates the state and returns the next 32-bit unsigned integer random number
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.Run(System.UInt32)">
            <summary>
            returns a random integer sampled uniformly from [0, N).
            </summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.Run">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.Uniform(System.Int32,System.Int32)">
            <summary>
            returns uniformly distributed integer random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.Uniform(System.Single,System.Single)">
            <summary>
            returns uniformly distributed floating-point random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RNG_MT19937.Uniform(System.Double,System.Double)">
            <summary>
            returns uniformly distributed double-precision floating-point random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.SparseMat">
            <summary>
            Sparse matrix class.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::SparseMat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.#ctor">
            <summary>
            Creates empty SparseMat
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.MatType)">
            <summary>
            constructs n-dimensional sparse matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.#ctor(ST4IVisionCoreNet.Mat)">
            <summary>
            converts old-style CvMat to the new matrix; the data is not copied by default
            </summary>
            <param name="m">cv::Mat object</param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Release">
            <summary>
            Releases the resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.FromMat(ST4IVisionCoreNet.Mat)">
            <summary>
            Create SparseMat from Mat
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.AssignFrom(ST4IVisionCoreNet.SparseMat)">
            <summary>
            Assignment operator. This is O(1) operation, i.e. no data is copied
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.AssignFrom(ST4IVisionCoreNet.Mat)">
            <summary>
            Assignment operator. equivalent to the corresponding constructor.
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Clone">
            <summary>
            creates full copy of the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.CopyTo(ST4IVisionCoreNet.SparseMat)">
            <summary>
            copies all the data to the destination matrix. All the previous content of m is erased.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.CopyTo(ST4IVisionCoreNet.Mat)">
            <summary>
            converts sparse matrix to dense matrix.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.ConvertTo(ST4IVisionCoreNet.SparseMat,System.Int32,System.Double)">
            <summary>
            multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type
            </summary>
            <param name="m"></param>
            <param name="rtype"></param>
            <param name="alpha"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.ConvertTo(ST4IVisionCoreNet.Mat,System.Int32,System.Double,System.Double)">
            <summary>
            converts sparse matrix to dense n-dim matrix with optional type conversion and scaling.
            </summary>
            <param name="m"></param>
            <param name="rtype">The output matrix data type. When it is =-1, the output array will have the same data type as (*this)</param>
            <param name="alpha">The scale factor</param>
            <param name="beta">The optional delta added to the scaled values before the conversion</param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.AssignTo(ST4IVisionCoreNet.SparseMat,System.Int32)">
            <summary>
            not used now
            </summary>
            <param name="m"></param>
            <param name="type"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Create(ST4IVisionCoreNet.MatType,System.Int32[])">
            <summary>
            Reallocates sparse matrix.
            If the matrix already had the proper size and type,
            it is simply cleared with clear(), otherwise,
            the old matrix is released (using release()) and the new one is allocated.
            </summary>
            <param name="type"></param>
            <param name="sizes"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Clear">
            <summary>
            sets all the sparse matrix elements to 0, which means clearing the hash table.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.AddRef">
            <summary>
            manually increments the reference counter to the header.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.ElemSize">
            <summary>
            returns the size of each element in bytes (not including the overhead - the space occupied by SparseMat::Node elements)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.ElemSize1">
            <summary>
            returns elemSize()/channels()
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Type">
            <summary>
            Returns the type of sparse matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Depth">
            <summary>
            Returns the depth of sparse matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Dims">
            <summary>
            Returns the matrix dimensionality
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Channels">
            <summary>
            Returns the number of sparse matrix channels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Size">
            <summary>
            Returns the array of sizes, or null if the matrix is not allocated
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Size(System.Int32)">
            <summary>
            Returns the size of i-th matrix dimension (or 0)
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.NzCount">
            <summary>
            returns the number of non-zero elements (=the number of hash table nodes)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Hash(System.Int32)">
            <summary>
            Computes the element hash value (1D case)
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Hash(System.Int32,System.Int32)">
            <summary>
            Computes the element hash value (2D case)
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Hash(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the element hash value (3D case)
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Hash(System.Int32[])">
            <summary>
            Computes the element hash value (nD case)
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Ptr(System.Int32,System.Boolean,System.Nullable{System.Int64})">
            <summary>
            Low-level element-access function.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="createMissing">Create new element with 0 value if it does not exist in SparseMat.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Ptr(System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int64})">
            <summary>
            Low-level element-access function.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="createMissing">Create new element with 0 value if it does not exist in SparseMat.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Ptr(System.Int32,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int64})">
            <summary>
            Low-level element-access function.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="createMissing">Create new element with 0 value if it does not exist in SparseMat.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Ptr(System.Int32[],System.Boolean,System.Nullable{System.Int64})">
            <summary>
            Low-level element-access function.
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="createMissing">Create new element with 0 value if it does not exist in SparseMat.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Find``1(System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, null.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Find``1(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, null.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Find``1(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, null.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Find``1(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, null.
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Value``1(System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, default(T).
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Value``1(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, default(T).
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Value``1(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, default(T).
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Value``1(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, default(T).
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.SparseMat.Indexer`1">
            <summary>
            Mat Indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMat.Indexer`1.Item(System.Int32,System.Nullable{System.Int64})">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMat.Indexer`1.Item(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMat.Indexer`1.Item(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMat.Indexer`1.Item(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Ref``1">
            <summary>
            Gets a type-specific indexer. 
            The indexer has getters/setters to access each matrix element.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.GetIndexer``1">
            <summary>
            Gets a type-specific indexer. 
            The indexer has getters/setters to access each matrix element.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Get``1(System.Int32,System.Nullable{System.Int64})">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Get``1(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Get``1(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Get``1(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Set``1(System.Int32,``0,System.Nullable{System.Int64})">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="value"></param>
            <param name="hashVal"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Set``1(System.Int32,System.Int32,``0,System.Nullable{System.Int64})">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="value"></param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Set``1(System.Int32,System.Int32,System.Int32,``0,System.Nullable{System.Int64})">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="value"></param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.Set``1(System.Int32[],``0,System.Nullable{System.Int64})">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="value"></param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMat.ToString">
            <summary>
            Returns a string that represents this Mat.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.SparseMatIndexer`1">
            <summary>
            Abstract definition of Mat indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMatIndexer`1.Item(System.Int32,System.Nullable{System.Int64})">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMatIndexer`1.Item(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMatIndexer`1.Item(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMatIndexer`1.Item(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:ST4IVisionCoreNet.SparseMatIndexer`1.Parent">
            <summary>
            Parent matrix object
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SparseMatIndexer`1.#ctor(ST4IVisionCoreNet.SparseMat)">
            <summary>
            Constructor
            </summary>
            <param name="parent"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.DMatch">
            <summary>
            Struct for matching: query descriptor index, train descriptor index, train image index and distance between descriptors.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DMatch.QueryIdx">
            <summary>
            query descriptor index
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DMatch.TrainIdx">
            <summary>
            train descriptor index
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DMatch.ImgIdx">
            <summary>
            train image index
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DMatch.Distance">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DMatch.Empty">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DMatch.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="queryIdx"></param>
            <param name="trainIdx"></param>
            <param name="distance"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DMatch.#ctor(System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="queryIdx"></param>
            <param name="trainIdx"></param>
            <param name="imgIdx"></param>
            <param name="distance"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DMatch.op_LessThan(ST4IVisionCoreNet.DMatch,ST4IVisionCoreNet.DMatch)">
            <summary>
            Compares by distance (less is better)
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DMatch.op_GreaterThan(ST4IVisionCoreNet.DMatch,ST4IVisionCoreNet.DMatch)">
            <summary>
            Compares by distance (less is better)
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DMatch.CompareTo(ST4IVisionCoreNet.DMatch)">
            <summary>
            Compares by distance (less is better)
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DMatch.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.KeyPoint">
            <summary>
            Data structure for salient point detectors
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KeyPoint.Pt">
            <summary>
            Coordinate of the point
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KeyPoint.Size">
            <summary>
            Feature size
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KeyPoint.Angle">
            <summary>
            Feature orientation in degrees (has negative value if the orientation is not defined/not computed)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KeyPoint.Response">
            <summary>
            Feature strength (can be used to select only the most prominent key points)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KeyPoint.Octave">
            <summary>
            Scale-space octave in which the feature has been found; may correlate with the size
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KeyPoint.ClassId">
            <summary>
            Point class (can be used by feature classifiers or object detectors)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPoint.#ctor(ST4IVisionCoreNet.Point2f,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Complete constructor
            </summary>
            <param name="pt">Coordinate of the point</param>
            <param name="size">Feature size</param>
            <param name="angle">Feature orientation in degrees (has negative value if the orientation is not defined/not computed)</param>
            <param name="response">Feature strength (can be used to select only the most prominent key points)</param>
            <param name="octave">Scale-space octave in which the feature has been found; may correlate with the size</param>
            <param name="classId">Point class (can be used by feature classifiers or object detectors)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPoint.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Complete constructor
            </summary>
            <param name="x">X-coordinate of the point</param>
            <param name="y">Y-coordinate of the point</param>
            <param name="size">Feature size</param>
            <param name="angle">Feature orientation in degrees (has negative value if the orientation is not defined/not computed)</param>
            <param name="response">Feature strength (can be used to select only the most prominent key points)</param>
            <param name="octave">Scale-space octave in which the feature has been found; may correlate with the size</param>
            <param name="classId">Point class (can be used by feature classifiers or object detectors)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPoint.op_Equality(ST4IVisionCoreNet.KeyPoint,ST4IVisionCoreNet.KeyPoint)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPoint.op_Inequality(ST4IVisionCoreNet.KeyPoint,ST4IVisionCoreNet.KeyPoint)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPoint.Equals(ST4IVisionCoreNet.KeyPoint)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPoint.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPoint.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPoint.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.MatType">
            <summary>
            Matrix data type (depth and number of channels)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.value">
            <summary>
            Entity value
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MatType.Value">
            <summary>
            Entity value
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatType.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.MatType.op_Implicit(ST4IVisionCoreNet.MatType)~System.Int32">
            <summary> 
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatType.ToInt32">
            <summary> 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatType.op_Implicit(System.Int32)~ST4IVisionCoreNet.MatType">
            <summary> 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MatType.FromInt32(System.Int32)">
            <summary> 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.MatType.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MatType.IsInteger">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MatType.Channels">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MatType.ToString">
            <inheritdoc />
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8U">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8S">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16U">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16S">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32S">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32F">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_64F">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_USRTYPE1">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8UC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8UC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8UC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8UC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8SC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8SC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8SC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_8SC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16UC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16UC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16UC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16UC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16SC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16SC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16SC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_16SC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32SC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32SC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32SC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32SC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32FC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32FC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32FC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_32FC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_64FC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_64FC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_64FC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MatType.CV_64FC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Point">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point.Y">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.op_Equality(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point)">
            <summary>
            Compares two Point objects. The result specifies whether the values of the X and Y properties of the two Point objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.op_Inequality(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point)">
            <summary>
            Compares two Point objects. The result specifies whether the values of the X or Y properties of the two Point objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.Plus">
            <summary>
            Unary plus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.op_UnaryPlus(ST4IVisionCoreNet.Point)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.Negate">
            <summary>
            Unary minus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.op_UnaryNegation(ST4IVisionCoreNet.Point)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.Add(ST4IVisionCoreNet.Point)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.op_Addition(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.Subtract(ST4IVisionCoreNet.Point)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.op_Subtraction(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.Multiply(System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.op_Multiply(ST4IVisionCoreNet.Point,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.Equals(ST4IVisionCoreNet.Point)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point.ToString">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point.Distance(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.DistanceTo(ST4IVisionCoreNet.Point)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.DotProduct(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.DotProduct(ST4IVisionCoreNet.Point)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.CrossProduct(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point.CrossProduct(ST4IVisionCoreNet.Point)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Point2d">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point2d.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point2d.Y">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.op_Equality(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.op_Inequality(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.Plus">
            <summary>
            Unary plus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.op_UnaryPlus(ST4IVisionCoreNet.Point2d)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.Negate">
            <summary>
            Unary minus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.op_UnaryNegation(ST4IVisionCoreNet.Point2d)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.Add(ST4IVisionCoreNet.Point2d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.op_Addition(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.Subtract(ST4IVisionCoreNet.Point2d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.op_Subtraction(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.Multiply(System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.op_Multiply(ST4IVisionCoreNet.Point2d,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.Equals(ST4IVisionCoreNet.Point2d)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.ToString">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.Distance(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.DistanceTo(ST4IVisionCoreNet.Point2d)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.DotProduct(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.DotProduct(ST4IVisionCoreNet.Point2d)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.CrossProduct(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2d.CrossProduct(ST4IVisionCoreNet.Point2d)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Point2f">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point2f.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point2f.Y">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.#ctor(System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.op_Equality(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.op_Inequality(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.Plus">
            <summary>
            Unary plus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.op_UnaryPlus(ST4IVisionCoreNet.Point2f)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.Negate">
            <summary>
            Unary minus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.op_UnaryNegation(ST4IVisionCoreNet.Point2f)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.Add(ST4IVisionCoreNet.Point2f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.op_Addition(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.Subtract(ST4IVisionCoreNet.Point2f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.op_Subtraction(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.Multiply(System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.op_Multiply(ST4IVisionCoreNet.Point2f,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.Equals(ST4IVisionCoreNet.Point2f)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.ToString">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.Distance(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.DistanceTo(ST4IVisionCoreNet.Point2f)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.DotProduct(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.DotProduct(ST4IVisionCoreNet.Point2f)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.CrossProduct(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point2f.CrossProduct(ST4IVisionCoreNet.Point2f)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Point3d">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3d.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3d.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3d.Z">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.op_Equality(ST4IVisionCoreNet.Point3d,ST4IVisionCoreNet.Point3d)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.op_Inequality(ST4IVisionCoreNet.Point3d,ST4IVisionCoreNet.Point3d)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.op_UnaryPlus(ST4IVisionCoreNet.Point3d)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.Plus">
            <summary>
            Unary plus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.op_UnaryNegation(ST4IVisionCoreNet.Point3d)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.Negate">
            <summary>
            Unary minus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.op_Addition(ST4IVisionCoreNet.Point3d,ST4IVisionCoreNet.Point3d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.Add(ST4IVisionCoreNet.Point3d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.op_Subtraction(ST4IVisionCoreNet.Point3d,ST4IVisionCoreNet.Point3d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.Subtract(ST4IVisionCoreNet.Point3d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.op_Multiply(ST4IVisionCoreNet.Point3d,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.Multiply(System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.Equals(ST4IVisionCoreNet.Point3d)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3d.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Point3f">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3f.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3f.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3f.Z">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.op_Equality(ST4IVisionCoreNet.Point3f,ST4IVisionCoreNet.Point3f)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.op_Inequality(ST4IVisionCoreNet.Point3f,ST4IVisionCoreNet.Point3f)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.Plus">
            <summary>
            Unary plus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.op_UnaryPlus(ST4IVisionCoreNet.Point3f)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.Negate">
            <summary>
            Unary minus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.op_UnaryNegation(ST4IVisionCoreNet.Point3f)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.Add(ST4IVisionCoreNet.Point3f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.op_Addition(ST4IVisionCoreNet.Point3f,ST4IVisionCoreNet.Point3f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.Subtract(ST4IVisionCoreNet.Point3f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.op_Subtraction(ST4IVisionCoreNet.Point3f,ST4IVisionCoreNet.Point3f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.Multiply(System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.op_Multiply(ST4IVisionCoreNet.Point3f,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.Equals(ST4IVisionCoreNet.Point3f)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3f.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Point3i">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3i.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3i.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Point3i.Z">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.op_Equality(ST4IVisionCoreNet.Point3i,ST4IVisionCoreNet.Point3i)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.op_Inequality(ST4IVisionCoreNet.Point3i,ST4IVisionCoreNet.Point3i)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.op_UnaryPlus(ST4IVisionCoreNet.Point3i)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.Plus">
            <summary>
            Unary plus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.op_UnaryNegation(ST4IVisionCoreNet.Point3i)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.Negate">
            <summary>
            Unary minus operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.op_Addition(ST4IVisionCoreNet.Point3i,ST4IVisionCoreNet.Point3i)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.Add(ST4IVisionCoreNet.Point3i)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.op_Subtraction(ST4IVisionCoreNet.Point3i,ST4IVisionCoreNet.Point3i)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.Subtract(ST4IVisionCoreNet.Point3i)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.op_Multiply(ST4IVisionCoreNet.Point3i,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.Multiply(System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.Equals(ST4IVisionCoreNet.Point3i)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Point3i.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Range">
            <summary>
            Template class specifying a continuous subsequence (slice) of a sequence.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Range.Start">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Range.End">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="P:ST4IVisionCoreNet.Range.All">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Range.Equals(ST4IVisionCoreNet.Range)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Range.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Range.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Range.op_Equality(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Range.op_Inequality(ST4IVisionCoreNet.Range,ST4IVisionCoreNet.Range)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Rangef">
            <summary>
            float Range class
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rangef.Start">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rangef.End">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Rangef.#ctor(System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rangef.ToRange">
            <summary>
            Convert to Range
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rangef.op_Implicit(ST4IVisionCoreNet.Rangef)~ST4IVisionCoreNet.Range">
            <summary>
            Implicit operator (Range)this
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Rangef.All">
            <summary>
            Range(int.MinValue, int.MaxValue)
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Rect">
            <summary>
            Stores a set of four integers that represent the location and size of a rectangle
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect.Height">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect.Empty">
            <summary>
            Represents a Rect structure with its properties left uninitialized. 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the Rectangle class with the specified location and size.
            </summary>
            <param name="x">The x-coordinate of the upper-left corner of the rectangle.</param>
            <param name="y">The y-coordinate of the upper-left corner of the rectangle.</param>
            <param name="width">The width of the rectangle.</param>
            <param name="height">The height of the rectangle.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.#ctor(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Size)">
            <summary>
            Initializes a new instance of the Rectangle class with the specified location and size.
            </summary>
            <param name="location">A Point that represents the upper-left corner of the rectangular region.</param>
            <param name="size">A Size that represents the width and height of the rectangular region.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.FromLTRB(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Rectangle structure with the specified edge locations.
            </summary>
            <param name="left">The x-coordinate of the upper-left corner of this Rectangle structure.</param>
            <param name="top">The y-coordinate of the upper-left corner of this Rectangle structure.</param>
            <param name="right">The x-coordinate of the lower-right corner of this Rectangle structure.</param>
            <param name="bottom">The y-coordinate of the lower-right corner of this Rectangle structure.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.op_Equality(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Rect)">
            <summary>
            Compares two Rect objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.op_Inequality(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Rect)">
            <summary>
            Compares two Rect objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.op_Addition(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Point)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Add(ST4IVisionCoreNet.Point)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.op_Subtraction(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Point)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Subtract(ST4IVisionCoreNet.Point)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.op_Addition(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Size)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Add(ST4IVisionCoreNet.Size)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.op_Subtraction(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Size)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Subtract(ST4IVisionCoreNet.Size)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.op_BitwiseAnd(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Rect)">
            <summary>
            Determines the Rect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.op_BitwiseOr(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Rect)">
            <summary>
            Gets a Rect structure that contains the union of two Rect structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect.Top">
            <summary>
            Gets the y-coordinate of the top edge of this Rect structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect.Bottom">
            <summary>
            Gets the y-coordinate that is the sum of the Y and Height property values of this Rect structure.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect.Left">
            <summary>
            Gets the x-coordinate of the left edge of this Rect structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect.Right">
            <summary>
            Gets the x-coordinate that is the sum of X and Width property values of this Rect structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect.Location">
            <summary>
            Coordinate of the left-most rectangle corner [Point(X, Y)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect.Size">
            <summary>
            Size of the rectangle [CvSize(Width, Height)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect.TopLeft">
            <summary>
            Coordinate of the left-most rectangle corner [Point(X, Y)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect.BottomRight">
            <summary>
            Coordinate of the right-most rectangle corner [Point(X+Width, Y+Height)]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Contains(System.Int32,System.Int32)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="x">x-coordinate of the point</param>
            <param name="y">y-coordinate of the point</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Contains(ST4IVisionCoreNet.Point)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="pt">point</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Contains(ST4IVisionCoreNet.Rect)">
            <summary>
            Determines if the specified rectangle is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="rect">rectangle</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Inflate(System.Int32,System.Int32)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="width">The amount to inflate this Rectangle horizontally. </param>
            <param name="height">The amount to inflate this Rectangle vertically. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Inflate(ST4IVisionCoreNet.Size)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="size">The amount to inflate this rectangle. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Inflate(ST4IVisionCoreNet.Rect,System.Int32,System.Int32)">
            <summary>
            Creates and returns an inflated copy of the specified Rect structure.
            </summary>
            <param name="rect">The Rectangle with which to start. This rectangle is not modified. </param>
            <param name="x">The amount to inflate this Rectangle horizontally. </param>
            <param name="y">The amount to inflate this Rectangle vertically. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Intersect(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Rect)">
            <summary>
            Determines the Rect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Intersect(ST4IVisionCoreNet.Rect)">
            <summary>
            Determines the Rect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="rect">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.IntersectsWith(ST4IVisionCoreNet.Rect)">
            <summary>
            Determines if this rectangle intersects with rect. 
            </summary>
            <param name="rect">Rectangle</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Union(ST4IVisionCoreNet.Rect)">
            <summary>
            Gets a Rect structure that contains the union of two Rect structures. 
            </summary>
            <param name="rect">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Union(ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Rect)">
            <summary>
            Gets a Rect structure that contains the union of two Rect structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Equals(ST4IVisionCoreNet.Rect)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Rect2d">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect2d.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect2d.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect2d.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect2d.Height">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect2d.Empty">
            <summary>
            Represents a Rect2d structure with its properties left uninitialized. 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.#ctor(ST4IVisionCoreNet.Point2d,ST4IVisionCoreNet.Size2d)">
            <summary>
            Constructor
            </summary>
            <param name="location"></param>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.FromLTRB(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.op_Equality(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Rect2d)">
            <summary>
            Compares two Rect2d objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.op_Inequality(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Rect2d)">
            <summary>
            Compares two Rect2d objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.op_Addition(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Add(ST4IVisionCoreNet.Point2d)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.op_Subtraction(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Point2d)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Subtract(ST4IVisionCoreNet.Point2d)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.op_Addition(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Size2d)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Add(ST4IVisionCoreNet.Size2d)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.op_Subtraction(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Size2d)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Subtract(ST4IVisionCoreNet.Size2d)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.op_BitwiseAnd(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Rect2d)">
            <summary>
            Determines the Rect2d structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.op_BitwiseOr(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Rect2d)">
            <summary>
            Gets a Rect2d structure that contains the union of two Rect2d structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2d.Top">
            <summary>
            Gets the y-coordinate of the top edge of this Rect2d structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2d.Bottom">
            <summary>
            Gets the y-coordinate that is the sum of the Y and Height property values of this Rect2d structure.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2d.Left">
            <summary>
            Gets the x-coordinate of the left edge of this Rect2d structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2d.Right">
            <summary>
            Gets the x-coordinate that is the sum of X and Width property values of this Rect2d structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2d.Location">
            <summary>
            Coordinate of the left-most rectangle corner [Point2d(X, Y)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2d.Size">
            <summary>
            Size of the rectangle [CvSize(Width, Height)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2d.TopLeft">
            <summary>
            Coordinate of the left-most rectangle corner [Point2d(X, Y)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2d.BottomRight">
            <summary>
            Coordinate of the right-most rectangle corner [Point2d(X+Width, Y+Height)]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.ToRect">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Contains(System.Double,System.Double)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="x">x-coordinate of the point</param>
            <param name="y">y-coordinate of the point</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Contains(ST4IVisionCoreNet.Point2d)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="pt">point</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Contains(ST4IVisionCoreNet.Rect2d)">
            <summary>
            Determines if the specified rectangle is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="rect">rectangle</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Inflate(System.Double,System.Double)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="width">The amount to inflate this Rectangle horizontally. </param>
            <param name="height">The amount to inflate this Rectangle vertically. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Inflate(ST4IVisionCoreNet.Size2d)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="size">The amount to inflate this rectangle. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Inflate(ST4IVisionCoreNet.Rect,System.Int32,System.Int32)">
            <summary>
            Creates and returns an inflated copy of the specified Rect2d structure.
            </summary>
            <param name="rect">The Rectangle with which to start. This rectangle is not modified. </param>
            <param name="x">The amount to inflate this Rectangle horizontally. </param>
            <param name="y">The amount to inflate this Rectangle vertically. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Intersect(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Rect2d)">
            <summary>
            Determines the Rect2d structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Intersect(ST4IVisionCoreNet.Rect2d)">
            <summary>
            Determines the Rect2d structure that represents the intersection of two rectangles. 
            </summary>
            <param name="rect">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.IntersectsWith(ST4IVisionCoreNet.Rect2d)">
            <summary>
            Determines if this rectangle intersects with rect. 
            </summary>
            <param name="rect">Rectangle</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Union(ST4IVisionCoreNet.Rect2d)">
            <summary>
            Gets a Rect2d structure that contains the union of two Rect2d structures. 
            </summary>
            <param name="rect">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Union(ST4IVisionCoreNet.Rect2d,ST4IVisionCoreNet.Rect2d)">
            <summary>
            Gets a Rect2d structure that contains the union of two Rect2d structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Equals(ST4IVisionCoreNet.Rect2d)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2d.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Rect2f">
            <summary>
            A rectangle with float type coordinates in 2D space
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Rect2f.Empty">
            <summary>
            Represents a Rect2f structure with its properties left uninitialized. 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.#ctor(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Size2f)">
            <summary>
            Constructor
            </summary>
            <param name="location"></param>
            <param name="size"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.FromLTRB(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.op_Equality(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Rect2f)">
            <summary>
            Compares two Rect2f objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.op_Inequality(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Rect2f)">
            <summary>
            Compares two Rect2f objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Add(ST4IVisionCoreNet.Point2f)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.op_Addition(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Subtract(ST4IVisionCoreNet.Point2f)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.op_Subtraction(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Point2f)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Add(ST4IVisionCoreNet.Size2f)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.op_Addition(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Size2f)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Subtract(ST4IVisionCoreNet.Size2f)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.op_Subtraction(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Size2f)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.op_BitwiseAnd(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Rect2f)">
            <summary>
            Determines the Rect2f structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.op_BitwiseOr(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Rect2f)">
            <summary>
            Gets a Rect2f structure that contains the union of two Rect2f structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2f.Top">
            <summary>
            Gets the y-coordinate of the top edge of this Rect2f structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2f.Bottom">
            <summary>
            Gets the y-coordinate that is the sum of the Y and Height property values of this Rect2f structure.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2f.Left">
            <summary>
            Gets the x-coordinate of the left edge of this Rect2f structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2f.Right">
            <summary>
            Gets the x-coordinate that is the sum of X and Width property values of this Rect2f structure. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2f.Location">
            <summary>
            Coordinate of the left-most rectangle corner [Point2f(X, Y)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2f.Size">
            <summary>
            Size of the rectangle [CvSize(Width, Height)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2f.TopLeft">
            <summary>
            Coordinate of the left-most rectangle corner [Point2f(X, Y)]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Rect2f.BottomRight">
            <summary>
            Coordinate of the right-most rectangle corner [Point2f(X+Width, Y+Height)]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Contains(System.Single,System.Single)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="x">x-coordinate of the point</param>
            <param name="y">y-coordinate of the point</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Contains(ST4IVisionCoreNet.Point2f)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="pt">point</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Contains(ST4IVisionCoreNet.Rect2f)">
            <summary>
            Determines if the specified rectangle is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="rect">rectangle</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Inflate(System.Single,System.Single)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="width">The amount to inflate this Rectangle horizontally. </param>
            <param name="height">The amount to inflate this Rectangle vertically. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Inflate(ST4IVisionCoreNet.Size2f)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="size">The amount to inflate this rectangle. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Inflate(ST4IVisionCoreNet.Rect,System.Int32,System.Int32)">
            <summary>
            Creates and returns an inflated copy of the specified Rect2f structure.
            </summary>
            <param name="rect">The Rectangle with which to start. This rectangle is not modified. </param>
            <param name="x">The amount to inflate this Rectangle horizontally. </param>
            <param name="y">The amount to inflate this Rectangle vertically. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Intersect(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Rect2f)">
            <summary>
            Determines the Rect2f structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Intersect(ST4IVisionCoreNet.Rect2f)">
            <summary>
            Determines the Rect2f structure that represents the intersection of two rectangles. 
            </summary>
            <param name="rect">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.IntersectsWith(ST4IVisionCoreNet.Rect2f)">
            <summary>
            Determines if this rectangle intersects with rect. 
            </summary>
            <param name="rect">Rectangle</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Union(ST4IVisionCoreNet.Rect2f)">
            <summary>
            Gets a Rect2f structure that contains the union of two Rect2f structures. 
            </summary>
            <param name="rect">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Union(ST4IVisionCoreNet.Rect2f,ST4IVisionCoreNet.Rect2f)">
            <summary>
            Gets a Rect2f structure that contains the union of two Rect2f structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Equals(ST4IVisionCoreNet.Rect2f)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Rect2f.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.RotatedRect">
            <summary>
            The class represents rotated (i.e. not up-right) rectangles on a plane.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RotatedRect.Center">
            <summary>
            the rectangle mass center
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RotatedRect.Size">
            <summary>
            width and height of the rectangle
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RotatedRect.Angle">
            <summary>
            the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.RotatedRect.#ctor(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Size2f,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="center"></param>
            <param name="size"></param>
            <param name="angle"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.RotatedRect.Points">
            <summary>
            returns 4 vertices of the rectangle
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RotatedRect.BoundingRect">
            <summary>
            returns the minimal up-right rectangle containing the rotated rectangle
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Scalar">
            <summary>
            Template class for a 4-element vector derived from Vec.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Val0">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Val1">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Val2">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Val3">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Scalar.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.#ctor(System.Double)">
            <summary>
            
            </summary>
            <param name="v0"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.FromRgb(System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.RandomColor">
            <summary>
            Gets random color
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.RandomColor(System.Security.Cryptography.RandomNumberGenerator)">
            <summary>
            Gets random color
            </summary>
            <param name="rng">.NET random number generator. This method uses Random.NextBytes()</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.Equals(ST4IVisionCoreNet.Scalar)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.ToString">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.op_Equality(ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Scalar)">
            <summary>
            
            </summary>
            <param name="s1"></param>
            <param name="s2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.op_Inequality(ST4IVisionCoreNet.Scalar,ST4IVisionCoreNet.Scalar)">
            <summary>
            
            </summary>
            <param name="s1"></param>
            <param name="s2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.All(System.Double)">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.Mul(ST4IVisionCoreNet.Scalar,System.Double)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.Mul(ST4IVisionCoreNet.Scalar)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.Conj">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.IsReal">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Scalar.ToVec3b">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.AliceBlue">
            <summary>
            #F0F8FF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.AntiqueWhite">
            <summary>
            #FAEBD7 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Aqua">
            <summary>
            #00FFFF 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Aquamarine">
            <summary>
            #7FFFD4
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Azure">
            <summary>
            #F0FFFF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Beige">
            <summary>
            #F5F5DC
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Bisque">
            <summary>
            #FFE4C4
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Black">
            <summary>
            #000000
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.BlanchedAlmond">
            <summary>
            #FFEBCD
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Blue">
            <summary>
            #0000FF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.BlueViolet">
            <summary>
            #8A2BE2
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Brown">
            <summary>
            #A52A2A 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.BurlyWood">
            <summary>
            #DEB887
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.CadetBlue">
            <summary>
            #5F9EA0 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Chartreuse">
            <summary>
            #7FFF00 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Chocolate">
            <summary>
            #D2691E
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Coral">
            <summary>
            #FF7F50
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.CornflowerBlue">
            <summary>
            #6495ED
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Cornsilk">
            <summary>
            #FFF8DC
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Crimson">
            <summary>
            #DC143C
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Cyan">
            <summary>
            #00FFFF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkBlue">
            <summary>
            #00008B
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkCyan">
            <summary>
            #008B8B
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkGoldenrod">
            <summary>
            #B8860B
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkGray">
            <summary>
            #A9A9A9
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkGreen">
            <summary>
            #006400
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkKhaki">
            <summary>
            #BDB76B
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkMagenta">
            <summary>
            #8B008B
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkOliveGreen">
            <summary>
            #556B2F
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkOrange">
            <summary>
            #FF8C00 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkOrchid">
            <summary>
            #9932CC
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkRed">
            <summary>
            #8B0000
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkSalmon">
            <summary>
            #E9967A
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkSeaGreen">
            <summary>
            #8FBC8F
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkSlateBlue">
            <summary>
            #483D8B
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkSlateGray">
            <summary>
            #2F4F4F
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkTurquoise">
            <summary>
            #00CED1 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DarkViolet">
            <summary>
            #9400D3
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DeepPink">
            <summary>
            #FF1493
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DeepSkyBlue">
            <summary>
            #00BFFF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DimGray">
            <summary>
            #696969
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.DodgerBlue">
            <summary>
            #1E90FF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Firebrick">
            <summary>
            #B22222
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.FloralWhite">
            <summary>
            #FFFAF0 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.ForestGreen">
            <summary>
            #228B22
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Fuchsia">
            <summary>
            #FF00FF 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Gainsboro">
            <summary>
            #DCDCDC
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.GhostWhite">
            <summary>
            #F8F8FF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Gold">
            <summary>
            #FFD700
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Goldenrod">
            <summary>
            #DAA520
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Gray">
            <summary>
            #808080
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Green">
            <summary>
            #008000
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.GreenYellow">
            <summary>
            #ADFF2F
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Honeydew">
            <summary>
            #F0FFF0
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.HotPink">
            <summary>
            #FF69B4
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.IndianRed">
            <summary>
            #CD5C5C
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Indigo">
            <summary>
            #4B0082
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Ivory">
            <summary>
            #FFFFF0
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Khaki">
            <summary>
            #F0E68C
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Lavender">
            <summary>
            #E6E6FA
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LavenderBlush">
            <summary>
            #FFF0F5 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LawnGreen">
            <summary>
            #7CFC00
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LemonChiffon">
            <summary>
            #FFFACD
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightBlue">
            <summary>
            #ADD8E6
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightCoral">
            <summary>
            #F08080
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightCyan">
            <summary>
            #E0FFFF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightGoldenrodYellow">
            <summary>
            #FAFAD2
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightGray">
            <summary>
            #D3D3D3
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightGreen">
            <summary>
            #90EE90 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightPink">
            <summary>
            #FFB6C1
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightSalmon">
            <summary>
            #FFA07A
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightSeaGreen">
            <summary>
            #20B2AA
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightSkyBlue">
            <summary>
            #87CEFA 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightSlateGray">
            <summary>
            #778899
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightSteelBlue">
            <summary>
            #B0C4DE 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LightYellow">
            <summary>
            #FFFFE0
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Lime">
            <summary>
            #00FF00
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.LimeGreen">
            <summary>
            #32CD32
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Linen">
            <summary>
            #FAF0E6
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Magenta">
            <summary>
            #FF00FF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Maroon">
            <summary>
            #800000
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumAquamarine">
            <summary>
            #66CDAA
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumBlue">
            <summary>
            #0000CD
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumOrchid">
            <summary>
            #BA55D3
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumPurple">
            <summary>
            #9370DB
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumSeaGreen">
            <summary>
            #3CB371
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumSlateBlue">
            <summary>
            #7B68EE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumSpringGreen">
            <summary>
            #00FA9A 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumTurquoise">
            <summary>
            #48D1CC
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MediumVioletRed">
            <summary>
            #C71585
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MidnightBlue">
            <summary>
            #191970
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MintCream">
            <summary>
            #F5FFFA
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.MistyRose">
            <summary>
            #FFE4E1
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Moccasin">
            <summary>
            #FFE4B5
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.NavajoWhite">
            <summary>
            #FFDEAD
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Navy">
            <summary>
            #000080
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.OldLace">
            <summary>
            #FDF5E6
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Olive">
            <summary>
            #808000 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.OliveDrab">
            <summary>
            #6B8E23
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Orange">
            <summary>
            #FFA500
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.OrangeRed">
            <summary>
            #FF4500
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Orchid">
            <summary>
            #DA70D6
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.PaleGoldenrod">
            <summary>
            #EEE8AA 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.PaleGreen">
            <summary>
            #98FB98
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.PaleTurquoise">
            <summary>
            #AFEEEE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.PaleVioletRed">
            <summary>
            #DB7093
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.PapayaWhip">
            <summary>
            #FFEFD5 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.PeachPuff">
            <summary>
            #FFDAB9
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Peru">
            <summary>
            #CD853F
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Pink">
            <summary>
            #FFC0CB
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Plum">
            <summary>
            #DDA0DD
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.PowderBlue">
            <summary>
            #B0E0E6
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Purple">
            <summary>
            #800080
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Red">
            <summary>
            #FF0000
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.RosyBrown">
            <summary>
            #BC8F8F
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.RoyalBlue">
            <summary>
            #4169E1
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SaddleBrown">
            <summary>
            #8B4513
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Salmon">
            <summary>
            #FA8072
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SandyBrown">
            <summary>
            #F4A460
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SeaGreen">
            <summary>
            #2E8B57
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SeaShell">
            <summary>
            #FFF5EE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Sienna">
            <summary>
            #A0522D
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Silver">
            <summary>
            #C0C0C0 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SkyBlue">
            <summary>
            #87CEEB
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SlateBlue">
            <summary>
            #6A5ACD
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SlateGray">
            <summary>
            #708090
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Snow">
            <summary>
            #FFFAFA
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SpringGreen">
            <summary>
            #00FF7F
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.SteelBlue">
            <summary>
            #4682B4
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Tan">
            <summary>
            #D2B48C
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Teal">
            <summary>
            #008080
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Thistle">
            <summary>
            #D8BFD8
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Tomato">
            <summary>
            #FF6347
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Turquoise">
            <summary>
            #40E0D0
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Violet">
            <summary>
            #EE82EE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Wheat">
            <summary>
            #F5DEB3
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.White">
            <summary>
            #FFFFFF
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.WhiteSmoke">
            <summary>
            #F5F5F5
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.Yellow">
            <summary>
            #FFFF00
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Scalar.YellowGreen">
            <summary>
            #9ACD32
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Size">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Size.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Size.Height">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Size.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Size.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="F:ST4IVisionCoreNet.Size.Zero">
            <summary>
            Zero size
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Size.op_Equality(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Size)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Size.op_Inequality(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Size)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Size.Equals(ST4IVisionCoreNet.Size)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Size2d">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Size2d.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Size2d.Height">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2d.#ctor(System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2d.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2d.op_Equality(ST4IVisionCoreNet.Size2d,ST4IVisionCoreNet.Size2d)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2d.op_Inequality(ST4IVisionCoreNet.Size2d,ST4IVisionCoreNet.Size2d)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2d.Equals(ST4IVisionCoreNet.Size2d)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size2d.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size2d.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size2d.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Size2f">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Size2f.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Size2f.Height">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2f.#ctor(System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2f.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2f.op_Equality(ST4IVisionCoreNet.Size2f,ST4IVisionCoreNet.Size2f)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2f.op_Inequality(ST4IVisionCoreNet.Size2f,ST4IVisionCoreNet.Size2f)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Size2f.Equals(ST4IVisionCoreNet.Size2f)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size2f.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size2f.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Size2f.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.TermCriteria">
            <summary>
            The class defining termination criteria for iterative algorithms.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TermCriteria.Type">
            <summary>
            the type of termination criteria: COUNT, EPS or COUNT + EPS
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TermCriteria.MaxCount">
            <summary>
            the maximum number of iterations/elements
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TermCriteria.Epsilon">
            <summary>
            the desired accuracy
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TermCriteria.#ctor(ST4IVisionCoreNet.CriteriaTypes,System.Int32,System.Double)">
            <summary>
            full constructor
            </summary>
            <param name="type"></param>
            <param name="maxCount"></param>
            <param name="epsilon"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.TermCriteria.Both(System.Int32,System.Double)">
            <summary>
            full constructor with both type (count | epsilon)
            </summary>
            <param name="maxCount"></param>
            <param name="epsilon"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.IVec">
            <summary>
            Vec empty interface
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.IVec`2">
            <summary>
            Vec** interface
            </summary>
            <typeparam name="TSelf"></typeparam>
            <typeparam name="TElem"></typeparam>
        </member>
        <member name="M:ST4IVisionCoreNet.IVec`2.Add(`0)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.IVec`2.Subtract(`0)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.IVec`2.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.IVec`2.Divide(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.IVec`2.Item(System.Int32)">
            <summary>
            indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Vec2b">
            <summary>
            2-Tuple of byte (System.Byte)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2b.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2b.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.Deconstruct(System.Byte@,System.Byte@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.All(System.Byte)">
            <summary>
            returns a Vec with all elements set to v0
            </summary>
            <param name="v0"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.Add(ST4IVisionCoreNet.Vec2b)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.Subtract(ST4IVisionCoreNet.Vec2b)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec2b.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.Equals(ST4IVisionCoreNet.Vec2b)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.op_Equality(ST4IVisionCoreNet.Vec2b,ST4IVisionCoreNet.Vec2b)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.op_Inequality(ST4IVisionCoreNet.Vec2b,ST4IVisionCoreNet.Vec2b)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2b.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec2d">
            <summary>
            2-Tuple of double (System.Double)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2d.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2d.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.Deconstruct(System.Double@,System.Double@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.#ctor(System.Double,System.Double)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.Add(ST4IVisionCoreNet.Vec2d)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.Subtract(ST4IVisionCoreNet.Vec2d)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec2d.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.Equals(ST4IVisionCoreNet.Vec2d)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.op_Equality(ST4IVisionCoreNet.Vec2d,ST4IVisionCoreNet.Vec2d)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.op_Inequality(ST4IVisionCoreNet.Vec2d,ST4IVisionCoreNet.Vec2d)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2d.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec2f">
            <summary>
            2-Tuple of float (System.Single)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2f.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2f.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.Deconstruct(System.Single@,System.Single@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.#ctor(System.Single,System.Single)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.Add(ST4IVisionCoreNet.Vec2f)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.Subtract(ST4IVisionCoreNet.Vec2f)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec2f.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.Equals(ST4IVisionCoreNet.Vec2f)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.op_Equality(ST4IVisionCoreNet.Vec2f,ST4IVisionCoreNet.Vec2f)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.op_Inequality(ST4IVisionCoreNet.Vec2f,ST4IVisionCoreNet.Vec2f)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2f.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec2i">
            <summary>
            2-Tuple of int (System.Int32)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2i.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2i.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.Deconstruct(System.Int32@,System.Int32@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.Add(ST4IVisionCoreNet.Vec2i)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.Subtract(ST4IVisionCoreNet.Vec2i)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec2i.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.Equals(ST4IVisionCoreNet.Vec2i)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.op_Equality(ST4IVisionCoreNet.Vec2i,ST4IVisionCoreNet.Vec2i)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.op_Inequality(ST4IVisionCoreNet.Vec2i,ST4IVisionCoreNet.Vec2i)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2i.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec2s">
            <summary>
            2-Tuple of short (System.Int16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2s.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2s.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.Deconstruct(System.Int16@,System.Int16@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.#ctor(System.Int16,System.Int16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.Add(ST4IVisionCoreNet.Vec2s)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.Subtract(ST4IVisionCoreNet.Vec2s)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec2s.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.Equals(ST4IVisionCoreNet.Vec2s)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.op_Equality(ST4IVisionCoreNet.Vec2s,ST4IVisionCoreNet.Vec2s)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.op_Inequality(ST4IVisionCoreNet.Vec2s,ST4IVisionCoreNet.Vec2s)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2s.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec2w">
            <summary>
            2-Tuple of ushort (System.UInt16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2w.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec2w.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.Deconstruct(System.UInt16@,System.UInt16@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.#ctor(System.UInt16,System.UInt16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.Add(ST4IVisionCoreNet.Vec2w)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.Subtract(ST4IVisionCoreNet.Vec2w)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec2w.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.Equals(ST4IVisionCoreNet.Vec2w)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.op_Equality(ST4IVisionCoreNet.Vec2w,ST4IVisionCoreNet.Vec2w)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.op_Inequality(ST4IVisionCoreNet.Vec2w,ST4IVisionCoreNet.Vec2w)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec2w.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec3b">
            <summary>
            3-Tuple of byte (System.Byte)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3b.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3b.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3b.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.Deconstruct(System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.Add(ST4IVisionCoreNet.Vec3b)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.Subtract(ST4IVisionCoreNet.Vec3b)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec3b.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.Equals(ST4IVisionCoreNet.Vec3b)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.op_Equality(ST4IVisionCoreNet.Vec3b,ST4IVisionCoreNet.Vec3b)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.op_Inequality(ST4IVisionCoreNet.Vec3b,ST4IVisionCoreNet.Vec3b)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3b.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec3d">
            <summary>
            3-Tuple of double (System.Double)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3d.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3d.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3d.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.Deconstruct(System.Double@,System.Double@,System.Double@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.Add(ST4IVisionCoreNet.Vec3d)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.Subtract(ST4IVisionCoreNet.Vec3d)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec3d.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.Equals(ST4IVisionCoreNet.Vec3d)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.op_Equality(ST4IVisionCoreNet.Vec3d,ST4IVisionCoreNet.Vec3d)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.op_Inequality(ST4IVisionCoreNet.Vec3d,ST4IVisionCoreNet.Vec3d)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3d.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec3f">
            <summary>
            3-Tuple of float (System.Single)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3f.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3f.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3f.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.Deconstruct(System.Single@,System.Single@,System.Single@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.Add(ST4IVisionCoreNet.Vec3f)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.Subtract(ST4IVisionCoreNet.Vec3f)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec3f.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.Equals(ST4IVisionCoreNet.Vec3f)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.op_Equality(ST4IVisionCoreNet.Vec3f,ST4IVisionCoreNet.Vec3f)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.op_Inequality(ST4IVisionCoreNet.Vec3f,ST4IVisionCoreNet.Vec3f)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3f.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec3i">
            <summary>
            3-Tuple of int (System.Int32)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3i.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3i.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3i.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.Deconstruct(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.Add(ST4IVisionCoreNet.Vec3i)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.Subtract(ST4IVisionCoreNet.Vec3i)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec3i.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.Equals(ST4IVisionCoreNet.Vec3i)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.op_Equality(ST4IVisionCoreNet.Vec3i,ST4IVisionCoreNet.Vec3i)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.op_Inequality(ST4IVisionCoreNet.Vec3i,ST4IVisionCoreNet.Vec3i)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3i.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec3s">
            <summary>
            3-Tuple of short (System.Int16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3s.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3s.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3s.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.Deconstruct(System.Int16@,System.Int16@,System.Int16@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.#ctor(System.Int16,System.Int16,System.Int16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.Add(ST4IVisionCoreNet.Vec3s)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.Subtract(ST4IVisionCoreNet.Vec3s)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec3s.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.Equals(ST4IVisionCoreNet.Vec3s)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.op_Equality(ST4IVisionCoreNet.Vec3s,ST4IVisionCoreNet.Vec3s)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.op_Inequality(ST4IVisionCoreNet.Vec3s,ST4IVisionCoreNet.Vec3s)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3s.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec3w">
            <summary>
            3-Tuple of ushort (System.UInt16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3w.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3w.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec3w.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.Deconstruct(System.UInt16@,System.UInt16@,System.UInt16@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.#ctor(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.Add(ST4IVisionCoreNet.Vec3w)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.Subtract(ST4IVisionCoreNet.Vec3w)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec3w.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.Equals(ST4IVisionCoreNet.Vec3w)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.op_Equality(ST4IVisionCoreNet.Vec3w,ST4IVisionCoreNet.Vec3w)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.op_Inequality(ST4IVisionCoreNet.Vec3w,ST4IVisionCoreNet.Vec3w)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec3w.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec4b">
            <summary>
            4-Tuple of byte (System.Byte)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4b.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4b.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4b.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4b.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.Deconstruct(System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.Add(ST4IVisionCoreNet.Vec4b)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.Subtract(ST4IVisionCoreNet.Vec4b)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec4b.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.Equals(ST4IVisionCoreNet.Vec4b)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.op_Equality(ST4IVisionCoreNet.Vec4b,ST4IVisionCoreNet.Vec4b)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.op_Inequality(ST4IVisionCoreNet.Vec4b,ST4IVisionCoreNet.Vec4b)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4b.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec4d">
            <summary>
            4-Tuple of double (System.Double)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4d.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4d.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4d.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4d.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.Deconstruct(System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.Add(ST4IVisionCoreNet.Vec4d)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.Subtract(ST4IVisionCoreNet.Vec4d)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec4d.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.Equals(ST4IVisionCoreNet.Vec4d)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.op_Equality(ST4IVisionCoreNet.Vec4d,ST4IVisionCoreNet.Vec4d)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.op_Inequality(ST4IVisionCoreNet.Vec4d,ST4IVisionCoreNet.Vec4d)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4d.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec4f">
            <summary>
            4-Tuple of float (System.Single)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4f.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4f.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4f.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4f.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.Deconstruct(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.Add(ST4IVisionCoreNet.Vec4f)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.Subtract(ST4IVisionCoreNet.Vec4f)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec4f.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.Equals(ST4IVisionCoreNet.Vec4f)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.op_Equality(ST4IVisionCoreNet.Vec4f,ST4IVisionCoreNet.Vec4f)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.op_Inequality(ST4IVisionCoreNet.Vec4f,ST4IVisionCoreNet.Vec4f)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4f.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec4i">
            <summary>
            4-Tuple of int (System.Int32)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4i.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4i.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4i.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4i.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.Deconstruct(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.Add(ST4IVisionCoreNet.Vec4i)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.Subtract(ST4IVisionCoreNet.Vec4i)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec4i.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.Equals(ST4IVisionCoreNet.Vec4i)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.op_Equality(ST4IVisionCoreNet.Vec4i,ST4IVisionCoreNet.Vec4i)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.op_Inequality(ST4IVisionCoreNet.Vec4i,ST4IVisionCoreNet.Vec4i)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4i.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec4s">
            <summary>
            4-Tuple of short (System.Int16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4s.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4s.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4s.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4s.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.Deconstruct(System.Int16@,System.Int16@,System.Int16@,System.Int16@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.#ctor(System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.Add(ST4IVisionCoreNet.Vec4s)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.Subtract(ST4IVisionCoreNet.Vec4s)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec4s.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.Equals(ST4IVisionCoreNet.Vec4s)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.op_Equality(ST4IVisionCoreNet.Vec4s,ST4IVisionCoreNet.Vec4s)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.op_Inequality(ST4IVisionCoreNet.Vec4s,ST4IVisionCoreNet.Vec4s)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4s.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec4w">
            <summary>
            4-Tuple of ushort (System.UInt16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4w.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4w.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4w.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec4w.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.Deconstruct(System.UInt16@,System.UInt16@,System.UInt16@,System.UInt16@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.#ctor(System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.Add(ST4IVisionCoreNet.Vec4w)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.Subtract(ST4IVisionCoreNet.Vec4w)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec4w.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.Equals(ST4IVisionCoreNet.Vec4w)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.op_Equality(ST4IVisionCoreNet.Vec4w,ST4IVisionCoreNet.Vec4w)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.op_Inequality(ST4IVisionCoreNet.Vec4w,ST4IVisionCoreNet.Vec4w)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec4w.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec6b">
            <summary>
            6-Tuple of byte (System.Byte)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6b.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6b.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6b.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6b.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6b.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6b.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.Deconstruct(System.Byte@,System.Byte@,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.#ctor(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.Add(ST4IVisionCoreNet.Vec6b)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.Subtract(ST4IVisionCoreNet.Vec6b)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec6b.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.Equals(ST4IVisionCoreNet.Vec6b)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.op_Equality(ST4IVisionCoreNet.Vec6b,ST4IVisionCoreNet.Vec6b)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.op_Inequality(ST4IVisionCoreNet.Vec6b,ST4IVisionCoreNet.Vec6b)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6b.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec6d">
            <summary>
            6-Tuple of double (System.Double)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6d.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6d.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6d.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6d.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6d.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6d.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.Deconstruct(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.Add(ST4IVisionCoreNet.Vec6d)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.Subtract(ST4IVisionCoreNet.Vec6d)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec6d.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.Equals(ST4IVisionCoreNet.Vec6d)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.op_Equality(ST4IVisionCoreNet.Vec6d,ST4IVisionCoreNet.Vec6d)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.op_Inequality(ST4IVisionCoreNet.Vec6d,ST4IVisionCoreNet.Vec6d)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6d.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec6f">
            <summary>
            6-Tuple of float (System.Single)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6f.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6f.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6f.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6f.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6f.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6f.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.Deconstruct(System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.Add(ST4IVisionCoreNet.Vec6f)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.Subtract(ST4IVisionCoreNet.Vec6f)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec6f.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.Equals(ST4IVisionCoreNet.Vec6f)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.op_Equality(ST4IVisionCoreNet.Vec6f,ST4IVisionCoreNet.Vec6f)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.op_Inequality(ST4IVisionCoreNet.Vec6f,ST4IVisionCoreNet.Vec6f)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6f.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec6i">
            <summary>
            6-Tuple of int (System.Int32)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6i.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6i.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6i.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6i.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6i.Item4">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6i.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.Deconstruct(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.Add(ST4IVisionCoreNet.Vec6i)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.Subtract(ST4IVisionCoreNet.Vec6i)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec6i.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.Equals(ST4IVisionCoreNet.Vec6i)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.op_Equality(ST4IVisionCoreNet.Vec6i,ST4IVisionCoreNet.Vec6i)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.op_Inequality(ST4IVisionCoreNet.Vec6i,ST4IVisionCoreNet.Vec6i)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6i.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec6s">
            <summary>
            6-Tuple of short (System.Int16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6s.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6s.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6s.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6s.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6s.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6s.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.Deconstruct(System.Int16@,System.Int16@,System.Int16@,System.Int16@,System.Int16@,System.Int16@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.#ctor(System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.Add(ST4IVisionCoreNet.Vec6s)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.Subtract(ST4IVisionCoreNet.Vec6s)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec6s.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.Equals(ST4IVisionCoreNet.Vec6s)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.op_Equality(ST4IVisionCoreNet.Vec6s,ST4IVisionCoreNet.Vec6s)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.op_Inequality(ST4IVisionCoreNet.Vec6s,ST4IVisionCoreNet.Vec6s)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6s.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Vec6w">
            <summary>
            4-Tuple of ushort (System.UInt16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6w.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6w.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6w.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6w.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6w.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Vec6w.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.Deconstruct(System.UInt16@,System.UInt16@,System.UInt16@,System.UInt16@,System.UInt16@,System.UInt16@)">
            <summary>
            Deconstructing a Vector
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.#ctor(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.Add(ST4IVisionCoreNet.Vec6w)">
            <summary>
            this + other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.Subtract(ST4IVisionCoreNet.Vec6w)">
            <summary>
            this - other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.Multiply(System.Double)">
            <summary>
            this * alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.Divide(System.Double)">
            <summary>
            this / alpha
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Vec6w.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.Equals(ST4IVisionCoreNet.Vec6w)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.op_Equality(ST4IVisionCoreNet.Vec6w,ST4IVisionCoreNet.Vec6w)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.op_Inequality(ST4IVisionCoreNet.Vec6w,ST4IVisionCoreNet.Vec6w)">
            <summary> 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.Vec6w.ToString">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.SVD">
            <summary>
            Singular Value Decomposition class
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.#ctor">
            <summary>
            the default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.#ctor(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.SVD.Flags)">
            <summary>
            the constructor that performs SVD
            </summary>
            <param name="src"></param>
            <param name="flags"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.U">
            <summary>
            eigenvalues of the covariation matrix
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.W">
            <summary>
            eigenvalues of the covariation matrix
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.Vt">
            <summary>
            mean value subtracted before the projection and added after the back projection
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.Run(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.SVD.Flags)">
            <summary>
            the operator that performs SVD. The previously allocated SVD::u, SVD::w are SVD::vt are released.
            </summary>
            <param name="src"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.BackSubst(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            performs back substitution, so that dst is the solution or pseudo-solution of m*dst = rhs, where m is the decomposed matrix
            </summary>
            <param name="rhs"></param>
            <param name="dst"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.SVD.Flags)">
            <summary>
            decomposes matrix and stores the results to user-provided matrices
            </summary>
            <param name="src"></param>
            <param name="w"></param>
            <param name="u"></param>
            <param name="vt"></param>
            <param name="flags"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.SVD.Flags)">
            <summary>
            computes singular values of a matrix
            </summary>
            <param name="src"></param>
            <param name="w"></param>
            <param name="flags"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.BackSubst(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            performs back substitution
            </summary>
            <param name="w"></param>
            <param name="u"></param>
            <param name="vt"></param>
            <param name="rhs"></param>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SVD.SolveZ(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            finds dst = arg min_{|dst|=1} |m*dst|
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.SVD.Flags">
            <summary>
            Operation flags for SVD
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SVD.Flags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SVD.Flags.ModifyA">
            <summary>
            enables modification of matrix src1 during the operation. It speeds up the processing. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SVD.Flags.NoUV">
            <summary>
            indicates that only a vector of singular values `w` is to be processed, 
            while u and vt will be set to empty matrices
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SVD.Flags.FullUV">
            <summary>
            when the matrix is not square, by default the algorithm produces u and 
            vt matrices of sufficiently large size for the further A reconstruction; 
            if, however, FULL_UV flag is specified, u and vt will be full-size square 
            orthogonal matrices.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Dnn.Backend">
            <summary>
            Enum of computation backends supported by layers.
            </summary>
            <remarks>
            DNN_BACKEND_DEFAULT equals to DNN_BACKEND_INFERENCE_ENGINE if
            OpenCV is built with Intel's Inference Engine library or 
            DNN_BACKEND_OPENCV otherwise.
            </remarks>
        </member>
        <member name="T:ST4IVisionCoreNet.Dnn.CvDnn">
            <summary>
            cv::dnn functions
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromDarknet(System.String,System.String)">
            <summary>
            Reads a network model stored in Darknet (https://pjreddie.com/darknet/) model files.
            </summary>
            <param name="cfgFile">path to the .cfg file with text description of the network architecture.</param>
            <param name="darknetModel">path to the .weights file with learned network.</param>
            <returns>Network object that ready to do forward, throw an exception in failure cases.</returns>
            <remarks>This is shortcut consisting from DarknetImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromDarknet(System.Byte[],System.Byte[])">
            <summary>
            Reads a network model stored in Darknet (https://pjreddie.com/darknet/) model files from memory.
            </summary>
            <param name="bufferCfg">A buffer contains a content of .cfg file with text description of the network architecture.</param>
            <param name="bufferModel">A buffer contains a content of .weights file with learned network.</param>
            <returns></returns>
            <remarks>This is shortcut consisting from DarknetImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromDarknet(System.IO.Stream,System.IO.Stream)">
            <summary>
            Reads a network model stored in Darknet (https://pjreddie.com/darknet/) model files from stream.
            </summary>
            <param name="bufferCfg">A buffer contains a content of .cfg file with text description of the network architecture.</param>
            <param name="bufferModel">A buffer contains a content of .weights file with learned network.</param>
            <returns></returns>
            <remarks>This is shortcut consisting from DarknetImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromCaffe(System.String,System.String)">
            <summary>
            Reads a network model stored in Caffe model files.
            </summary>
            <param name="prototxt">path to the .prototxt file with text description of the network architecture.</param>
            <param name="caffeModel">path to the .caffemodel file with learned network.</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromCaffe(System.Byte[],System.Byte[])">
            <summary>
            Reads a network model stored in Caffe model files from memory.
            </summary>
            <param name="bufferProto">buffer containing the content of the .prototxt file</param>
            <param name="bufferModel">buffer containing the content of the .caffemodel file</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromCaffe(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a network model stored in Caffe model files from memory.
            </summary>
            <param name="bufferProto">buffer containing the content of the .prototxt file</param>
            <param name="bufferModel">buffer containing the content of the .caffemodel file</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromCaffe(System.IO.Stream,System.IO.Stream)">
            <summary>
            Reads a network model stored in Caffe model files from Stream.
            </summary>
            <param name="bufferProto">buffer containing the content of the .prototxt file</param>
            <param name="bufferModel">buffer containing the content of the .caffemodel file</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromTensorflow(System.String,System.String)">
            <summary>
            Reads a network model stored in Tensorflow model file.
            </summary>
            <param name="model">path to the .pb file with binary protobuf description of the network architecture</param>
            <param name="config">path to the .pbtxt file that contains text graph definition in protobuf format.</param>
            <returns>Resulting Net object is built by text graph using weights from a binary one that
            let us make it more flexible.</returns>
            <remarks>This is shortcut consisting from createTensorflowImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromTensorflow(System.Byte[],System.Byte[])">
            <summary>
            Reads a network model stored in Tensorflow model file from memory.
            </summary>
            <param name="bufferModel">buffer containing the content of the pb file</param>
            <param name="bufferConfig">buffer containing the content of the pbtxt file (optional)</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createTensorflowImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromTensorflow(System.IO.Stream,System.IO.Stream)">
            <summary>
            Reads a network model stored in Tensorflow model file from stream.
            </summary>
            <param name="bufferModel">buffer containing the content of the pb file</param>
            <param name="bufferConfig">buffer containing the content of the pbtxt file (optional)</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createTensorflowImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromTorch(System.String,System.Boolean)">
            <summary>
            Reads a network model stored in Torch model file.
            </summary>
            <param name="model"></param>
            <param name="isBinary"></param>
            <returns></returns>
            <remarks>This is shortcut consisting from createTorchImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNet(System.String,System.String,System.String)">
            <summary>
            Read deep learning network represented in one of the supported formats.
            
            This function automatically detects an origin framework of trained model 
            and calls an appropriate function such @ref readNetFromCaffe, @ref readNetFromTensorflow,
            </summary>
            <param name="model">Binary file contains trained weights. The following file
            *                  extensions are expected for models from different frameworks:
            *                  * `*.caffemodel` (Caffe, http://caffe.berkeleyvision.org/)
            *                  * `*.pb` (TensorFlow, https://www.tensorflow.org/)
            *                  * `*.t7` | `*.net` (Torch, http://torch.ch/)
            *                  * `*.weights` (Darknet, https://pjreddie.com/darknet/)
            *                  * `*.bin` (DLDT, https://software.intel.com/openvino-toolkit)</param>
            <param name="config">Text file contains network configuration. It could be a
            *                   file with the following extensions:
            *                  * `*.prototxt` (Caffe, http://caffe.berkeleyvision.org/)
            *                  * `*.pbtxt` (TensorFlow, https://www.tensorflow.org/)
            *                  * `*.cfg` (Darknet, https://pjreddie.com/darknet/)
            *                  * `*.xml` (DLDT, https://software.intel.com/openvino-toolkit)</param>
            <param name="framework">Explicit framework name tag to determine a format.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadTorchBlob(System.String,System.Boolean)">
            <summary>
            Loads blob which was serialized as torch.Tensor object of Torch7 framework. 
            </summary>
            <param name="fileName"></param>
            <param name="isBinary"></param>
            <returns></returns>
            <remarks>
            This function has the same limitations as createTorchImporter().
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromOnnx(System.String)">
            <summary>
            Reads a network model ONNX https://onnx.ai/ from memory
            </summary>
            <param name="onnxFile"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromOnnx(System.Byte[])">
            <summary>
            Reads a network model ONNX https://onnx.ai/ from memory
            </summary>
            <param name="onnxFileData">memory of the first byte of the buffer.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromOnnx(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a network model ONNX https://onnx.ai/ from memory
            </summary>
            <param name="onnxFileData">memory of the first byte of the buffer.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadNetFromOnnx(System.IO.Stream)">
            <summary>
            Reads a network model ONNX https://onnx.ai/  from stream.
            </summary>
            <param name="onnxFileStream">memory of the first byte of the buffer.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ReadTensorFromONNX(System.String)">
            <summary>
            Creates blob from .pb file.
            </summary>
            <param name="path">path to the .pb file with input tensor.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.BlobFromImage(ST4IVisionCoreNet.Mat,System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Scalar,System.Boolean,System.Boolean)">
            <summary>
            Creates 4-dimensional blob from image. Optionally resizes and crops @p image from center, 
            subtract @p mean values, scales values by @p scalefactor, swap Blue and Red channels.
            </summary>
            <param name="image">input image (with 1- or 3-channels).</param>
            <param name="scaleFactor">multiplier for @p image values.</param>
            <param name="size">spatial size for output image</param>
            <param name="mean">scalar with mean values which are subtracted from channels. Values are intended 
            to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true.</param>
            <param name="swapRB">flag which indicates that swap first and last channels in 3-channel image is necessary.</param>
            <param name="crop">flag which indicates whether image will be cropped after resize or not</param>
            <returns>4-dimansional Mat with NCHW dimensions order.</returns>
            <remarks>if @p crop is true, input image is resized so one side after resize is equal to corresponing 
            dimension in @p size and another one is equal or larger.Then, crop from the center is performed. 
            If @p crop is false, direct resize without cropping and preserving aspect ratio is performed.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.BlobFromImages(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.Scalar,System.Boolean,System.Boolean)">
            <summary>
            Creates 4-dimensional blob from series of images. Optionally resizes and 
            crops @p images from center, subtract @p mean values, scales values by @p scalefactor, swap Blue and Red channels.
            </summary>
            <param name="images">input images (all with 1- or 3-channels).</param>
            <param name="scaleFactor">multiplier for @p image values.</param>
            <param name="size">spatial size for output image</param>
            <param name="mean">scalar with mean values which are subtracted from channels. Values are intended 
            to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true.</param>
            <param name="swapRB">flag which indicates that swap first and last channels in 3-channel image is necessary.</param>
            <param name="crop">flag which indicates whether image will be cropped after resize or not</param>
            <returns>4-dimansional Mat with NCHW dimensions order.</returns>
            <remarks>if @p crop is true, input image is resized so one side after resize is equal to corresponing 
            dimension in @p size and another one is equal or larger.Then, crop from the center is performed. 
            If @p crop is false, direct resize without cropping and preserving aspect ratio is performed.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ShrinkCaffeModel(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Convert all weights of Caffe network to half precision floating point.
            </summary>
            <param name="src">Path to origin model from Caffe framework contains single 
            precision floating point weights(usually has `.caffemodel` extension).</param>
            <param name="dst">Path to destination model with updated weights.</param>
            <param name="layersTypes">Set of layers types which parameters will be converted.
            By default, converts only Convolutional and Fully-Connected layers' weights.</param>
            <remarks>
            Shrinked model has no origin float32 weights so it can't be used 
            in origin Caffe framework anymore.However the structure of data 
            is taken from NVidia's Caffe fork: https://github.com/NVIDIA/caffe.
            So the resulting model may be used there.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.WriteTextGraph(System.String,System.String)">
            <summary>
            Create a text representation for a binary network stored in protocol buffer format.
            </summary>
            <param name="model">A path to binary network.</param>
            <param name="output">A path to output text file to be created.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.NMSBoxes(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Rect},System.Collections.Generic.IEnumerable{System.Single},System.Single,System.Single,System.Int32[]@,System.Single,System.Int32)">
            <summary>
            Performs non maximum suppression given boxes and corresponding scores.
            </summary>
            <param name="bboxes">a set of bounding boxes to apply NMS.</param>
            <param name="scores">a set of corresponding confidences.</param>
            <param name="scoreThreshold">a threshold used to filter boxes by score.</param>
            <param name="nmsThreshold">a threshold used in non maximum suppression.</param>
            <param name="indices">the kept indices of bboxes after NMS.</param>
            <param name="eta">a coefficient in adaptive threshold formula</param>
            <param name="topK">if `&gt;0`, keep at most @p top_k picked indices.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.NMSBoxes(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Rect2d},System.Collections.Generic.IEnumerable{System.Single},System.Single,System.Single,System.Int32[]@,System.Single,System.Int32)">
            <summary>
            Performs non maximum suppression given boxes and corresponding scores.
            </summary>
            <param name="bboxes">a set of bounding boxes to apply NMS.</param>
            <param name="scores">a set of corresponding confidences.</param>
            <param name="scoreThreshold">a threshold used to filter boxes by score.</param>
            <param name="nmsThreshold">a threshold used in non maximum suppression.</param>
            <param name="indices">the kept indices of bboxes after NMS.</param>
            <param name="eta">a coefficient in adaptive threshold formula</param>
            <param name="topK">if `&gt;0`, keep at most @p top_k picked indices.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.NMSBoxes(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.RotatedRect},System.Collections.Generic.IEnumerable{System.Single},System.Single,System.Single,System.Int32[]@,System.Single,System.Int32)">
            <summary>
            Performs non maximum suppression given boxes and corresponding scores.
            </summary>
            <param name="bboxes">a set of bounding boxes to apply NMS.</param>
            <param name="scores">a set of corresponding confidences.</param>
            <param name="scoreThreshold">a threshold used to filter boxes by score.</param>
            <param name="nmsThreshold">a threshold used in non maximum suppression.</param>
            <param name="indices">the kept indices of bboxes after NMS.</param>
            <param name="eta">a coefficient in adaptive threshold formula</param>
            <param name="topK">if `&gt;0`, keep at most @p top_k picked indices.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.CvDnn.ResetMyriadDevice">
            <summary>
            Release a Myriad device is binded by OpenCV.
            
            Single Myriad device cannot be shared across multiple processes which uses Inference Engine's Myriad plugin.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Dnn.Net">
            <inheritdoc />
            <summary>
            This class allows to create and manipulate comprehensive artificial neural networks.
            </summary>
            <remarks>
            Neural network is presented as directed acyclic graph(DAG), where vertices are Layer instances,
            and edges specify relationships between layers inputs and outputs.
            
            Each network layer has unique integer id and unique string name inside its network.
            LayerId can store either layer name or layer id.
            This class supports reference counting of its instances, i.e.copies point to the same instance.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.#ctor">
            <inheritdoc />
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.#ctor(System.IntPtr)">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.DisposeUnmanaged">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadFromModelOptimizer(System.String,System.String)">
            <summary>
            Create a network from Intel's Model Optimizer intermediate representation (IR).
            Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine backend.
            </summary>
            <param name="xml">XML configuration file with network's topology.</param>
            <param name="bin">Binary file with trained weights.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromDarknet(System.String,System.String)">
            <summary>
            Reads a network model stored in Darknet (https://pjreddie.com/darknet/) model files.
            </summary>
            <param name="cfgFile">path to the .cfg file with text description of the network architecture.</param>
            <param name="darknetModel">path to the .weights file with learned network.</param>
            <returns>Network object that ready to do forward, throw an exception in failure cases.</returns>
            <remarks>This is shortcut consisting from DarknetImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromDarknet(System.Byte[],System.Byte[])">
            <summary>
            Reads a network model stored in Caffe model files from memory.
            </summary>
            <param name="bufferCfg">A buffer contains a content of .cfg file with text description of the network architecture.</param>
            <param name="bufferModel">A buffer contains a content of .weights file with learned network.</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromDarknet(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a network model stored in Caffe model files from memory.
            </summary>
            <param name="bufferCfg">A buffer contains a content of .cfg file with text description of the network architecture.</param>
            <param name="bufferModel">A buffer contains a content of .weights file with learned network.</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromCaffe(System.String,System.String)">
            <summary>
            Reads a network model stored in Caffe model files.
            </summary>
            <param name="prototxt">path to the .prototxt file with text description of the network architecture.</param>
            <param name="caffeModel">path to the .caffemodel file with learned network.</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromCaffe(System.Byte[],System.Byte[])">
            <summary>
            Reads a network model stored in Caffe model in memory.
            </summary>
            <param name="bufferProto">buffer containing the content of the .prototxt file</param>
            <param name="bufferModel">buffer containing the content of the .caffemodel file</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromCaffe(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a network model stored in Caffe model files from memory.
            </summary>
            <param name="bufferProto">buffer containing the content of the .prototxt file</param>
            <param name="bufferModel">buffer containing the content of the .caffemodel file</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createCaffeImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromTensorflow(System.String,System.String)">
            <summary>
            Reads a network model stored in Tensorflow model file.
            </summary>
            <param name="model">path to the .pb file with binary protobuf description of the network architecture</param>
            <param name="config">path to the .pbtxt file that contains text graph definition in protobuf format.</param>
            <returns>Resulting Net object is built by text graph using weights from a binary one that
            let us make it more flexible.</returns>
            <remarks>This is shortcut consisting from createTensorflowImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromTensorflow(System.Byte[],System.Byte[])">
            <summary>
            Reads a network model stored in Tensorflow model from memory.
            </summary>
            <param name="bufferModel">buffer containing the content of the pb file</param>
            <param name="bufferConfig">buffer containing the content of the pbtxt file (optional)</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createTensorflowImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromTensorflow(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a network model stored in Tensorflow model from memory.
            </summary>
            <param name="bufferModel">buffer containing the content of the pb file</param>
            <param name="bufferConfig">buffer containing the content of the pbtxt file (optional)</param>
            <returns></returns>
            <remarks>This is shortcut consisting from createTensorflowImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromTorch(System.String,System.Boolean)">
            <summary>
            Reads a network model stored in Torch model file.
            </summary>
            <param name="model"></param>
            <param name="isBinary"></param>
            <returns></returns>
            <remarks>This is shortcut consisting from createTorchImporter and Net::populateNet calls.</remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNet(System.String,System.String,System.String)">
            <summary>
            Read deep learning network represented in one of the supported formats.
            
            This function automatically detects an origin framework of trained model 
            and calls an appropriate function such @ref readNetFromCaffe, @ref readNetFromTensorflow,
            </summary>
            <param name="model">Binary file contains trained weights. The following file
            *                  extensions are expected for models from different frameworks:
            *                  * `*.caffemodel` (Caffe, http://caffe.berkeleyvision.org/)
            *                  * `*.pb` (TensorFlow, https://www.tensorflow.org/)
            *                  * `*.t7` | `*.net` (Torch, http://torch.ch/)
            *                  * `*.weights` (Darknet, https://pjreddie.com/darknet/)
            *                  * `*.bin` (DLDT, https://software.intel.com/openvino-toolkit)</param>
            <param name="config">Text file contains network configuration. It could be a
            *                   file with the following extensions:
            *                  * `*.prototxt` (Caffe, http://caffe.berkeleyvision.org/)
            *                  * `*.pbtxt` (TensorFlow, https://www.tensorflow.org/)
            *                  * `*.cfg` (Darknet, https://pjreddie.com/darknet/)
            *                  * `*.xml` (DLDT, https://software.intel.com/openvino-toolkit)</param>
            <param name="framework">Explicit framework name tag to determine a format.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromModelOptimizer(System.String,System.String)">
            <summary>
            Load a network from Intel's Model Optimizer intermediate representation.
            Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine  backend.
            </summary>
            <param name="xml">XML configuration file with network's topology.</param>
            <param name="bin">Binary file with trained weights.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromONNX(System.String)">
            <summary>
            Reads a network model ONNX https://onnx.ai/
            </summary>
            <param name="onnxFile">path to the .onnx file with text description of the network architecture.</param>
            <returns>Network object that ready to do forward, throw an exception in failure cases.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromONNX(System.Byte[])">
            <summary>
            Reads a network model ONNX https://onnx.ai/ from memory
            </summary>
            <param name="onnxFileData">memory of the first byte of the buffer.</param>
            <returns>Network object that ready to do forward, throw an exception in failure cases.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.ReadNetFromONNX(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a network model ONNX https://onnx.ai/ from memory
            </summary>
            <param name="onnxFileData">memory of the first byte of the buffer.</param>
            <returns>Network object that ready to do forward, throw an exception in failure cases.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.Empty">
            <summary>
            Returns true if there are no layers in the network. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.Dump">
            <summary>
            Dump net to String.
            Call method after setInput(). To see correct backend, target and fusion run after forward().
            </summary>
            <returns>String with structure, hyperparameters, backend, target and fusion</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.DumpToFile(System.String)">
            <summary>
            Dump net structure, hyperparameters, backend, target and fusion to dot file
            </summary>
            <param name="path">path to output file with .dot extension</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.GetLayerId(System.String)">
            <summary>
            Converts string name of the layer to the integer identifier.
            </summary>
            <param name="layer"></param>
            <returns>id of the layer, or -1 if the layer wasn't found.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.GetLayerNames">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.Connect(System.String,System.String)">
            <summary>
            Connects output of the first layer to input of the second layer.
            </summary>
            <param name="outPin">descriptor of the first layer output.</param>
            <param name="inpPin">descriptor of the second layer input.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.Connect(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Connects #@p outNum output of the first layer to #@p inNum input of the second layer.
            </summary>
            <param name="outLayerId">identifier of the first layer</param>
            <param name="outNum">identifier of the second layer</param>
            <param name="inpLayerId">number of the first layer output</param>
            <param name="inpNum">number of the second layer input</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.SetInputsNames(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Sets outputs names of the network input pseudo layer.
            </summary>
            <param name="inputBlobNames"></param>
            <remarks>
            * Each net always has special own the network input pseudo layer with id=0.
            * This layer stores the user blobs only and don't make any computations.
            * In fact, this layer provides the only way to pass user data into the network.
            * As any other layer, this layer can label its outputs and this function provides an easy way to do this.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.Forward(System.String)">
            <summary>
            Runs forward pass to compute output of layer with name @p outputName.
            By default runs forward pass for the whole network.
            </summary>
            <param name="outputName">name for layer which output is needed to get</param>
            <returns>blob for first output of specified layer.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.Forward(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.String)">
            <summary>
            Runs forward pass to compute output of layer with name @p outputName.
            </summary>
            <param name="outputBlobs">contains all output blobs for specified layer.</param>
            <param name="outputName">name for layer which output is needed to get. 
            If outputName is empty, runs forward pass for the whole network.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.Forward(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Runs forward pass to compute outputs of layers listed in @p outBlobNames.
            </summary>
            <param name="outputBlobs">contains blobs for first outputs of specified layers.</param>
            <param name="outBlobNames">names for layers which outputs are needed to get</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.SetHalideScheduler(System.String)">
            <summary>
            Compile Halide layers.
            Schedule layers that support Halide backend. Then compile them for 
            specific target.For layers that not represented in scheduling file 
            or if no manual scheduling used at all, automatic scheduling will be applied.
            </summary>
            <param name="scheduler">Path to YAML file with scheduling directives.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.SetPreferableBackend(ST4IVisionCoreNet.Dnn.Backend)">
            <summary>
            Ask network to use specific computation backend where it supported.
            </summary>
            <param name="backendId">backend identifier.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.SetPreferableTarget(ST4IVisionCoreNet.Dnn.Target)">
            <summary>
            Ask network to make computations on specific target device.
            </summary>
            <param name="targetId">target identifier.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.SetInput(ST4IVisionCoreNet.Mat,System.String)">
            <summary>
            Sets the new value for the layer output blob
            </summary>
            <param name="blob">new blob.</param>
            <param name="name">descriptor of the updating layer output blob.</param>
            <remarks>
            connect(String, String) to know format of the descriptor.
            If updating blob is not empty then @p blob must have the same shape, 
            because network reshaping is not implemented yet.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.GetUnconnectedOutLayers">
            <summary>
            Returns indexes of layers with unconnected outputs.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.GetUnconnectedOutLayersNames">
            <summary>
            Returns names of layers with unconnected outputs.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.EnableFusion(System.Boolean)">
            <summary>
            Enables or disables layer fusion in the network.
            </summary>
            <param name="fusion">true to enable the fusion, false to disable. The fusion is enabled by default.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Dnn.Net.GetPerfProfile(System.Double[]@)">
            <summary>
            Returns overall time for inference and timings (in ticks) for layers.
            Indexes in returned vector correspond to layers ids.Some layers can be fused with others,
            in this case zero ticks count will be return for that skipped layers.
            </summary>
            <param name="timings">vector for tick timings for all layers.</param>
            <returns>overall ticks for model inference.</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Dnn.Target">
            <summary>
            Enum of target devices for computations.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Dnn.Target.FPGA">
            <summary>
            FPGA device with CPU fallbacks using Inference Engine's Heterogeneous plugin.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl">
            <summary>
             A class to upscale images via convolutional neural networks.
            The following four models are implemented:
            - edsr
            - espcn
            - fsrcnn
            - lapsrn
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.#ctor">
            <inheritdoc />
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.#ctor(System.String,System.Int32)">
            <inheritdoc />
            <summary>
            Constructor which immediately sets the desired model
            </summary>
            <param name="algo">String containing one of the desired models:
            - edsr
            - espcn
            - fsrcnn
            - lapsrn</param>
            <param name="scale">Integer specifying the upscale factor</param>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.#ctor(System.IntPtr)">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.DisposeUnmanaged">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.ReadModel(System.String)">
            <summary>
            Read the model from the given path
            </summary>
            <param name="path">Path to the model file.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.ReadModel(System.String,System.String)">
            <summary>
            Read the model from the given path
            </summary>
            <param name="weights">Path to the model weights file.</param>
            <param name="definition">Path to the model definition file.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.SetModel(System.String,System.Int32)">
            <summary>
            Set desired model
            </summary>
            <param name="algo">String containing one of the desired models:
            - edsr
            - espcn
            - fsrcnn
            - lapsrn</param>
            <param name="scale">Integer specifying the upscale factor</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.SetPreferableBackend(ST4IVisionCoreNet.Dnn.Backend)">
            <summary>
            Ask network to use specific computation backend where it supported.
            </summary>
            <param name="backendId">backend identifier.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.SetPreferableTarget(ST4IVisionCoreNet.Dnn.Target)">
            <summary>
            Ask network to make computations on specific target device.
            </summary>
            <param name="targetId">target identifier.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.Upsample(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Upsample via neural network
            </summary>
            <param name="img">Image to upscale</param>
            <param name="result">Destination upscaled image</param>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.UpsampleMultioutput(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Mat[]@,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Upsample via neural network of multiple outputs
            </summary>
            <param name="img">Image to upscale</param>
            <param name="imgsNew">Destination upscaled images</param>
            <param name="scaleFactors">Scaling factors of the output nodes</param>
            <param name="nodeNames">Names of the output nodes in the neural network</param>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.GetScale">
            <summary>
            Returns the scale factor of the model
            </summary>
            <returns>Current scale factor.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DnnSuperres.DnnSuperResImpl.GetAlgorithm">
            <summary>
            Returns the scale factor of the model
            </summary>
            <returns>Current algorithm.</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.Facemark">
            <summary>
            Abstract base class for all facemark models.
            
            All facemark models in OpenCV are derived from the abstract base class Facemark, which 
            provides a unified access to all facemark algorithms in OpenCV.
            To utilize this API in your program, please take a look at the @ref tutorial_table_of_content_facemark
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.Facemark.LoadModel(System.String)">
            <summary>
             A function to load the trained model before the fitting process.
            </summary>
            <param name="model">A string represent the filename of a trained model.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.Facemark.Fit(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[][]@)">
            <summary>
            Trains a Facemark algorithm using the given dataset.
            </summary>
            <param name="image">Input image.</param>
            <param name="faces">Output of the function which represent region of interest of the detected faces. Each face is stored in cv::Rect container.</param>
            <param name="landmarks">The detected landmark points for each faces.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.FacemarkAAM">
            <inheritdoc />
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkAAM.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkAAM.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkAAM.Create(ST4IVisionCoreNet.Face.FacemarkAAM.Params)">
            <summary>
            
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.FacemarkAAM.Params">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkAAM.Params.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkAAM.Params.DisposeUnmanaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkAAM.Params.ModelFilename">
            <summary>
            filename of the model
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkAAM.Params.M">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkAAM.Params.N">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkAAM.Params.NIter">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkAAM.Params.Verbose">
            <summary>
            show the training print-out
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkAAM.Params.SaveModel">
            <summary>
            flag to save the trained model or not
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkAAM.Params.Scales">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkAAM.Params.Read(ST4IVisionCoreNet.FileNode)">
            <summary>
            
            </summary>
            <param name="fn"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkAAM.Params.Write(ST4IVisionCoreNet.FileStorage)">
            <summary>
            
            </summary>
            <param name="fs"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.FacemarkLBF">
            <inheritdoc />
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkLBF.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkLBF.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkLBF.Create(ST4IVisionCoreNet.Face.FacemarkLBF.Params)">
            <summary>
            
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.FacemarkLBF.Params">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkLBF.Params.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkLBF.Params.DisposeUnmanaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.ShapeOffset">
            <summary>
            offset for the loaded face landmark points
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.CascadeFace">
            <summary>
            filename of the face detector model
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.Verbose">
            <summary>
            show the training print-out
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.NLandmarks">
            <summary>
            number of landmark points
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.InitShapeN">
            <summary>
            multiplier for augment the training data
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.StagesN">
            <summary>
            number of refinement stages
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.TreeN">
            <summary>
            number of tree in the model for each landmark point refinement
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.TreeDepth">
            <summary>
            the depth of decision tree, defines the size of feature
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.BaggingOverlap">
            <summary>
            overlap ratio for training the LBF feature
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.ModelFilename">
            <summary>
            filename where the trained model will be saved
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.SaveModel">
            <summary>
            flag to save the trained model or not
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.Seed">
            <summary>
            seed for shuffling the training data
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.FeatsM">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.RadiusM">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.Pupils0">
            <summary>
            index of facemark points on pupils of left and right eye
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.Pupils1">
            <summary>
            index of facemark points on pupils of left and right eye
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Face.FacemarkLBF.Params.DetectROI">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkLBF.Params.Read(ST4IVisionCoreNet.FileNode)">
            <summary>
            
            </summary>
            <param name="fn"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FacemarkLBF.Params.Write(ST4IVisionCoreNet.FileStorage)">
            <summary>
            
            </summary>
            <param name="fs"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.BasicFaceRecognizer">
            <summary>
            base for two FaceRecognizer classes
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.GetNumComponents">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.SetNumComponents(System.Int32)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.GetThreshold">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.SetThreshold(System.Double)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.GetProjections">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.GetLabels">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.GetEigenValues">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.GetEigenVectors">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.BasicFaceRecognizer.GetMean">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.EigenFaceRecognizer">
            <inheritdoc />
            <summary>
            Training and prediction must be done on grayscale images, use cvtColor to convert between the 
            color spaces.
            -   **THE EIGENFACES METHOD MAKES THE ASSUMPTION, THAT THE TRAINING AND TEST IMAGES ARE OF EQUAL SIZE.
            ** (caps-lock, because I got so many mails asking for this). You have to make sure your 
            input data has the correct shape, else a meaningful exception is thrown.Use resize to resize the images.
            -   This model does not support updating.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Face.EigenFaceRecognizer.recognizerPtr">
             <summary>
            
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.EigenFaceRecognizer.#ctor">
            <inheritdoc />
             <summary>
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.EigenFaceRecognizer.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.EigenFaceRecognizer.Create(System.Int32,System.Double)">
            <summary>
            Training and prediction must be done on grayscale images, use cvtColor to convert between the 
            color spaces.
            -   **THE EIGENFACES METHOD MAKES THE ASSUMPTION, THAT THE TRAINING AND TEST IMAGES ARE OF EQUAL SIZE.
            ** (caps-lock, because I got so many mails asking for this). You have to make sure your 
            input data has the correct shape, else a meaningful exception is thrown.Use resize to resize the images.
            -   This model does not support updating.
            </summary>
            <param name="numComponents"> The number of components (read: Eigenfaces) kept for this Principal Component Analysis. 
            As a hint: There's no rule how many components (read: Eigenfaces) should be kept for good reconstruction capabilities. 
            It is based on your input data, so experiment with the number. Keeping 80 components should almost always be sufficient.</param>
            <param name="threshold">The threshold applied in the prediction.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.FaceRecognizer">
            <summary>
            Abstract base class for all face recognition models.
            All face recognition models in OpenCV are derived from the abstract base class FaceRecognizer, which
            provides a unified access to all face recongition algorithms in OpenCV.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.Train(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Trains a FaceRecognizer with given data and associated labels.
            </summary>
            <param name="src"></param>
            <param name="labels"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.Update(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Updates a FaceRecognizer with given data and associated labels.
            </summary>
            <param name="src"></param>
            <param name="labels"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.Predict(ST4IVisionCoreNet.InputArray)">
            <summary>
            Gets a prediction from a FaceRecognizer.
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.Predict(ST4IVisionCoreNet.InputArray,System.Int32@,System.Double@)">
            <summary>
            Predicts the label and confidence for a given sample.
            </summary>
            <param name="src"></param>
            <param name="label"></param>
            <param name="confidence"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.Write(System.String)">
            <summary>
            Serializes this object to a given filename.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.Read(System.String)">
            <summary>
            Deserializes this object from a given filename.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.Write(ST4IVisionCoreNet.FileStorage)">
            <inheritdoc />
            <summary>
            Serializes this object to a given cv::FileStorage.
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.Read(ST4IVisionCoreNet.FileNode)">
            <inheritdoc />
            <summary>
            Deserializes this object from a given cv::FileNode.
            </summary>
            <param name="fn"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.SetLabelInfo(System.Int32,System.String)">
            <summary>
            Sets string info for the specified model's label.
            The string info is replaced by the provided value if it was set before for the specified label.
            </summary>
            <param name="label"></param>
            <param name="strInfo"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.GetLabelInfo(System.Int32)">
            <summary>
            Gets string information by label.
            If an unknown label id is provided or there is no label information associated with the specified 
            label id the method returns an empty string.
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.GetLabelsByString(System.String)">
            <summary>
            Gets vector of labels by string.
            The function searches for the labels containing the specified sub-string in the associated string info.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.GetThreshold">
            <summary>
            threshold parameter accessor - required for default BestMinDist collector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FaceRecognizer.SetThreshold(System.Double)">
            <summary>
            Sets threshold of model
            </summary>
            <param name="val"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.FisherFaceRecognizer">
            <inheritdoc />
            <summary>
            Training and prediction must be done on grayscale images, use cvtColor to convert between the color spaces.
            -   **THE FISHERFACES METHOD MAKES THE ASSUMPTION, THAT THE TRAINING AND TEST IMAGES ARE OF EQUAL SIZE.
                ** (caps-lock, because I got so many mails asking for this). You have to make sure your input data 
                  has the correct shape, else a meaningful exception is thrown.Use resize to resize the images.
            -   This model does not support updating.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Face.FisherFaceRecognizer.recognizerPtr">
             <summary>
            
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FisherFaceRecognizer.#ctor">
            <inheritdoc />
             <summary>
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FisherFaceRecognizer.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.FisherFaceRecognizer.Create(System.Int32,System.Double)">
            <summary>
            Training and prediction must be done on grayscale images, use cvtColor to convert between the color spaces.
            -   **THE FISHERFACES METHOD MAKES THE ASSUMPTION, THAT THE TRAINING AND TEST IMAGES ARE OF EQUAL SIZE.
                ** (caps-lock, because I got so many mails asking for this). You have to make sure your input data 
                  has the correct shape, else a meaningful exception is thrown.Use resize to resize the images.
            -   This model does not support updating.
            </summary>
            <param name="numComponents">The number of components (read: Fisherfaces) kept for this Linear Discriminant Analysis 
            with the Fisherfaces criterion. It's useful to keep all components, that means the number of your classes c 
            (read: subjects, persons you want to recognize). If you leave this at the default (0) or set it 
            to a value less-equal 0 or greater (c-1), it will be set to the correct number (c-1) automatically.</param>
            <param name="threshold">The threshold applied in the prediction. If the distance to the nearest neighbor 
            is larger than the threshold, this method returns -1.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Face.LBPHFaceRecognizer">
            <inheritdoc />
            <summary>
            The Circular Local Binary Patterns (used in training and prediction) expect the data given as
            grayscale images, use cvtColor to convert between the color spaces.
            This model supports updating.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.recognizerPtr">
             <summary>
            
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            The Circular Local Binary Patterns (used in training and prediction) expect the data given as
            grayscale images, use cvtColor to convert between the color spaces.
            This model supports updating.
            </summary>
            <param name="radius">The radius used for building the Circular Local Binary Pattern. The greater the radius, the</param>
            <param name="neighbors">The number of sample points to build a Circular Local Binary Pattern from. 
            An appropriate value is to use `8` sample points.Keep in mind: the more sample points you include, the higher the computational cost.</param>
            <param name="gridX">The number of cells in the horizontal direction, 8 is a common value used in publications. 
            The more cells, the finer the grid, the higher the dimensionality of the resulting feature vector.</param>
            <param name="gridY">The number of cells in the vertical direction, 8 is a common value used in publications. 
            The more cells, the finer the grid, the higher the dimensionality of the resulting feature vector.</param>
            <param name="threshold">The threshold applied in the prediction. If the distance to the nearest neighbor 
            is larger than the threshold, this method returns -1.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.GetGridX">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.SetGridX(System.Int32)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.GetGridY">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.SetGridY(System.Int32)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.GetRadius">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.SetRadius(System.Int32)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.GetNeighbors">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.SetNeighbors(System.Int32)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.GetThreshold">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.SetThreshold(System.Double)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.GetHistograms">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Face.LBPHFaceRecognizer.GetLabels">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.AgastFeatureDetector">
            <summary>
            Detects corners using the AGAST algorithm
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.AgastFeatureDetector.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.AgastFeatureDetector.Create(System.Int32,System.Boolean,ST4IVisionCoreNet.AgastFeatureDetector.DetectorType)">
            <summary>
            The AgastFeatureDetector constructor
            </summary>
            <param name="threshold">threshold on difference between intensity of the central pixel 
            and pixels of a circle around this pixel.</param>
            <param name="nonmaxSuppression">if true, non-maximum suppression is applied to detected corners (keypoints).</param>
            <param name="type"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.AgastFeatureDetector.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AgastFeatureDetector.Threshold">
            <summary>
            threshold on difference between intensity of the central pixel and pixels of a circle around this pixel.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AgastFeatureDetector.NonmaxSuppression">
            <summary>
            if true, non-maximum suppression is applied to detected corners (keypoints).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AgastFeatureDetector.Type">
            <summary>
            type one of the four neighborhoods as defined in the paper
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.AgastFeatureDetector.DetectorType">
            <summary>
            AGAST type one of the four neighborhoods as defined in the paper
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.AKAZE">
            <summary>
            Class implementing the AKAZE keypoint detector and descriptor extractor, 
            described in @cite ANB13
            </summary>
            <remarks>
            AKAZE descriptors can only be used with KAZE or AKAZE keypoints. 
            Try to avoid using *extract* and *detect* instead of *operator()* due to performance reasons. 
            .. [ANB13] Fast Explicit Diffusion for Accelerated Features in Nonlinear Scale 
            Spaces. Pablo F. Alcantarilla, Jesús Nuevo and Adrien Bartoli. 
            In British Machine Vision Conference (BMVC), Bristol, UK, September 2013.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.AKAZE.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.AKAZE.Create(ST4IVisionCoreNet.AKAZEDescriptorType,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,ST4IVisionCoreNet.KAZEDiffusivityType)">
            <summary>
            The AKAZE constructor
            </summary>
            <param name="descriptorType">Type of the extracted descriptor: DESCRIPTOR_KAZE,
            DESCRIPTOR_KAZE_UPRIGHT, DESCRIPTOR_MLDB or DESCRIPTOR_MLDB_UPRIGHT.</param>
            <param name="descriptorSize">Size of the descriptor in bits. 0 -&gt; Full size</param>
            <param name="descriptorChannels">Number of channels in the descriptor (1, 2, 3)</param>
            <param name="threshold">Detector response threshold to accept point</param>
            <param name="nOctaves">Maximum octave evolution of the image</param>
            <param name="nOctaveLayers">Default number of sublevels per scale level</param>
            <param name="diffusivity">Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or DIFF_CHARBONNIER</param>
        </member>
        <member name="M:ST4IVisionCoreNet.AKAZE.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AKAZE.AKAZEDescriptorType">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AKAZE.AKAZEDescriptorSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AKAZE.AKAZEDescriptorChannels">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AKAZE.Threshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AKAZE.NOctaves">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AKAZE.NOctaveLayers">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.AKAZE.DiffusivityType">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.BFMatcher">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BFMatcher.#ctor(ST4IVisionCoreNet.NormTypes,System.Boolean)">
            <summary>
            
            </summary>
            <param name="normType"></param>
            <param name="crossCheck"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.BFMatcher.#ctor(ST4IVisionCoreNet.BFMatcher.Ptr)">
            <summary>
            Creates instance by cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BFMatcher.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer T*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BFMatcher.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.BFMatcher.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BFMatcher.DisposeUnmanaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BFMatcher.IsMaskSupported">
            <summary>
            Return true if the matcher supports mask in match methods.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.BOWImgDescriptorExtractor">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.#ctor(ST4IVisionCoreNet.Feature2D,ST4IVisionCoreNet.DescriptorMatcher)">
            <summary>
            The constructor.
            </summary>
            <param name="dextractor">Descriptor extractor that is used to compute descriptors for an input image and its keypoints.</param>
            <param name="dmatcher">Descriptor matcher that is used to find the nearest word of the trained vocabulary for each keypoint descriptor of the image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.#ctor(ST4IVisionCoreNet.DescriptorMatcher)">
            <summary>
            The constructor.
            </summary>
            <param name="dmatcher">Descriptor matcher that is used to find the nearest word of the trained vocabulary for each keypoint descriptor of the image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.SetVocabulary(ST4IVisionCoreNet.Mat)">
            <summary>
            Sets a visual vocabulary.
            </summary>
            <param name="vocabulary">Vocabulary (can be trained using the inheritor of BOWTrainer ). 
            Each row of the vocabulary is a visual word(cluster center).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.GetVocabulary">
            <summary>
            Returns the set vocabulary.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.KeyPoint[]@,ST4IVisionCoreNet.OutputArray,System.Int32[][]@,ST4IVisionCoreNet.Mat)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="image">Image, for which the descriptor is computed.</param>
            <param name="keypoints">Keypoints detected in the input image.</param>
            <param name="imgDescriptor">Computed output image descriptor.</param>
            <param name="pointIdxsOfClusters">pointIdxsOfClusters Indices of keypoints that belong to the cluster. 
            This means that pointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster(word of vocabulary) returned if it is non-zero.</param>
            <param name="descriptors">Descriptors of the image keypoints that are returned if they are non-zero.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32[][]@)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="keypointDescriptors">Computed descriptors to match with vocabulary.</param>
            <param name="imgDescriptor">Computed output image descriptor.</param>
            <param name="pointIdxsOfClusters">Indices of keypoints that belong to the cluster. 
            This means that pointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster(word of vocabulary) returned if it is non-zero.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.Compute2(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.KeyPoint[]@,ST4IVisionCoreNet.Mat)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="image">Image, for which the descriptor is computed.</param>
            <param name="keypoints">Keypoints detected in the input image.</param>
            <param name="imgDescriptor">Computed output image descriptor.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.DescriptorSize">
            <summary>
            Returns an image descriptor size if the vocabulary is set. Otherwise, it returns 0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWImgDescriptorExtractor.DescriptorType">
            <summary>
            Returns an image descriptor type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.BOWKMeansTrainer">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWKMeansTrainer.#ctor(System.Int32,System.Nullable{ST4IVisionCoreNet.TermCriteria},System.Int32,ST4IVisionCoreNet.KMeansFlags)">
            <summary>
            The constructor.
            </summary>
            <param name="clusterCount"></param>
            <param name="termcrit"></param>
            <param name="attempts"></param>
            <param name="flags"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWKMeansTrainer.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWKMeansTrainer.Cluster">
            <summary>
            Clusters train descriptors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWKMeansTrainer.Cluster(ST4IVisionCoreNet.Mat)">
            <summary>
            Clusters train descriptors.
            </summary>
            <param name="descriptors">Descriptors to cluster. Each row of the descriptors matrix is a descriptor. Descriptors are not added to the inner train descriptor set.
            The vocabulary consists of cluster centers. So, this method returns the vocabulary. In the first variant of the method, train descriptors stored in the object 
            are clustered.In the second variant, input descriptors are clustered.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.BOWTrainer">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWTrainer.Add(ST4IVisionCoreNet.Mat)">
            <summary>
            Adds descriptors to a training set.
            </summary>
            <param name="descriptors">descriptors Descriptors to add to a training set. Each row of the descriptors matrix is a descriptor.
            The training set is clustered using clustermethod to construct the vocabulary.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWTrainer.GetDescriptors">
            <summary>
            Returns a training set of descriptors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWTrainer.DescriptorsCount">
            <summary>
            Returns the count of all descriptors stored in the training set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWTrainer.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWTrainer.Cluster">
            <summary>
            Clusters train descriptors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BOWTrainer.Cluster(ST4IVisionCoreNet.Mat)">
            <summary>
            Clusters train descriptors.
            </summary>
            <param name="descriptors">Descriptors to cluster. Each row of the descriptors matrix is a descriptor. Descriptors are not added to the inner train descriptor set.
            The vocabulary consists of cluster centers. So, this method returns the vocabulary. In the first variant of the method, train descriptors stored in the object 
            are clustered.In the second variant, input descriptors are clustered.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.BRISK">
            <summary>
            BRISK implementation
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BRISK.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BRISK.#ctor(System.IntPtr)">
            <summary>
            Construct from native cv::Ptr&lt;T&gt;*
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.BRISK.Create(System.Int32,System.Int32,System.Single)">
            <summary>
            The BRISK constructor
            </summary>
            <param name="thresh">AGAST detection threshold score.</param>
            <param name="octaves">detection octaves. Use 0 to do single scale.</param>
            <param name="patternScale">apply this scale to the pattern used for sampling the neighbourhood of a keypoint.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.BRISK.Create(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Int32},System.Single,System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            The BRISK constructor for a custom pattern
            </summary>
            <param name="radiusList">defines the radii (in pixels) where the samples around a keypoint are taken (for keypoint scale 1).</param>
            <param name="numberList">defines the number of sampling points on the sampling circle. Must be the same size as radiusList..</param>
            <param name="dMax">threshold for the short pairings used for descriptor formation (in pixels for keypoint scale 1).</param>
            <param name="dMin">threshold for the long pairings used for orientation determination (in pixels for keypoint scale 1).</param>
            <param name="indexChange">index remapping of the bits.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BRISK.Create(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Int32},System.Single,System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            The BRISK constructor for a custom pattern, detection threshold and octaves
            </summary>
            <param name="thresh">AGAST detection threshold score.</param>
            <param name="octaves">detection octaves. Use 0 to do single scale.</param>
            <param name="radiusList">defines the radii (in pixels) where the samples around a keypoint are taken (for keypoint scale 1).</param>
            <param name="numberList">defines the number of sampling points on the sampling circle. Must be the same size as radiusList..</param>
            <param name="dMax">threshold for the short pairings used for descriptor formation (in pixels for keypoint scale 1).</param>
            <param name="dMin">threshold for the long pairings used for orientation determination (in pixels for keypoint scale 1).</param>
            <param name="indexChange">index remapping of the bits.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BRISK.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DescriptorMatcher">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DescriptorMatcher.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.Create(System.String)">
            <summary>
            Create descriptor matcher by type name.
            </summary>
            <param name="descriptorMatcherType"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.FromRawPtr(System.IntPtr)">
            <summary>
            Creates instance from raw pointer T*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.Add(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            Add descriptors to train descriptor collection.
            </summary>
            <param name="descriptors">Descriptors to add. Each descriptors[i] is a descriptors set from one image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.GetTrainDescriptors">
            <summary>
            Get train descriptors collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.Clear">
            <summary>
            Clear train descriptors collection.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.Empty">
            <summary>
            Return true if there are not train descriptors in collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.IsMaskSupported">
            <summary>
            Return true if the matcher supports mask in match methods.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.Train">
            <summary>
            Train matcher (e.g. train flann index).
            In all methods to match the method train() is run every time before matching.
            Some descriptor matchers (e.g. BruteForceMatcher) have empty implementation
            of this method, other matchers really train their inner structures
            (e.g. FlannBasedMatcher trains flann::Index). So nonempty implementation
            of train() should check the class object state and do traing/retraining
            only if the state requires that (e.g. FlannBasedMatcher trains flann::Index
            if it has not trained yet or if new descriptors have been added to the train collection).
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.Match(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat)">
            <summary>
            Find one best match for each query descriptor (if mask is empty).
            </summary>
            <param name="queryDescriptors"></param>
            <param name="trainDescriptors"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.KnnMatch(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Int32,ST4IVisionCoreNet.Mat,System.Boolean)">
            <summary>
            Find k best matches for each query descriptor (in increasing order of distances).
            compactResult is used when mask is not empty. If compactResult is false matches
            vector will have the same size as queryDescriptors rows. If compactResult is true
            matches vector will not contain matches for fully masked out query descriptors.
            </summary>
            <param name="queryDescriptors"></param>
            <param name="trainDescriptors"></param>
            <param name="k"></param>
            <param name="mask"></param>
            <param name="compactResult"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.RadiusMatch(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Single,ST4IVisionCoreNet.Mat,System.Boolean)">
            <summary>
            Find best matches for each query descriptor which have distance less than
            maxDistance (in increasing order of distances).
            </summary>
            <param name="queryDescriptors"></param>
            <param name="trainDescriptors"></param>
            <param name="maxDistance"></param>
            <param name="mask"></param>
            <param name="compactResult"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.Match(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat[])">
            <summary>
            Find one best match for each query descriptor (if mask is empty).
            </summary>
            <param name="queryDescriptors"></param>
            <param name="masks"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.KnnMatch(ST4IVisionCoreNet.Mat,System.Int32,ST4IVisionCoreNet.Mat[],System.Boolean)">
            <summary>
            Find k best matches for each query descriptor (in increasing order of distances).
            compactResult is used when mask is not empty. If compactResult is false matches
            vector will have the same size as queryDescriptors rows. If compactResult is true
            matches vector will not contain matches for fully masked out query descriptors.
            </summary>
            <param name="queryDescriptors"></param>
            <param name="k"></param>
            <param name="masks"></param>
            <param name="compactResult"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DescriptorMatcher.RadiusMatch(ST4IVisionCoreNet.Mat,System.Single,ST4IVisionCoreNet.Mat[],System.Boolean)">
            <summary>
            Find best matches for each query descriptor which have distance less than
            maxDistance (in increasing order of distances).
            </summary>
            <param name="queryDescriptors"></param>
            <param name="maxDistance"></param>
            <param name="masks"></param>
            <param name="compactResult"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.AKAZEDescriptorType">
            <summary>
            cv::AKAZE descriptor type
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.AKAZEDescriptorType.KAZEUpright">
            <summary>
            Upright descriptors, not invariant to rotation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.AKAZEDescriptorType.KAZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.AKAZEDescriptorType.MLDBUpright">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.AKAZEDescriptorType.MLDB">
            <summary>
            Upright descriptors, not invariant to rotation
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DrawMatchesFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DrawMatchesFlags.Default">
            <summary>
            Output image matrix will be created (Mat::create),
            i.e. existing memory of output image may be reused.
            Two source image, matches and single keypoints will be drawn.
            For each keypoint only the center point will be drawn (without
            the circle around keypoint with keypoint size and orientation).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DrawMatchesFlags.DrawOverOutImg">
            <summary>
            Output image matrix will not be created (Mat::create).
            Matches will be drawn on existing content of output image.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DrawMatchesFlags.NotDrawSinglePoints">
            <summary>
            Single keypoints will not be drawn.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DrawMatchesFlags.DrawRichKeypoints">
            <summary>
            For each keypoint the circle around keypoint with keypoint size and
            orientation will be drawn.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FASTType">
            <summary>
            AGAST type one of the four neighborhoods as defined in the paper
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.KAZEDiffusivityType">
            <summary>
            cv::KAZE diffusivity type
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KAZEDiffusivityType.DiffPmG1">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KAZEDiffusivityType.DiffPmG2">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KAZEDiffusivityType.DiffWeickert">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.KAZEDiffusivityType.DiffCharbonnier">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ORBScoreType">
            <summary>
            cv::ORB score flags
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ORBScoreType.Fast">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ORBScoreType.Harris">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FastFeatureDetector">
            <summary>
            Detects corners using FAST algorithm by E. Rosten
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FastFeatureDetector.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FastFeatureDetector.Create(System.Int32,System.Boolean)">
            <summary>
            Constructs FastFeatureDetector
            </summary>
            <param name="threshold">threshold on difference between intensity of the central pixel and pixels of a circle around this pixel.</param>
            <param name="nonmaxSuppression">if true, non-maximum suppression is applied to detected corners (keypoints).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.FastFeatureDetector.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FastFeatureDetector.Threshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FastFeatureDetector.NonmaxSuppression">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FastFeatureDetector.Type">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Feature2D">
            <summary>
            Abstract base class for 2D image feature detectors and descriptor extractors
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.#ctor">
            <inheritdoc />
        </member>
        <member name="P:ST4IVisionCoreNet.Feature2D.DescriptorSize">
            <summary> 
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Feature2D.DescriptorType">
            <summary> 
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.Feature2D.DefaultNorm">
            <summary> 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.Empty">
            <summary>
            Return true if detector object is empty
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.Detect(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat)">
            <summary>
            Detect keypoints in an image.
            </summary>
            <param name="image">The image.</param>
            <param name="mask">Mask specifying where to look for keypoints (optional). 
            Must be a char matrix with non-zero values in the region of interest.</param>
            <returns>The detected keypoints.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Mat)">
            <summary>
            Detect keypoints in an image.
            </summary>
            <param name="image">The image.</param>
            <param name="mask">Mask specifying where to look for keypoints (optional). 
            Must be a char matrix with non-zero values in the region of interest.</param>
            <returns>The detected keypoints.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.Detect(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            Detect keypoints in an image set.
            </summary>
            <param name="images">Image collection.</param>
            <param name="masks">Masks for image set. masks[i] is a mask for images[i].</param>
            <returns>Collection of keypoints detected in an input images. keypoints[i] is a set of keypoints detected in an images[i].</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.KeyPoint[]@,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Compute the descriptors for a set of keypoints in an image.
            </summary>
            <param name="image">The image.</param>
            <param name="keypoints">The input keypoints. Keypoints for which a descriptor cannot be computed are removed.</param>
            <param name="descriptors">Computed descriptors. Row i is the descriptor for KeyPoint i.</param>param>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.Compute(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.KeyPoint[][]@,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            Compute the descriptors for a keypoints collection detected in image collection.
            </summary>
            <param name="images">Image collection.</param>
            <param name="keypoints">Input keypoints collection. keypoints[i] is keypoints detected in images[i].
            Keypoints for which a descriptor cannot be computed are removed.</param>
            <param name="descriptors">Descriptor collection. descriptors[i] are descriptors computed for set keypoints[i].</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.DetectAndCompute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.KeyPoint[]@,ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            Detects keypoints and computes the descriptors
            </summary>
            <param name="image"></param>
            <param name="mask"></param>
            <param name="keypoints"></param>
            <param name="descriptors"></param>
            <param name="useProvidedKeypoints"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.Write(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.Read(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Feature2D.GetDefaultName">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.FlannBasedMatcher">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.#ctor(ST4IVisionCoreNet.Flann.IndexParams,ST4IVisionCoreNet.Flann.SearchParams)">
            <summary>
            
            </summary>
            <param name="indexParams"></param>
            <param name="searchParams"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.#ctor(ST4IVisionCoreNet.FlannBasedMatcher.Ptr)">
            <summary>
            Creates instance by cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer T*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.DisposeUnmanaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.IsMaskSupported">
            <summary>
            Return true if the matcher supports mask in match methods.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.Add(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            Add descriptors to train descriptor collection.
            </summary>
            <param name="descriptors">Descriptors to add. Each descriptors[i] is a descriptors set from one image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.Clear">
            <summary>
            Clear train descriptors collection.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FlannBasedMatcher.Train">
            <summary>
            Train matcher (e.g. train flann index).
            In all methods to match the method train() is run every time before matching.
            Some descriptor matchers (e.g. BruteForceMatcher) have empty implementation
            of this method, other matchers really train their inner structures
            (e.g. FlannBasedMatcher trains flann::Index). So nonempty implementation
            of train() should check the class object state and do traing/retraining
            only if the state requires that (e.g. FlannBasedMatcher trains flann::Index
            if it has not trained yet or if new descriptors have been added to the train collection).
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.GFTTDetector">
            <summary>
            Good Features To Track Detector
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.GFTTDetector.Create(System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            Construct GFTT processor
            </summary>
            <param name="maxCorners"></param>
            <param name="qualityLevel"></param>
            <param name="minDistance"></param>
            <param name="blockSize"></param>
            <param name="useHarrisDetector"></param>
            <param name="k"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.GFTTDetector.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.GFTTDetector.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GFTTDetector.MaxFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GFTTDetector.QualityLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GFTTDetector.MinDistance">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GFTTDetector.BlockSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GFTTDetector.HarrisDetector">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GFTTDetector.K">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.KAZE">
            <summary>
            Class implementing the KAZE keypoint detector and descriptor extractor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.KAZE.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.KAZE.Create(System.Boolean,System.Boolean,System.Single,System.Int32,System.Int32,ST4IVisionCoreNet.KAZEDiffusivityType)">
            <summary>
            The KAZE constructor
            </summary>
            <param name="extended">Set to enable extraction of extended (128-byte) descriptor.</param>
            <param name="upright">Set to enable use of upright descriptors (non rotation-invariant).</param>
            <param name="threshold">Detector response threshold to accept point</param>
            <param name="nOctaves">Maximum octave evolution of the image</param>
            <param name="nOctaveLayers">Default number of sublevels per scale level</param>
            <param name="diffusivity">Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or DIFF_CHARBONNIER</param>
        </member>
        <member name="M:ST4IVisionCoreNet.KAZE.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KAZE.Diffusivity">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KAZE.Extended">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KAZE.NOctaveLayers">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KAZE.NOctaves">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KAZE.Threshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KAZE.Upright">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.KeyPointsFilter">
            <summary>
            A class filters a vector of keypoints.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPointsFilter.RunByImageBorder(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},ST4IVisionCoreNet.Size,System.Int32)">
            <summary>
            Remove keypoints within borderPixels of an image edge.
            </summary>
            <param name="keypoints"></param>
            <param name="imageSize"></param>
            <param name="borderSize"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPointsFilter.RunByKeypointSize(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},System.Single,System.Single)">
            <summary>
            Remove keypoints of sizes out of range.
            </summary>
            <param name="keypoints"></param>
            <param name="minSize"></param>
            <param name="maxSize"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPointsFilter.RunByPixelsMask(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},ST4IVisionCoreNet.Mat)">
            <summary>
            Remove keypoints from some image by mask for pixels of this image.
            </summary>
            <param name="keypoints"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPointsFilter.RemoveDuplicated(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint})">
            <summary>
            Remove duplicated keypoints.
            </summary>
            <param name="keypoints"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPointsFilter.RemoveDuplicatedSorted(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint})">
            <summary>
            Remove duplicated keypoints and sort the remaining keypoints
            </summary>
            <param name="keypoints"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.KeyPointsFilter.RetainBest(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.KeyPoint},System.Int32)">
            <summary>
            Retain the specified number of the best keypoints (according to the response)
            </summary>
            <param name="keypoints"></param>
            <param name="nPoints"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.MSER">
            <summary>
            Maximal Stable Extremal Regions class
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MSER.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::MSER*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MSER.Create(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Creates MSER parameters
            </summary>
            <param name="delta">delta, in the code, it compares (size_{i}-size_{i-delta})/size_{i-delta}</param>
            <param name="minArea">prune the area which smaller than min_area</param>
            <param name="maxArea">prune the area which bigger than max_area</param>
            <param name="maxVariation">prune the area have simliar size to its children</param>
            <param name="minDiversity">trace back to cut off mser with diversity &lt; min_diversity</param>
            <param name="maxEvolution">for color image, the evolution steps</param>
            <param name="areaThreshold">the area threshold to cause re-initialize</param>
            <param name="minMargin">ignore too small margin</param>
            <param name="edgeBlurSize">the aperture size for edge blur</param>
        </member>
        <member name="M:ST4IVisionCoreNet.MSER.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MSER.Delta">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MSER.MinArea">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MSER.MaxArea">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.MSER.Pass2Only">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MSER.DetectRegions(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point[][]@,ST4IVisionCoreNet.Rect[]@)">
            <summary>
            Detect MSER regions
            </summary>
            <param name="image">input image (8UC1, 8UC3 or 8UC4, must be greater or equal than 3x3)</param>
            <param name="msers">resulting list of point sets</param>
            <param name="bboxes">resulting bounding boxes</param>
        </member>
        <member name="T:ST4IVisionCoreNet.ORB">
             <summary>
             Class implementing the ORB (*oriented BRIEF*) keypoint detector and descriptor extractor.
            
             described in @cite RRKB11 . The algorithm uses FAST in pyramids to detect stable keypoints, selects 
             the strongest features using FAST or Harris response, finds their orientation using first-order
             moments and computes the descriptors using BRIEF (where the coordinates of random point pairs (or
             k-tuples) are rotated according to the measured orientation).
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ORB.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ORB.Create(System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.ORBScoreType,System.Int32,System.Int32)">
            <summary>
            The ORB constructor
            </summary>
            <param name="nFeatures">The maximum number of features to retain.</param>
            <param name="scaleFactor">Pyramid decimation ratio, greater than 1. scaleFactor==2 means the classical
            pyramid, where each next level has 4x less pixels than the previous, but such a big scale factor
            will degrade feature matching scores dramatically. On the other hand, too close to 1 scale factor
            will mean that to cover certain scale range you will need more pyramid levels and so the speed will suffer.</param>
            <param name="nLevels">The number of pyramid levels. The smallest level will have linear size equal to
            input_image_linear_size/pow(scaleFactor, nlevels - firstLevel).</param>
            <param name="edgeThreshold">This is size of the border where the features are not detected. It should
            roughly match the patchSize parameter.</param>
            <param name="firstLevel">The level of pyramid to put source image to. Previous layers are filled
            with upscaled source image.</param>
            <param name="wtaK">The number of points that produce each element of the oriented BRIEF descriptor. The
            default value 2 means the BRIEF where we take a random point pair and compare their brightnesses,
            so we get 0/1 response. Other possible values are 3 and 4. For example, 3 means that we take 3
            random points (of course, those point coordinates are random, but they are generated from the
            pre-defined seed, so each element of BRIEF descriptor is computed deterministically from the pixel
            rectangle), find point of maximum brightness and output index of the winner (0, 1 or 2). Such
            output will occupy 2 bits, and therefore it will need a special variant of Hamming distance,
            denoted as NORM_HAMMING2 (2 bits per bin). When WTA_K=4, we take 4 random points to compute each
            bin (that will also occupy 2 bits with possible values 0, 1, 2 or 3).</param>
            <param name="scoreType">The default HARRIS_SCORE means that Harris algorithm is used to rank features
            (the score is written to KeyPoint::score and is used to retain best nfeatures features);
            FAST_SCORE is alternative value of the parameter that produces slightly less stable keypoints,
            but it is a little faster to compute.</param>
            <param name="patchSize">size of the patch used by the oriented BRIEF descriptor. Of course, on smaller
            pyramid layers the perceived image area covered by a feature will be larger.</param>
            <param name="fastThreshold">the fast threshold</param>
        </member>
        <member name="M:ST4IVisionCoreNet.ORB.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.MaxFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.ScaleFactor">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.NLevels">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.EdgeThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.FirstLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.WTA_K">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.ScoreType">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.PatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ORB.FastThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Features2D.SIFT">
            <summary>
            SIFT implementation.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Features2D.SIFT.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::SIFT*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Features2D.SIFT.Create(System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            The SIFT constructor.
            </summary>
            <param name="nFeatures">The number of best features to retain. 
            The features are ranked by their scores (measured in SIFT algorithm as the local contrast)</param>
            <param name="nOctaveLayers">The number of layers in each octave. 3 is the value used in D. Lowe paper. 
            The number of octaves is computed automatically from the image resolution.</param>
            <param name="contrastThreshold">The contrast threshold used to filter out weak features in semi-uniform 
            (low-contrast) regions. The larger the threshold, the less features are produced by the detector.</param>
            <param name="edgeThreshold">The threshold used to filter out edge-like features. Note that the its meaning is 
            different from the contrastThreshold, i.e. the larger the edgeThreshold, the less features are filtered out (more features are retained).</param>
            <param name="sigma">The sigma of the Gaussian applied to the input image at the octave #0. 
            If your image is captured with a weak camera with soft lenses, you might want to reduce the number.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Features2D.SIFT.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.SimpleBlobDetector">
            <summary>
            Class for extracting blobs from an image.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.SimpleBlobDetector.Params">
            <summary>
            SimpleBlobDetector parameters
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SimpleBlobDetector.Params.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SimpleBlobDetector.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SimpleBlobDetector.Create(ST4IVisionCoreNet.SimpleBlobDetector.Params)">
            <summary>
            Construct a SimpleBlobDetector instance
            </summary>
            <param name="parameters"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SimpleBlobDetector.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.FlannCentersInit">
            <summary>
            The algorithm to use for selecting the initial centers when performing a k-means clustering step. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Flann.FlannCentersInit.Random">
            <summary>
            picks the initial cluster centers randomly
            [flann_centers_init_t::CENTERS_RANDOM]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Flann.FlannCentersInit.Gonzales">
            <summary>
            picks the initial centers using Gonzales’ algorithm
            [flann_centers_init_t::CENTERS_GONZALES]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Flann.FlannCentersInit.KMeansPP">
            <summary>
            picks the initial centers using the algorithm suggested in [arthur_kmeanspp_2007]
            [flann_centers_init_t::CENTERS_KMEANSPP]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.Index">
            <summary>
            The FLANN nearest neighbor index class. 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.#ctor(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Flann.IndexParams,ST4IVisionCoreNet.Flann.FlannDistance)">
            <summary>
            Constructs a nearest neighbor search index for a given dataset.
            </summary>
            <param name="features">features – Matrix of type CV _ 32F containing the features(points) to index. The size of the matrix is num _ features x feature _ dimensionality.</param>
            <param name="params">Structure containing the index parameters. The type of index that will be constructed depends on the type of this parameter. </param>
            <param name="distType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.KnnSearch(System.Single[],System.Int32[]@,System.Single[]@,System.Int32,ST4IVisionCoreNet.Flann.SearchParams)">
            <summary>
            Performs a K-nearest neighbor search for multiple query points.
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.KnnSearch(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Int32,ST4IVisionCoreNet.Flann.SearchParams)">
            <summary>
            Performs a K-nearest neighbor search for multiple query points.
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.KnnSearch(ST4IVisionCoreNet.Mat,System.Int32[]@,System.Single[]@,System.Int32,ST4IVisionCoreNet.Flann.SearchParams)">
            <summary>
            Performs a K-nearest neighbor search for multiple query points.
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.RadiusSearch(System.Single[],System.Int32[],System.Single[],System.Double,System.Int32,ST4IVisionCoreNet.Flann.SearchParams)">
            <summary>
            Performs a radius nearest neighbor search for a given query point.
            </summary>
            <param name="queries">The query point</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="radius">Number of nearest neighbors to search for</param>
            <param name="maxResults"></param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.RadiusSearch(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Double,System.Int32,ST4IVisionCoreNet.Flann.SearchParams)">
            <summary>
            Performs a radius nearest neighbor search for a given query point.
            </summary>
            <param name="queries">The query point</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="radius">Number of nearest neighbors to search for</param>
            <param name="maxResults"></param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.RadiusSearch(ST4IVisionCoreNet.Mat,System.Int32[],System.Single[],System.Double,System.Int32,ST4IVisionCoreNet.Flann.SearchParams)">
            <summary>
            Performs a radius nearest neighbor search for a given query point.
            </summary>
            <param name="queries">The query point</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="radius">Number of nearest neighbors to search for</param>
            <param name="maxResults"></param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.Index.Save(System.String)">
            <summary>
            Saves the index to a file.
            </summary>
            <param name="filename">The file to save the index to</param>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.AutotunedIndexParams">
            <summary>
            hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.AutotunedIndexParams.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="targetPrecision">Is a number between 0 and 1 specifying the percentage of the approximate nearest-neighbor searches that return the exact nearest-neighbor. 
            Using a higher value for this parameter gives more accurate results, but the search takes longer. The optimum value usually depends on the application.</param>
            <param name="buildWeight">Specifies the importance of the index build time raported to the nearest-neighbor search time. 
            In some applications it’s acceptable for the index build step to take a long time if the subsequent searches in the index can be performed very fast. 
            In other applications it’s required that the index be build as fast as possible even if that leads to slightly longer search times.</param>
            <param name="memoryWeight">Is used to specify the tradeoff between time (index build time and search time) and memory used by the index. 
            A value less than 1 gives more importance to the time spent and a value greater than 1 gives more importance to the memory usage.</param>
            <param name="sampleFraction">Is a number between 0 and 1 indicating what fraction of the dataset to use in the automatic parameter configuration algorithm. 
            Running the algorithm on the full dataset gives the most accurate results, but for very large datasets can take longer than desired. 
            In such case using just a fraction of the data helps speeding up this algorithm while still giving good approximations of the optimum parameters.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.AutotunedIndexParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.CompositeIndexParams">
            <summary>
            When using a parameters object of this type the index created combines the randomized kd-trees and the hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.CompositeIndexParams.#ctor(System.Int32,System.Int32,System.Int32,ST4IVisionCoreNet.Flann.FlannCentersInit,System.Single)">
            <summary>
            
            </summary>
            <param name="trees">The number of parallel kd-trees to use. Good values are in the range [1..16]</param>
            <param name="branching">The branching factor to use for the hierarchical k-means tree</param>
            <param name="iterations">The maximum number of iterations to use in the k-means clustering stage when building the k-means tree. A value of -1 used here means that the k-means clustering should be iterated until convergence</param>
            <param name="centersInit">The algorithm to use for selecting the initial centers when performing a k-means clustering step. </param>
            <param name="cbIndex">This parameter (cluster boundary index) influences the way exploration is performed in the hierarchical kmeans tree. When cb_index is zero the next kmeans domain to be explored is choosen to be the one with the closest center. A value greater then zero also takes into account the size of the domain.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.CompositeIndexParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.IndexParams">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.GetString(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.GetInt(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.GetDouble(System.String,System.Double)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.SetString(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.SetInt(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.SetDouble(System.String,System.Double)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.SetFloat(System.String,System.Single)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.SetBool(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.IndexParams.SetAlgorithm(System.Int32)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.KDTreeIndexParams">
            <summary>
            When passing an object of this type the index constructed will consist of a set
            of randomized kd-trees which will be searched in parallel.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.KDTreeIndexParams.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="trees">The number of parallel kd-trees to use. Good values are in the range [1..16]</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.KDTreeIndexParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.KMeansIndexParams">
            <summary>
            When passing an object of this type the index constructed will be a hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.KMeansIndexParams.#ctor(System.Int32,System.Int32,ST4IVisionCoreNet.Flann.FlannCentersInit,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="branching">The branching factor to use for the hierarchical k-means tree</param>
            <param name="iterations">The maximum number of iterations to use in the k-means clustering stage when building the k-means tree. A value of -1 used here means that the k-means clustering should be iterated until convergence</param>
            <param name="centersInit">The algorithm to use for selecting the initial centers when performing a k-means clustering step. </param>
            <param name="cbIndex">This parameter (cluster boundary index) influences the way exploration is performed in the hierarchical kmeans tree. When cb_index is zero the next kmeans domain to be explored is choosen to be the one with the closest center. A value greater then zero also takes into account the size of the domain.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.KMeansIndexParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.LinearIndexParams">
            <summary>
            the index will perform a linear, brute-force search.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.LinearIndexParams.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.LinearIndexParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.LshIndexParams">
            <summary>
            When using a parameters object of this type the index created uses multi-probe LSH (by Multi-Probe LSH: Efficient Indexing for High-Dimensional Similarity Search by Qin Lv, William Josephson, Zhe Wang, Moses Charikar, Kai Li., Proceedings of the 33rd International Conference on Very Large Data Bases (VLDB). Vienna, Austria. September 2007)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.LshIndexParams.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="tableNumber">The number of hash tables to use (between 10 and 30 usually).</param>
            <param name="keySize">The size of the hash key in bits (between 10 and 20 usually).</param>
            <param name="multiProbeLevel">The number of bits to shift to check for neighboring buckets (0 is regular LSH, 2 is recommended).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.LshIndexParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.SavedIndexParams">
            <summary>
            This object type is used for loading a previously saved index from the disk.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.SavedIndexParams.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.SavedIndexParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Flann.SearchParams">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.SearchParams.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            
            </summary>
            <param name="checks"></param>
            <param name="eps"></param>
            <param name="sorted"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Flann.SearchParams.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CvTrackbar">
            <summary>
            Trackbar that is shown on OpenCV Window
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CvTrackbar.TrackbarName">
            <summary>
            Name of this trackbar
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CvTrackbar.WindowName">
            <summary>
            Name of parent window
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CvTrackbar.Callback">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CvTrackbar.Pos">
            <summary>
            Gets or sets a numeric value that represents the current position of the scroll box on the track bar. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CvTrackbar.Result">
            <summary>
            Result value of cv::createTrackbar
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CvTrackbar.#ctor(System.String,System.String,ST4IVisionCoreNet.TrackbarCallback)">
            <summary>
            Constructor (value=0, max=100)
            </summary>
            <param name="name">Trackbar name</param>
            <param name="window">Window name</param>
            <param name="callback">Callback handler</param>
        </member>
        <member name="M:ST4IVisionCoreNet.CvTrackbar.#ctor(System.String,System.String,System.Int32,System.Int32,ST4IVisionCoreNet.TrackbarCallback)">
            <summary>
            Constructor
            </summary>
            <param name="trackbarName">Trackbar name</param>
            <param name="windowName">Window name</param>
            <param name="initialPos">Initial slider position</param>
            <param name="max">The upper limit of the range this trackbar is working with. </param>
            <param name="callback">Callback handler</param>
        </member>
        <member name="M:ST4IVisionCoreNet.CvTrackbar.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CvTrackbar.SetMax(System.Int32)">
            <summary>
            Sets the trackbar maximum position.
            The function sets the maximum position of the specified trackbar in the specified window.
            </summary>
            <param name="maxVal">New maximum position.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.CvTrackbar.SetMin(System.Int32)">
            <summary>
            Sets the trackbar minimum position.
            The function sets the minimum position of the specified trackbar in the specified window.
            </summary>
            <param name="minVal">New minimum position.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.ButtonType">
            <summary>
            Button type flags (cv::createButton)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ButtonType.PushButton">
            <summary>
            The button will be a push button.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ButtonType.Checkbox">
            <summary>
            The button will be a checkbox button.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ButtonType.Radiobox">
            <summary>
            The button will be a radiobox button. The radiobox on the same buttonbar (same line) are exclusive; one on can be select at the time.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MouseEventFlags">
            <summary>
            Mouse Event Flags see cv::MouseCallback
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventFlags.LButton">
            <summary>
            indicates that the left mouse button is down.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventFlags.RButton">
            <summary>
            indicates that the right mouse button is down.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventFlags.MButton">
            <summary>
            indicates that the middle mouse button is down.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventFlags.CtrlKey">
            <summary>
            indicates that CTRL Key is pressed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventFlags.ShiftKey">
            <summary>
            indicates that SHIFT Key is pressed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventFlags.AltKey">
            <summary>
            indicates that ALT Key is pressed.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MouseEventTypes">
            <summary>
            Mouse Events 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.MouseMove">
            <summary>
            indicates that the mouse pointer has moved over the window.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.LButtonDown">
            <summary>
            indicates that the left mouse button is pressed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.RButtonDown">
            <summary>
            indicates that the right mouse button is pressed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.MButtonDown">
            <summary>
            indicates that the middle mouse button is pressed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.LButtonUp">
            <summary>
            indicates that left mouse button is released.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.RButtonUp">
            <summary>
            indicates that right mouse button is released.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.MButtonUp">
            <summary>
            indicates that middle mouse button is released.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.LButtonDoubleClick">
            <summary>
            indicates that left mouse button is double clicked.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.RButtonDoubleClick">
            <summary>
            indicates that right mouse button is double clicked.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.MButtonDoubleClick">
            <summary>
            indicates that middle mouse button is double clicked.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.MouseWheel">
            <summary>
            positive and negative values mean forward and backward scrolling, respectively.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MouseEventTypes.MouseHWheel">
            <summary>
            positive and negative values mean right and left scrolling, respectively.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.WindowFlags">
            <summary>
            Flags for cv::namedWindow
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowFlags.Normal">
            <summary>
            the user can resize the window (no constraint) / 
            also use to switch a fullscreen window to a normal size
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowFlags.AutoSize">
            <summary>
            the user cannot resize the window, the size is constrainted by the image displayed.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowFlags.OpenGL">
            <summary>
            window with opengl support
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowFlags.FullScreen">
            <summary>
            change the window to fullscreen
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowFlags.FreeRatio">
            <summary>
            the image expends as much as it can (no ratio constraint)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowFlags.KeepRatio">
            <summary>
            the ratio of the image is respected
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowFlags.GuiExpanded">
            <summary>
            status bar and tool bar
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowFlags.GuiNormal">
            <summary>
            old fashious way
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.WindowPropertyFlags">
            <summary>
            Property identifiers for cvGetWindowProperty/cvSetWindowProperty
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowPropertyFlags.Fullscreen">
            <summary>
            fullscreen property (can be WINDOW_NORMAL or WINDOW_FULLSCREEN)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowPropertyFlags.AutoSize">
            <summary>
            autosize property (can be WINDOW_NORMAL or WINDOW_AUTOSIZE)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowPropertyFlags.AspectRatio">
            <summary>
            window's aspect ration (can be set to WINDOW_FREERATIO or WINDOW_KEEPRATIO)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowPropertyFlags.OpenGL">
            <summary>
            opengl support
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowPropertyFlags.Visible">
            <summary>
            checks whether the window exists and is visible
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WindowPropertyFlags.Topmost">
            <summary>
            property to toggle normal window being topmost or not
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MouseCallback">
            <summary>
            Delegate to be called every time mouse event occurs in the specified window.
            </summary>
            <param name="event">one of MouseEventTypes</param>
            <param name="x">x-coordinates of mouse pointer in image coordinates</param>
            <param name="y">y-coordinates of mouse pointer in image coordinates</param>
            <param name="flags">a combination of MouseEventFlags</param>
            <param name="userData"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.TrackbarCallback">
            <summary>
            Delegate to be called every time the slider changes the position.
            </summary>
            <param name="pos"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.TrackbarCallbackNative">
            <summary>
            
            </summary>
            <param name="pos"></param>
            <param name="userData"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Window">
            <summary>
            Wrapper of HighGUI window
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.#ctor">
            <summary>
            Creates a window with a random name
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.#ctor(System.String)">
            <summary>
            Creates a window
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.#ctor(System.String,ST4IVisionCoreNet.WindowFlags)">
            <summary>
            Creates a window
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption. </param>
            <param name="flags">Flags of the window. Currently the only supported flag is WindowMode.AutoSize. 
            If it is set, window size is automatically adjusted to fit the displayed image (see cvShowImage), while user can not change the window size manually. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.#ctor(System.String,ST4IVisionCoreNet.Mat)">
            <summary>
            Creates a window
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption. </param>
            <param name="image">Image to be shown.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.#ctor(System.String,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.WindowFlags)">
            <summary>
            Creates a window
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption. </param>
            <param name="image">Image to be shown.</param>
            <param name="flags">Flags of the window. Currently the only supported flag is WindowMode.AutoSize. 
            If it is set, window size is automatically adjusted to fit the displayed image (see cvShowImage), while user can not change the window size manually. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.DefaultName">
            <summary>
            ウィンドウ名が指定されなかったときに、適当な名前を作成して返す.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.Close">
            <summary>
            Destroys this window. 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.DestroyAllWindows">
            <summary>
            Destroys all the opened HighGUI windows. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Window.Image">
            <summary>
            Gets or sets an image to be shown
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Window.Name">
            <summary>
            Gets window name
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Window.MouseCallback">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.CreateTrackbar(System.String,ST4IVisionCoreNet.TrackbarCallback)">
            <summary>
            Creates the trackbar and attaches it to this window
            </summary>
            <param name="trackbarName">Name of created trackbar. </param>
            <param name="callback">the function to be called every time the slider changes the position. This function should be prototyped as void Foo(int);</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.CreateTrackbar(System.String,System.Int32,System.Int32,ST4IVisionCoreNet.TrackbarCallback)">
            <summary>
            Creates the trackbar and attaches it to this window
            </summary>
            <param name="trackbarName">Name of created trackbar. </param>
            <param name="initialPos">The position of the slider</param>
            <param name="max">Maximal position of the slider. Minimal position is always 0. </param>
            <param name="callback">the function to be called every time the slider changes the position. This function should be prototyped as void Foo(int);</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.DisplayOverlay(System.String,System.Int32)">
            <summary>
            Display text on the window's image as an overlay for delay milliseconds. This is not editing the image's data. The text is display on the top of the image.
            </summary>
            <param name="text">Overlay text to write on the window’s image</param>
            <param name="delayMs">Delay to display the overlay text. If this function is called before the previous overlay text time out, the timer is restarted and the text updated.
            If this value is zero, the text never disappears.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.DisplayStatusBar(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="text">Text to write on the window’s statusbar</param>
            <param name="delayms">Delay to display the text. If this function is called before the previous text time out, the timer is restarted and the text updated. If this value is zero, the text never disapers.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.GetProperty(ST4IVisionCoreNet.WindowPropertyFlags)">
            <summary>
            Get Property of the window
            </summary>
            <param name="propId">Property identifier</param>
            <returns>Value of the specified property</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.Move(System.Int32,System.Int32)">
            <summary>
            Sets window position
            </summary>
            <param name="x">New x coordinate of top-left corner </param>
            <param name="y">New y coordinate of top-left corner </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.Resize(System.Int32,System.Int32)">
            <summary>
            Sets window size
            </summary>
            <param name="width">New width </param>
            <param name="height">New height </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.SetProperty(ST4IVisionCoreNet.WindowPropertyFlags,System.Double)">
            <summary>
            Set Property of the window
            </summary>
            <param name="propId">Property identifier</param>
            <param name="propValue">New value of the specified property</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.ShowImage(ST4IVisionCoreNet.Mat)">
            <summary>
            Shows the image in this window
            </summary>
            <param name="img">Image to be shown. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.ShowImage(ST4IVisionCoreNet.UMat)">
            <summary>
            Shows the image in this window
            </summary>
            <param name="img">Image to be shown. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.GetHandle">
            <summary>
            get native window handle (HWND in case of Win32 and Widget in case of X Window) 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.WaitKey(System.Int32)">
            <summary>
            Waits for a pressed key
            </summary>
            <param name="delay">Delay in milliseconds. </param>
            <returns>Key code</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.WaitKeyEx(System.Int32)">
            <summary>
            Waits for a pressed key.
            Similar to #waitKey, but returns full key code. 
            Key code is implementation specific and depends on used backend: QT/GTK/Win32/etc
            </summary>
            <param name="delay">Delay in milliseconds. 0 is the special value that means ”forever”</param>
            <returns>Returns the code of the pressed key or -1 if no key was pressed before the specified time had elapsed.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.ShowImages(ST4IVisionCoreNet.Mat[])">
            <summary>
            
            </summary>
            <param name="images"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.ShowImages(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="images"></param>
            <param name="names"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.GetWindowByName(System.String)">
            <summary>
            Retrieves a created window by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Window.SetMouseCallback(ST4IVisionCoreNet.MouseCallback,System.IntPtr)">
            <summary>
            Sets the callback function for mouse events occuting within the specified window.
            </summary>
            <param name="onMouse">Reference to the function to be called every time mouse event occurs in the specified window. </param>
            <param name="userData"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.ConvertImageModes">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConvertImageModes.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConvertImageModes.Flip">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConvertImageModes.SwapRB">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImreadModes">
            <summary>
            Specifies colorness and Depth of the loaded image
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.Unchanged">
            <summary>
            If set, return the loaded image as is (with alpha channel, otherwise it gets cropped).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.Grayscale">
            <summary>
            If set, always convert image to the single channel grayscale image.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.Color">
            <summary>
            If set, always convert image to the 3 channel BGR color image.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.AnyDepth">
            <summary>
            If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.AnyColor">
            <summary>
            If set, the image is read in any possible color format.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.LoadGdal">
            <summary>
            If set, use the gdal driver for loading the image.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.ReducedGrayscale2">
            <summary>
            If set, always convert image to the single channel grayscale image and the image size reduced 1/2.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.ReducedColor2">
            <summary>
            If set, always convert image to the 3 channel BGR color image and the image size reduced 1/2.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.ReducedGrayscale4">
            <summary>
            If set, always convert image to the single channel grayscale image and the image size reduced 1/4.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.ReducedColor4">
            <summary>
            If set, always convert image to the 3 channel BGR color image and the image size reduced 1/4.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.ReducedGrayscale8">
            <summary>
            If set, always convert image to the single channel grayscale image and the image size reduced 1/8.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.ReducedColor8">
            <summary>
            If set, always convert image to the 3 channel BGR color image and the image size reduced 1/8.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImreadModes.IgnoreOrientation">
            <summary>
            If set, do not rotate the image according to EXIF's orientation flag.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImwriteEXRTypeFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteEXRTypeFlags.TypeHalf">
            <summary>
            store as HALF (FP16)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteEXRTypeFlags.TypeFloat">
            <summary>
            store as FP32 (default)
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImwriteFlags">
            <summary>
            The format type IDs for cv::imwrite and cv::inencode
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.JpegQuality">
            <summary>
            For JPEG, it can be a quality from 0 to 100 (the higher is the better). Default value is 95.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.JpegProgressive">
            <summary>
            Enable JPEG features, 0 or 1, default is False.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.JpegOptimize">
            <summary>
            Enable JPEG features, 0 or 1, default is False.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.JpegRstInterval">
            <summary>
            JPEG restart interval, 0 - 65535, default is 0 - no restart.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.JpegLumaQuality">
            <summary>
            Separate luma quality level, 0 - 100, default is 0 - don't use.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.JpegChromaQuality">
            <summary>
            Separate chroma quality level, 0 - 100, default is 0 - don't use.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.PngCompression">
            <summary>
            For PNG, it can be the compression level from 0 to 9. 
            A higher value means a smaller size and longer compression time. Default value is 3.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.PngStrategy">
            <summary>
            One of cv::ImwritePNGFlags, default is IMWRITE_PNG_StrategyDEFAULT.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.PngBilevel">
            <summary>
            Binary level PNG, 0 or 1, default is 0.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.PxmBinary">
            <summary>
            For PPM, PGM, or PBM, it can be a binary format flag, 0 or 1. Default value is 1.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.ExrType">
            <summary>
            [48] override EXR storage type (FLOAT (FP32) is default)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.WebPQuality">
            <summary>
            For WEBP, it can be a quality from 1 to 100 (the higher is the better). By default (without any parameter) and for quality above 100 the lossless compression is used.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.PamTupleType">
            <summary>
            For PAM, sets the TUPLETYPE field to the corresponding string value that is defined for the format
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.TiffResUnit">
            <summary>
            For TIFF, use to specify which DPI resolution unit to set; see libtiff documentation for valid values
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.TiffXDpi">
            <summary>
            For TIFF, use to specify the X direction DPI
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.TiffYDpi">
            <summary>
            For TIFF, use to specify the Y direction DPI
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.TiffCompression">
            <summary>
            For TIFF, use to specify the image compression scheme. 
            See libtiff for integer constants corresponding to compression formats. 
            Note, for images whose depth is CV_32F, only libtiff's SGILOG compression scheme is used. 
            For other supported depths, the compression scheme can be specified by this flag; LZW compression is the default.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwriteFlags.Jpeg2000CompressionX1000">
            <summary>
            For JPEG2000, use to specify the target compression rate (multiplied by 1000). 
            The value can be from 0 to 1000. Default is 1000.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImwritePAMFlags">
            <summary>
            Imwrite PAM specific tupletype flags used to define the 'TUPETYPE' field of a PAM file.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImwritePNGFlags">
            <summary>
            Imwrite PNG specific flags used to tune the compression algorithm.
            
            These flags will be modify the way of PNG image compression and will be passed to the underlying zlib processing stage.
            The effect of IMWRITE_PNG_StrategyFILTERED is to force more Huffman coding and less string matching; it is somewhat 
            intermediate between IMWRITE_PNG_StrategyDEFAULT and IMWRITE_PNG_StrategyHUFFMAN_ONLY.
            IMWRITE_PNG_StrategyRLE is designed to be almost as fast as IMWRITE_PNG_StrategyHUFFMAN_ONLY, but give better compression for PNG 
            image data. The strategy parameter only affects the compression ratio but not the correctness of the compressed output even 
            if it is not set appropriately. IMWRITE_PNG_StrategyFIXED prevents the use of dynamic Huffman codes, allowing for a simpler 
            decoder for special applications.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwritePNGFlags.StrategyDefault">
            <summary>
            Use this value for normal data.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwritePNGFlags.StrategyFiltered">
            <summary>
            Use this value for data produced by a filter (or predictor).Filtered data consists mostly of small values with a somewhat 
            random distribution. In this case, the compression algorithm is tuned to compress them better.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwritePNGFlags.StrategyHuffmanOnly">
            <summary>
            Use this value to force Huffman encoding only (no string match).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwritePNGFlags.StrategyRLE">
            <summary>
            Use this value to limit match distances to one (run-length encoding).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImwritePNGFlags.StrategyFixed">
            <summary>
            Using this value prevents the use of dynamic Huffman codes, allowing for a simpler decoder for special applications.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImageEncodingParam">
            <summary>
            The format-specific save parameters for cv::imwrite and cv::imencode
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ImageEncodingParam.EncodingId">
            <summary>
            format type ID
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ImageEncodingParam.Value">
            <summary>
            value of parameter
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImageEncodingParam.#ctor(ST4IVisionCoreNet.ImwriteFlags,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="id">format type ID</param>
            <param name="value">value of parameter</param>
        </member>
        <member name="T:ST4IVisionCoreNet.CLAHE">
            <summary>
            Contrast Limited Adaptive Histogram Equalization
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CLAHE.ptrObj">
            <summary>
            cv::Ptr&lt;CLAHE&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CLAHE.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CLAHE.Create(System.Double,System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            Creates a predefined CLAHE object
            </summary>
            <param name="clipLimit"></param>
            <param name="tileGridSize"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CLAHE.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CLAHE.Apply(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Equalizes the histogram of a grayscale image using Contrast Limited Adaptive Histogram Equalization.
            </summary>
            <param name="src">Source image of type CV_8UC1 or CV_16UC1.</param>
            <param name="dst">Destination image.</param>
        </member>
        <member name="P:ST4IVisionCoreNet.CLAHE.ClipLimit">
            <summary>
            Gets or sets threshold for contrast limiting.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CLAHE.TilesGridSize">
            <summary>
            Gets or sets size of grid for histogram equalization. Input image will be divided into equally sized rectangular tiles.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CLAHE.CollectGarbage">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ConnectedComponents">
            <summary>
            connected components that is returned from Sv.ConnectedComponentsEx
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blobs">
            <summary>
            All blobs
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Labels">
            <summary>
            destination labeled value
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.LabelCount">
            <summary>
            The number of labels -1
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ConnectedComponents.#ctor(System.Collections.Generic.IReadOnlyList{ST4IVisionCoreNet.ConnectedComponents.Blob},System.Int32[0:,0:],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="blobs"></param>
            <param name="labels"></param>
            <param name="labelCount"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.ConnectedComponents.FilterByLabel(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Int32)">
            <summary>
            Filter a image with the specified label value. 
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="labelValue">Label value.</param>
            <returns>Filtered image.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ConnectedComponents.FilterByLabels(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Filter a image with the specified label values. 
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="labelValues">Label values.</param>
            <returns>Filtered image.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ConnectedComponents.FilterByBlob(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.ConnectedComponents.Blob)">
            <summary>
            Filter a image with the specified blob object. 
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="blob">Blob value.</param>
            <returns>Filtered image.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ConnectedComponents.FilterByBlobs(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.ConnectedComponents.Blob})">
            <summary>
            Filter a image with the specified blob objects. 
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="blobs">Blob values.</param>
            <returns>Filtered image.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ConnectedComponents.RenderBlobs(ST4IVisionCoreNet.Mat)">
            <summary>
            Draws all blobs to the specified image.
            </summary>
            <param name="img">The target image to be drawn.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.ConnectedComponents.GetLargestBlob">
            <summary>
            Find the largest blob.
            </summary>
            <returns>the largest blob</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ConnectedComponents.GetLabelMask(System.Int32)">
            <summary>
            指定したラベル値のところのみを非0で残したマスク画像を返す
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ConnectedComponents.Blob">
            <summary>
            One blob
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blob.Label">
            <summary>
            Label value
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blob.Centroid">
            <summary>
            Floating point centroid (x,y)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blob.Left">
            <summary>
            The leftmost (x) coordinate which is the inclusive start of the bounding box in the horizontal direction.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blob.Top">
            <summary>
            The topmost (y) coordinate which is the inclusive start of the bounding box in the vertical direction.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blob.Width">
            <summary>
            The horizontal size of the bounding box.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blob.Height">
            <summary>
            The vertical size of the bounding box.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blob.Rect">
            <summary>
            The bounding box.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ConnectedComponents.Blob.Area">
            <summary>
            The total area (in pixels) of the connected component.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.AdaptiveThresholdTypes">
             <summary>
             Adaptive thresholding algorithms
             </summary>
             <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L333
             </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.AdaptiveThresholdTypes.MeanC">
            <summary>
            It is a mean of block_size × block_size pixel neighborhood, subtracted by param1.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.AdaptiveThresholdTypes.GaussianC">
            <summary>
            it is a weighted sum (Gaussian) of block_size × block_size pixel neighborhood, subtracted by param1.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ColorConversionCodes">
             <summary>
             Color conversion operation for cv::cvtColor
             </summary>
             <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L528
             </remarks>
        </member>
        <member name="T:ST4IVisionCoreNet.ColormapTypes">
            <summary>
            GNU Octave/MATLAB equivalent colormaps
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes">
            <summary>
            connected components algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes.WU">
            <summary>
            SAUF algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes.Default">
            <summary>
            BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes.GRANA">
            <summary>
            BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes.BOLELLI">
            <summary>
            Spaghetti @cite Bolelli2019 algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes.SAUF">
            <summary>
            Same as CCL_WU. It is preferable to use the flag with the name of the algorithm (CCL_SAUF) rather than the one with the name of the first author (CCL_WU).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes.BBDT">
            <summary>
            Same as CCL_GRANA. It is preferable to use the flag with the name of the algorithm (CCL_BBDT) rather than the one with the name of the first author (CCL_GRANA).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsAlgorithmsTypes.SPAGHETTI">
            <summary>
            Same as CCL_BOLELLI. It is preferable to use the flag with the name of the algorithm (CCL_SPAGHETTI) rather than the one with the name of the first author (CCL_BOLELLI).
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ConnectedComponentsTypes">
            <summary>
            components algorithm output formats
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsTypes.Left">
            <summary>
            The leftmost (x) coordinate which is the inclusive start of the bounding
            box in the horizontal direction.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsTypes.Top">
            <summary>
            The topmost (y) coordinate which is the inclusive start of the bounding
            box in the vertical direction.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsTypes.Width">
            <summary>
            The horizontal size of the bounding box
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsTypes.Height">
            <summary>
            The vertical size of the bounding box
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ConnectedComponentsTypes.Area">
            <summary>
            The total area (in pixels) of the connected component
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ContourApproximationModes">
            <summary>
            Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). 
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L431
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.ContourApproximationModes.ApproxNone">
            <summary>
            CHAIN_APPROX_NONE - translate all the points from the chain code into points; 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ContourApproximationModes.ApproxSimple">
            <summary>
            CHAIN_APPROX_SIMPLE - compress horizontal, vertical, and diagonal segments, that is, the function leaves only their ending points; 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ContourApproximationModes.ApproxTC89L1">
            <summary>
            CHAIN_APPROX_TC89_L1 - apply one of the flavors of Teh-Chin chain approximation algorithm. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ContourApproximationModes.ApproxTC89KCOS">
            <summary>
            CHAIN_APPROX_TC89_KCOS - apply one of the flavors of Teh-Chin chain approximation algorithm. 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DistanceTransformLabelTypes">
            <summary>
            distanceTransform algorithm flags
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTransformLabelTypes.CComp">
            <summary>
            each connected component of zeros in src 
            (as well as all the non-zero pixels closest to the connected component) 
            will be assigned the same label 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTransformLabelTypes.Pixel">
            <summary>
            each zero pixel (and all the non-zero pixels closest to it) gets its own label.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DistanceTransformMasks">
            <summary>
            Mask size for distance transform
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L312
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTransformMasks.Mask3">
            <summary>
            3
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTransformMasks.Mask5">
            <summary>
            5
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTransformMasks.Precise">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DistanceTypes">
            <summary>
            Type of distance for cvDistTransform
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L300
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTypes.User">
            <summary>
            User defined distance  [CV_DIST_USER]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTypes.L1">
            <summary>
            distance = |x1-x2| + |y1-y2|  [CV_DIST_L1]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTypes.L2">
            <summary>
            the simple euclidean distance  [CV_DIST_L2]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTypes.C">
            <summary>
            distance = max(|x1-x2|,|y1-y2|)  [CV_DIST_C]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTypes.L12">
            <summary>
            L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1))  [CV_DIST_L12]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTypes.Fair">
            <summary>
            distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998  [CV_DIST_FAIR]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTypes.Welsch">
            <summary>
            distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846  [CV_DIST_WELSCH]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DistanceTypes.Huber">
            <summary>
            distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345  [CV_DIST_HUBER]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FlipMode">
            <summary>
            Specifies how to flip the array
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FlipMode.X">
            <summary>
            means flipping around x-axis
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FlipMode.Y">
            <summary>
            means flipping around y-axis
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FlipMode.XY">
            <summary>
            means flipping around both axises
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FloodFillFlags">
            <summary>
            floodFill Operation flags. Lower bits contain a connectivity value, 4 (default) or 8, used within the function. Connectivity determines which neighbors of a pixel are considered. Upper bits can be 0 or a combination of the following flags:
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FloodFillFlags.Link4">
            <summary>
            4-connected line.
            [= 4]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FloodFillFlags.Link8">
            <summary>
            8-connected line.
            [= 8]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FloodFillFlags.FixedRange">
            <summary>
            If set, the difference between the current pixel and seed pixel is considered. Otherwise, the difference between neighbor pixels is considered (that is, the range is floating).
            [CV_FLOODFILL_FIXED_RANGE]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FloodFillFlags.MaskOnly">
            <summary>
            If set, the function does not change the image ( newVal is ignored), but fills the mask. The flag can be used for the second variant only.
            [CV_FLOODFILL_MASK_ONLY]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.GrabCutClasses">
            <summary>
            class of the pixel in GrabCut algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GrabCutClasses.BGD">
            <summary>
            an obvious background pixels
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GrabCutClasses.FGD">
            <summary>
            an obvious foreground (object) pixel
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GrabCutClasses.PR_BGD">
            <summary>
            a possible background pixel
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GrabCutClasses.PR_FGD">
            <summary>
            a possible foreground pixel
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.GrabCutModes">
            <summary>
            GrabCut algorithm flags
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GrabCutModes.InitWithRect">
            <summary>
             The function initializes the state and the mask using the provided rectangle. 
            After that it runs iterCount iterations of the algorithm.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GrabCutModes.InitWithMask">
            <summary>
             The function initializes the state using the provided mask. 
            Note that GC_INIT_WITH_RECT and GC_INIT_WITH_MASK can be combined. 
            Then, all the pixels outside of the ROI are automatically initialized with GC_BGD .
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GrabCutModes.Eval">
            <summary>
             The value means that the algorithm should just resume.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.HistCompMethods">
            <summary>
            Comparison methods for cvCompareHist
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L497
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.HistCompMethods.Correl">
            <summary>
            Correlation [CV_COMP_CORREL]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HistCompMethods.Chisqr">
            <summary>
            Chi-Square [CV_COMP_CHISQR]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HistCompMethods.Intersect">
            <summary>
            Intersection [CV_COMP_INTERSECT]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HistCompMethods.Bhattacharyya">
            <summary>
            Bhattacharyya distance [CV_COMP_BHATTACHARYYA]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HistCompMethods.Hellinger">
            <summary>
            Synonym for HISTCMP_BHATTACHARYYA
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HistCompMethods.ChisqrAlt">
            <summary>
            Alternative Chi-Square
            \f[d(H_1,H_2) =  2 * \sum _I  \frac{\left(H_1(I)-H_2(I)\right)^2}{H_1(I)+H_2(I)}\f] 
            This alternative formula is regularly used for texture comparison. See e.g. @cite Puzicha1997 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HistCompMethods.KLDiv">
            <summary>
            Kullback-Leibler divergence 
            \f[d(H_1,H_2) = \sum _I H_1(I) \log \left(\frac{H_1(I)}{H_2(I)}\right)\f] 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.HoughModes">
            <summary>
            Variants of a Hough transform
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L465
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.HoughModes.Standard">
            <summary>
            classical or standard Hough transform. 
            Every line is represented by two floating-point numbers \f$(\rho, \theta)\f$ , 
            where \f$\rho\f$ is a distance between (0,0) point and the line, 
            and \f$\theta\f$ is the angle between x-axis and the normal to the line. 
            Thus, the matrix must be (the created sequence will be) of CV_32FC2 type
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HoughModes.Probabilistic">
            <summary>
            probabilistic Hough transform (more efficient in case if the picture contains 
            a few long linear segments). It returns line segments rather than the whole line. 
            Each segment is represented by starting and ending points, and the matrix must be 
            (the created sequence will be) of the CV_32SC4 type.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HoughModes.MultiScale">
            <summary>
            multi-scale variant of the classical Hough transform. 
            The lines are encoded the same way as HOUGH_STANDARD.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HoughModes.Gradient">
            <summary>
            basically *21HT*, described in @cite Yuen90
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HoughModes.GradientAlt">
            <summary>
            variation of HOUGH_GRADIENT to get better accuracy
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.InterpolationFlags">
            <summary>
            Interpolation algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.Nearest">
            <summary>
            Nearest-neighbor interpolation, 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.Linear">
            <summary>
            Bilinear interpolation (used by default) 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.Cubic">
            <summary>
            Bicubic interpolation. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.Area">
            <summary>
            Resampling using pixel area relation. It is the preferred method for image decimation that gives moire-free results. In case of zooming it is similar to CV_INTER_NN method. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.Lanczos4">
            <summary>
            Lanczos interpolation over 8x8 neighborhood
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.LinearExact">
            <summary>
            Bit exact bilinear interpolation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.Max">
            <summary>
            mask for interpolation codes
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.WarpFillOutliers">
            <summary>
            Fill all the destination image pixels. If some of them correspond to outliers in the source image, they are set to fillval. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InterpolationFlags.WarpInverseMap">
            <summary>
            Indicates that matrix is inverse transform from destination image to source and, 
            thus, can be used directly for pixel interpolation. Otherwise, the function finds the inverse transform from map_matrix. 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.LineSegmentDetectorModes">
            <summary>
            Variants of Line Segment %Detector
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineSegmentDetectorModes.RefineNone">
            <summary>
            No refinement applied
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineSegmentDetectorModes.RefineStd">
            <summary>
            Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineSegmentDetectorModes.RefineAdv">
            <summary>
            Advanced refinement. Number of false alarms is calculated, lines are
            refined through increase of precision, decrement in size, etc.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.LineTypes">
            <summary>
            Type of the line
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L808
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.LineTypes.Link8">
            <summary>
            8-connected line.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineTypes.Link4">
            <summary>
            4-connected line.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineTypes.AntiAlias">
            <summary>
            Anti-aliased line. 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MarkerTypes">
            <summary>
            Possible set of marker types used for the cv::drawMarker function
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MarkerTypes.Cross">
            <summary>
            A crosshair marker shape
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MarkerTypes.TiltedCross">
            <summary>
            A 45 degree tilted crosshair marker shape
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MarkerTypes.Star">
            <summary>
            A star marker shape, combination of cross and tilted cross
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MarkerTypes.Diamond">
            <summary>
            A diamond marker shape
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MarkerTypes.Square">
            <summary>
            A square marker shape
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MarkerTypes.TriangleUp">
            <summary>
            An upwards pointing triangle marker shape
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MarkerTypes.TriangleDown">
            <summary>
            A downwards pointing triangle marker shape
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MorphShapes">
            <summary>
            Shape of the structuring element
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L231
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphShapes.Rect">
            <summary>
            A rectangular element
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphShapes.Cross">
            <summary>
            A cross-shaped element
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphShapes.Ellipse">
            <summary>
            An elliptic element
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MorphTypes">
            <summary>
            Type of morphological operation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphTypes.Erode">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphTypes.Dilate">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphTypes.Open">
            <summary>
            an opening operation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphTypes.Close">
            <summary>
            a closing operation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphTypes.Gradient">
            <summary>
            Morphological gradient
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphTypes.TopHat">
            <summary>
            "Top hat"
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphTypes.BlackHat">
            <summary>
            "Black hat"
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MorphTypes.HitMiss">
            <summary>
            "hit and miss"
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.PixelConnectivity">
            <summary>
            PixelConnectivity for LineIterator
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.PixelConnectivity.Connectivity4">
            <summary>
            Connectivity 4 (N,S,E,W)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.PixelConnectivity.Connectivity8">
            <summary>
            Connectivity 8 (N,S,E,W,NE,SE,SW,NW)
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.RectanglesIntersectTypes">
            <summary>
            types of intersection between rectangles
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RectanglesIntersectTypes.None">
            <summary>
            No intersection
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RectanglesIntersectTypes.Partial">
            <summary>
            There is a partial intersection
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RectanglesIntersectTypes.Full">
            <summary>
            One of the rectangle is fully enclosed in the other
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.RetrievalModes">
            <summary>
            mode of the contour retrieval algorithm
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L414
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.RetrievalModes.External">
            <summary>
            retrieves only the extreme outer contours. 
            It sets `hierarchy[i][2]=hierarchy[i][3]=-1` for all the contours.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RetrievalModes.List">
            <summary>
            retrieves all of the contours without establishing any hierarchical relationships.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RetrievalModes.CComp">
            <summary>
            retrieves all of the contours and organizes them into a two-level hierarchy. 
            At the top level, there are external boundaries of the components. 
            At the second level, there are boundaries of the holes. If there is another 
            contour inside a hole of a connected component, it is still put at the top level.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RetrievalModes.Tree">
            <summary>
            retrieves all of the contours and reconstructs a full hierarchy 
            of nested contours.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.RetrievalModes.FloodFill">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ShapeMatchModes">
            <summary>
            Comparison methods for cv::matchShapes
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L453
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.ShapeMatchModes.I1">
            <summary>
            \f[I_1(A,B) =  \sum _{i=1...7}  \left |  \frac{1}{m^A_i} -  \frac{1}{m^B_i} \right |\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ShapeMatchModes.I2">
            <summary>
            \f[I_2(A,B) =  \sum _{i=1...7}  \left | m^A_i - m^B_i  \right |\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ShapeMatchModes.I3">
            <summary>
            \f[I_3(A,B) =  \max _{i=1...7}  \frac{ \left| m^A_i - m^B_i \right| }{ \left| m^A_i \right| }\f]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.TemplateMatchModes">
            <summary>
            Specifies the way the template must be compared with image regions
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/imgproc/include/opencv2/imgproc.hpp#L3672
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.TemplateMatchModes.SqDiff">
            <summary>
            \f[R(x,y)= \sum _{x',y'} (T(x',y')-I(x+x',y+y'))^2\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TemplateMatchModes.SqDiffNormed">
            <summary>
            \f[R(x,y)= \frac{\sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2}{\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TemplateMatchModes.CCorr">
            <summary>
            \f[R(x,y)= \sum _{x',y'} (T(x',y')  \cdot I(x+x',y+y'))\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TemplateMatchModes.CCorrNormed">
            <summary>
            \f[R(x,y)= \frac{\sum_{x',y'} (T(x',y') \cdot I(x+x',y+y'))}{\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TemplateMatchModes.CCoeff">
            <summary>
            \f[R(x,y)= \sum _{x',y'} (T'(x',y')  \cdot I'(x+x',y+y'))\f]
            where
            \f[\begin{array}{l} T'(x',y')=T(x',y') - 1/(w  \cdot h)  \cdot \sum _{x'',y''} T(x'',y'') \\ I'(x+x',y+y')=I(x+x',y+y') - 1/(w  \cdot h)  \cdot \sum _{x'',y''} I(x+x'',y+y'') \end{array}\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TemplateMatchModes.CCoeffNormed">
            <summary>
            \f[R(x,y)= \frac{ \sum_{x',y'} (T'(x',y') \cdot I'(x+x',y+y')) }{ \sqrt{\sum_{x',y'}T'(x',y')^2 \cdot \sum_{x',y'} I'(x+x',y+y')^2} }\f]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ThresholdTypes">
            <summary>
            Thresholding type
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ThresholdTypes.Binary">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{\texttt{maxval}}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{0}{otherwise}\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ThresholdTypes.BinaryInv">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{0}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{\texttt{maxval}}{otherwise}\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ThresholdTypes.Trunc">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{\texttt{threshold}}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{\texttt{src}(x,y)}{otherwise}\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ThresholdTypes.Tozero">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{\texttt{src}(x,y)}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{0}{otherwise}\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ThresholdTypes.TozeroInv">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{0}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{\texttt{src}(x,y)}{otherwise}\f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ThresholdTypes.Mask">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ThresholdTypes.Otsu">
            <summary>
            flag, use Otsu algorithm to choose the optimal threshold value
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ThresholdTypes.Triangle">
            <summary>
            flag, use Triangle algorithm to choose the optimal threshold value
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.WarpPolarMode">
            <summary>
            Specify the polar mapping mode
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WarpPolarMode.Linear">
            <summary>
            Remaps an image to/from polar space.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.WarpPolarMode.Log">
            <summary>
            Remaps an image to/from semilog-polar space.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.GeneralizedHough">
            <summary>
            finds arbitrary template in the grayscale image using Generalized Hough Transform
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHough.CannyLowThresh">
            <summary>
            Canny low threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHough.CannyHighThresh">
            <summary>
            Canny high threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHough.MinDist">
            <summary>
            Minimum distance between the centers of the detected objects.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHough.Dp">
            <summary>
            Inverse ratio of the accumulator resolution to the image resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHough.MaxBufferSize">
            <summary>
            Maximal size of inner buffers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHough.SetTemplate(ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            set template to search
            </summary>
            <param name="templ"></param>
            <param name="templCenter"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHough.SetTemplate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            set template to search
            </summary>
            <param name="edges"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <param name="templCenter"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHough.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            find template on image
            </summary>
            <param name="image"></param>
            <param name="positions"></param>
            <param name="votes"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHough.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            find template on image
            </summary>
            <param name="edges"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <param name="positions"></param>
            <param name="votes"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.GeneralizedHoughBallard">
            <summary>
            Ballard, D.H. (1981). Generalizing the Hough transform to detect arbitrary shapes. 
            Pattern Recognition 13 (2): 111-122.
            Detects position only without traslation and rotation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GeneralizedHoughBallard.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt; object
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHoughBallard.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHoughBallard.Create">
            <summary>
            Creates a predefined GeneralizedHoughBallard object
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHoughBallard.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughBallard.Levels">
            <summary>
            R-Table levels.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughBallard.VotesThreshold">
            <summary>
            The accumulator threshold for the template centers at the detection stage. 
            The smaller it is, the more false positions may be detected.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.GeneralizedHoughGuil">
            <summary>
            Guil, N., González-Linares, J.M. and Zapata, E.L. (1999). 
            Bidimensional shape detection using an invariant approach. 
            Pattern Recognition 32 (6): 1025-1038.
            Detects position, translation and rotation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.GeneralizedHoughGuil.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt; object
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHoughGuil.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHoughGuil.Create">
            <summary>
            Creates a predefined GeneralizedHoughBallard object
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.GeneralizedHoughGuil.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.Xi">
            <summary>
            Angle difference in degrees between two points in feature.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.Levels">
            <summary>
            Feature table levels.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.AngleEpsilon">
            <summary>
            Maximal difference between angles that treated as equal.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.MinAngle">
            <summary>
            Minimal rotation angle to detect in degrees.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.MaxAngle">
            <summary>
            Maximal rotation angle to detect in degrees.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.AngleStep">
            <summary>
            Angle step in degrees.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.AngleThresh">
            <summary>
            Angle votes threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.MinScale">
            <summary>
            Minimal scale to detect.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.MaxScale">
            <summary>
            Maximal scale to detect.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.ScaleStep">
            <summary>
            Scale step.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.ScaleThresh">
            <summary>
            Scale votes threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.GeneralizedHoughGuil.PosThresh">
            <summary>
            Position votes threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB">
            <summary>
            Intelligent Scissors image segmentation
            
            This class is used to find the path (contour) between two points
            which can be used for image segmentation.
            
            Usage example:
            @snippet snippets/imgproc_segmentation.cpp usage_example_intelligent_scissors
            
            Reference: Intelligent Scissors for Image Composition http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.138.3811&amp;rep=rep1&amp;type=pdf
            algorithm designed by Eric N. Mortensen and William A. Barrett, Brigham Young University
            @cite Mortensen95intelligentscissors
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.SetWeights(System.Single,System.Single,System.Single)">
            <summary>
            Specify weights of feature functions
            
            Consider keeping weights normalized (sum of weights equals to 1.0)
            Discrete dynamic programming (DP) goal is minimization of costs between pixels.
            </summary>
            <param name="weightNonEdge">Specify cost of non-edge pixels (default: 0.43f)</param>
            <param name="weightGradientDirection">Specify cost of gradient direction function (default: 0.43f)</param>
            <param name="weightGradientMagnitude">Specify cost of gradient magnitude function (default: 0.14f)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.SetGradientMagnitudeMaxLimit(System.Single)">
            <summary>
            Specify gradient magnitude max value threshold
            
            Zero limit value is used to disable gradient magnitude thresholding (default behavior, as described in original article).
            Otherwize pixels with `gradient magnitude >= threshold` have zero cost.
            
            @note Thresholding should be used for images with irregular regions (to avoid stuck on parameters from high-contract areas, like embedded logos).
            </summary>
            <param name="gradientMagnitudeThresholdMax">Specify gradient magnitude max value threshold (default: 0, disabled)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.SetEdgeFeatureZeroCrossingParameters(System.Single)">
            <summary>
            Switch to "Laplacian Zero-Crossing" edge feature extractor and specify its parameters
            
            This feature extractor is used by default according to article.
            
            Implementation has additional filtering for regions with low-amplitude noise.
            This filtering is enabled through parameter of minimal gradient amplitude (use some small value 4, 8, 16).
            
            @note Current implementation of this feature extractor is based on processing of grayscale images (color image is converted to grayscale image first).
            
            @note Canny edge detector is a bit slower, but provides better results (especially on color images): use setEdgeFeatureCannyParameters().
            </summary>
            <param name="gradientMagnitudeMinValue">Minimal gradient magnitude value for edge pixels (default: 0, check is disabled)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.SetEdgeFeatureCannyParameters(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Switch edge feature extractor to use Canny edge detector
            Note: "Laplacian Zero-Crossing" feature extractor is used by default (following to original article)
            </summary>
            <param name="threshold1"></param>
            <param name="threshold2"></param>
            <param name="apertureSize"></param>
            <param name="l2gradient"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.ApplyImage(ST4IVisionCoreNet.InputArray)">
            <summary>
            Specify input image and extract image features
            </summary>
            <param name="image">input image. Type is #CV_8UC1 / #CV_8UC3</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.ApplyImageFeatures(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Specify custom features of imput image
            Customized advanced variant of applyImage() call.
            </summary>
            <param name="nonEdge">Specify cost of non-edge pixels. Type is CV_8UC1. Expected values are `{0, 1}`.</param>
            <param name="gradientDirection">Specify gradient direction feature. Type is CV_32FC2. Values are expected to be normalized: `x^2 + y^2 == 1`</param>
            <param name="gradientMagnitude">Specify cost of gradient magnitude function: Type is CV_32FC1. Values should be in range `[0, 1]`.</param>
            <param name="image">Optional parameter. Must be specified if subset of features is specified (non-specified features are calculated internally)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.BuildMap(ST4IVisionCoreNet.Point)">
            <summary>
            Prepares a map of optimal paths for the given source point on the image
            Note: applyImage() / applyImageFeatures() must be called before this call
            </summary>
            <param name="sourcePt">The source point used to find the paths</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Segmentation.IntelligentScissorsMB.GetContour(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            Extracts optimal contour for the given target point on the image
            Note: buildMap() must be called before this call
            </summary>
            <param name="targetPt">The target point</param>
            <param name="contour">contour The list of pixels which contains optimal path between the source and the target points of the image. 
            Type is CV_32SC2 (compatible with `std::vector&lt;Point&gt;`)</param>
            <param name="backward">Flag to indicate reverse order of retrived pixels (use "true" value to fetch points from the target to the source point)</param>
        </member>
        <member name="T:ST4IVisionCoreNet.LineIterator">
            <summary>
            Contrast Limited Adaptive Histogram Equalization
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineIterator.#ctor(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point,ST4IVisionCoreNet.PixelConnectivity,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="img"></param>
            <param name="pt1"></param>
            <param name="pt2"></param>
            <param name="connectivity"></param>
            <param name="leftToRight"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineIterator.Initialize">
            <summary>
            Initializes the iterator
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineIterator.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineIterator.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.Ptr">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.Ptr0">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.Step">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.ElemSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.Err">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.MinusDelta">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.PlusDelta">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.MinusStep">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.PlusStep">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.LineIterator.Pixel">
            <summary>
            LineIterator pixel data
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.Pixel.ValuePointer">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.Pixel.Pos">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineIterator.Pixel.Ptr">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineIterator.Pixel.GetValue``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineIterator.Pixel.SetValue``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineIterator.Pixel.#ctor(ST4IVisionCoreNet.Point,System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="pos"></param>
            <param name="ptr"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.LineSegmentDetector">
            <summary>
            Line segment detector class
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineSegmentDetector.ptrObj">
            <summary>
            cv::Ptr&lt;LineSegmentDetector&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentDetector.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentDetector.Create(ST4IVisionCoreNet.LineSegmentDetectorModes,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Creates a smart pointer to a LineSegmentDetector object and initializes it.
            </summary>
            <param name="refine">The way found lines will be refined, see cv::LineSegmentDetectorModes</param>
            <param name="scale">The scale of the image that will be used to find the lines. Range (0..1].</param>
            <param name="sigmaScale">Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale.</param>
            <param name="quant">Bound to the quantization error on the gradient norm.</param>
            <param name="angTh">Gradient angle tolerance in degrees.</param>
            <param name="logEps">Detection threshold: -log10(NFA) \> log_eps. 
            Used only when advancent refinement is chosen.</param>
            <param name="densityTh">Minimal density of aligned region points in the enclosing rectangle.</param>
            <param name="nBins">Number of bins in pseudo-ordering of gradient modulus.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentDetector.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentDetector.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Finds lines in the input image.
            This is the output of the default parameters of the algorithm on the above shown image.
            </summary>
            <param name="image">A grayscale (CV_8UC1) input image. </param>
            <param name="lines">A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. 
            Where Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly oriented depending on the gradient.</param>
            <param name="width">Vector of widths of the regions, where the lines are found. E.g. Width of line.</param>
            <param name="prec">Vector of precisions with which the lines are found.</param>
            <param name="nfa">Vector containing number of false alarms in the line region, 
            with precision of 10%. The bigger the value, logarithmically better the detection.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentDetector.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Vec4f[]@,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Finds lines in the input image.
            This is the output of the default parameters of the algorithm on the above shown image.
            </summary>
            <param name="image">A grayscale (CV_8UC1) input image. </param>
            <param name="lines">A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. 
            Where Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly oriented depending on the gradient.</param>
            <param name="width">Vector of widths of the regions, where the lines are found. E.g. Width of line.</param>
            <param name="prec">Vector of precisions with which the lines are found.</param>
            <param name="nfa">Vector containing number of false alarms in the line region, 
            with precision of 10%. The bigger the value, logarithmically better the detection.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentDetector.DrawSegments(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Draws the line segments on a given image.
            </summary>
            <param name="image">The image, where the liens will be drawn. 
            Should be bigger or equal to the image, where the lines were found.</param>
            <param name="lines">A vector of the lines that needed to be drawn.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentDetector.CompareSegments(ST4IVisionCoreNet.Size,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray)">
            <summary>
            Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels.
            </summary>
            <param name="size">The size of the image, where lines1 and lines2 were found.</param>
            <param name="lines1">The first group of lines that needs to be drawn. It is visualized in blue color.</param>
            <param name="lines2">The second group of lines. They visualized in red color.</param>
            <param name="image">Optional image, where the lines will be drawn. 
            The image should be color(3-channel) in order for lines1 and lines2 to be drawn 
            in the above mentioned colors.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.CircleSegment">
            <summary>
            circle structure retrieved from cvHoughCircle
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CircleSegment.Center">
            <summary>
            Center coordinate of the circle
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CircleSegment.Radius">
            <summary>
            Radius
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CircleSegment.#ctor(ST4IVisionCoreNet.Point2f,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="center">center</param>
            <param name="radius">radius</param>
        </member>
        <member name="M:ST4IVisionCoreNet.CircleSegment.Equals(ST4IVisionCoreNet.CircleSegment)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="other">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CircleSegment.op_Equality(ST4IVisionCoreNet.CircleSegment,ST4IVisionCoreNet.CircleSegment)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CircleSegment.op_Inequality(ST4IVisionCoreNet.CircleSegment,ST4IVisionCoreNet.CircleSegment)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CircleSegment.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CircleSegment.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CircleSegment.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.HierarchyIndex">
            <summary>
            Information about the image topology for cv::findContours
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HierarchyIndex.Next">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HierarchyIndex.Previous">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HierarchyIndex.Child">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HierarchyIndex.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.HierarchyIndex.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.HierarchyIndex.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="next"></param>
            <param name="previous"></param>
            <param name="child"></param>
            <param name="parent"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.HierarchyIndex.FromVec4i(ST4IVisionCoreNet.Vec4i)">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HierarchyIndex.ToVec4i">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Line2D">
            <summary>
            2-dimentional line vector
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line2D.Vx">
            <summary>
            The X component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line2D.Vy">
            <summary>
            The Y component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line2D.X1">
            <summary>
            X-coordinate of some point on the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line2D.Y1">
            <summary>
            Y-coordinate of some point on the line
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes this object
            </summary>
            <param name="vx">The X component of the normalized vector collinear to the line</param>
            <param name="vy">The Y component of the normalized vector collinear to the line</param>
            <param name="x1">Z-coordinate of some point on the line</param>
            <param name="y1">Z-coordinate of some point on the line</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.#ctor(System.Single[])">
            <summary>
            Initializes by cvFitLine output 
            </summary>
            <param name="line">The returned value from cvFitLine</param>param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.GetVectorRadian">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.GetVectorAngle">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.Distance(ST4IVisionCoreNet.Point)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.Distance(ST4IVisionCoreNet.Point2f)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.Distance(ST4IVisionCoreNet.Point2d)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.Distance(System.Double,System.Double)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line2D.FitSize(System.Int32,System.Int32,ST4IVisionCoreNet.Point@,ST4IVisionCoreNet.Point@)">
            <summary>
            Fits this line to the specified size (for drawing)
            </summary>
            <param name="width">Width of fit size</param>
            <param name="height">Height of fit size</param>
            <param name="pt1">1st edge point of fitted line</param>
            <param name="pt2">2nd edge point of fitted line</param>
        </member>
        <member name="T:ST4IVisionCoreNet.Line3D">
            <summary>
            A 3-dimensional line object
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line3D.Vx">
            <summary>
            The X component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line3D.Vy">
            <summary>
            The Y component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line3D.Vz">
            <summary>
            The Z component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line3D.X1">
            <summary>
            X-coordinate of some point on the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line3D.Y1">
            <summary>
            Y-coordinate of some point on the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Line3D.Z1">
            <summary>
            Z-coordinate of some point on the line
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes this object
            </summary>
            <param name="vx">The X component of the normalized vector collinear to the line</param>
            <param name="vy">The Y component of the normalized vector collinear to the line</param>
            <param name="vz">The Z component of the normalized vector collinear to the line</param>
            <param name="x1">Z-coordinate of some point on the line</param>
            <param name="y1">Z-coordinate of some point on the line</param>
            <param name="z1">Z-coordinate of some point on the line</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.#ctor(System.Single[])">
            <summary>
            Initializes by cvFitLine output 
            </summary>
            <param name="line">The returned value from cvFitLine</param>param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.PerpendicularFoot(ST4IVisionCoreNet.Point3f)">
            <summary>
            Perpendicular foot
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.PerpendicularFoot(ST4IVisionCoreNet.Point3d)">
            <summary>
            Perpendicular foot
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.PerpendicularFoot(System.Double,System.Double,System.Double)">
            <summary>
            Perpendicular foot
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.Distance(ST4IVisionCoreNet.Point3f)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.Distance(ST4IVisionCoreNet.Point3d)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.Distance(System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.CrossProduct(ST4IVisionCoreNet.Point3d,ST4IVisionCoreNet.Point3d)">
            <summary>
            ベクトルの外積
            </summary>
            <param name="vl"></param>
            <param name="vr"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.VectorLength(ST4IVisionCoreNet.Point3d)">
            <summary>
            ベクトルの長さ(原点からの距離)
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Line3D.VertexDistance(ST4IVisionCoreNet.Point3d,ST4IVisionCoreNet.Point3d)">
            <summary>
            2点間(2ベクトル)の距離
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.LineSegmentPoint">
            <summary>
            Line segment structure retrieved from cvHoughLines2
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineSegmentPoint.P1">
            <summary>
            1st Point
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineSegmentPoint.P2">
            <summary>
            2nd Point
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.#ctor(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.Point)">
            <summary>
            Constructor
            </summary>
            <param name="p1">1st Point</param>
            <param name="p2">2nd Point</param>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.Equals(ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="other">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.op_Equality(ST4IVisionCoreNet.LineSegmentPoint,ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.op_Inequality(ST4IVisionCoreNet.LineSegmentPoint,ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.LineIntersection(ST4IVisionCoreNet.LineSegmentPoint,ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Calculates a intersection of the specified two lines
            </summary>
            <param name="line1"></param>
            <param name="line2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.LineIntersection(ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Calculates a intersection of the specified two lines
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.SegmentIntersection(ST4IVisionCoreNet.LineSegmentPoint,ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Calculates a intersection of the specified two segments
            </summary>
            <param name="seg1"></param>
            <param name="seg2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.SegmentIntersection(ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Calculates a intersection of the specified two segments
            </summary>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.IntersectedSegments(ST4IVisionCoreNet.LineSegmentPoint,ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Returns a boolean value indicating whether the specified two segments intersect.
            </summary>
            <param name="seg1"></param>
            <param name="seg2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.IntersectedSegments(ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Returns a boolean value indicating whether the specified two segments intersect.
            </summary>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.IntersectedLineAndSegment(ST4IVisionCoreNet.LineSegmentPoint,ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Returns a boolean value indicating whether a line and a segment intersect.
            </summary>
            <param name="line">Line</param>
            <param name="seg">Segment</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.LineAndSegmentIntersection(ST4IVisionCoreNet.LineSegmentPoint,ST4IVisionCoreNet.LineSegmentPoint)">
            <summary>
            Calculates a intersection of a line and a segment
            </summary>
            <param name="line"></param>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.Length">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.Offset(System.Int32,System.Int32)">
            <summary>
            Translates the Point by the specified amount. 
            </summary>
            <param name="x">The amount to offset the x-coordinate. </param>
            <param name="y">The amount to offset the y-coordinate. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPoint.Offset(ST4IVisionCoreNet.Point)">
            <summary>
            Translates the Point by the specified amount. 
            </summary>
            <param name="p">The Point used offset this CvPoint.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.LineSegmentPolar">
            <summary>
            Polar line segment retrieved from cvHoughLines2
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineSegmentPolar.Rho">
            <summary>
            Length of the line
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineSegmentPolar.Theta">
            <summary>
            Angle of the line (radian)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.#ctor(System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="rho">Length of the line</param>
            <param name="theta">Angle of the line (radian)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.Equals(ST4IVisionCoreNet.LineSegmentPolar)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="other">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.op_Equality(ST4IVisionCoreNet.LineSegmentPolar,ST4IVisionCoreNet.LineSegmentPolar)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.op_Inequality(ST4IVisionCoreNet.LineSegmentPolar,ST4IVisionCoreNet.LineSegmentPolar)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.LineIntersection(ST4IVisionCoreNet.LineSegmentPolar,ST4IVisionCoreNet.LineSegmentPolar)">
            <summary>
            Calculates a intersection of the specified two lines
            </summary>
            <param name="line1"></param>
            <param name="line2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.LineIntersection(ST4IVisionCoreNet.LineSegmentPolar)">
            <summary>
            Calculates a intersection of the specified two lines
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.ToSegmentPoint(System.Double)">
            <summary>
            Convert To LineSegmentPoint
            </summary>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.ToSegmentPointX(System.Int32,System.Int32)">
            <summary>
            Converts to a line segment with the specified x coordinates at both ends
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.ToSegmentPointY(System.Int32,System.Int32)">
            <summary>
            Converts to a line segment with the specified y coordinates at both ends
            </summary>
            <param name="y1"></param>
            <param name="y2"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.XPosOfLine(System.Int32)">
            <summary>
            
            </summary>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.LineSegmentPolar.YPosOfLine(System.Int32)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Moments">
            <summary>
            Raster image moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M00">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M10">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M01">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M20">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M11">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M02">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M30">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M21">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M12">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.M03">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Mu20">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Mu11">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Mu02">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Mu30">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Mu21">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Mu12">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Mu03">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Nu20">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Nu11">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Nu02">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Nu30">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Nu21">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Nu12">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Moments.Nu03">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.#ctor">
            <summary>
            Default constructor.
            All moment values are set to 0.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="m00"></param>
            <param name="m10"></param>
            <param name="m01"></param>
            <param name="m20"></param>
            <param name="m11"></param>
            <param name="m02"></param>
            <param name="m30"></param>
            <param name="m21"></param>
            <param name="m12"></param>
            <param name="m03"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.#ctor(ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (single-channel, 8-bit or floating-point 
            2D array) or an array ( 1xN or Nx1 ) of 2D points ( Point or Point2f )</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.#ctor(System.Byte[0:,0:],System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (8-bit) 2D array</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (floating-point) 2D array</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point},System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">Array of 2D points</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.#ctor(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">Array of 2D points</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.InitializeFromInputArray(ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (single-channel, 8-bit or floating-point 
            2D array) or an array ( 1xN or Nx1 ) of 2D points ( Point or Point2f )</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.Initialize(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="m00"></param>
            <param name="m10"></param>
            <param name="m01"></param>
            <param name="m20"></param>
            <param name="m11"></param>
            <param name="m02"></param>
            <param name="m30"></param>
            <param name="m21"></param>
            <param name="m12"></param>
            <param name="m03"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Moments.HuMoments">
            <summary>
            computes 7 Hu invariants from the moments
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Subdiv2D">
            <summary>
            Planar Subdivision
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.#ctor">
            <summary>
            Creates an empty Subdiv2D object.
            To create a new empty Delaunay subdivision you need to use the #initDelaunay function.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.#ctor(ST4IVisionCoreNet.Rect)">
            <summary>
            Creates an empty Subdiv2D object.
            </summary>
            <param name="rect">Rectangle that includes all of the 2D points that are to be added to the subdivision.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.Release">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.InitDelaunay(ST4IVisionCoreNet.Rect)">
            <summary>
            Creates a new empty Delaunay subdivision
            </summary>
            <param name="rect">Rectangle that includes all of the 2D points that are to be added to the subdivision.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.Insert(ST4IVisionCoreNet.Point2f)">
            <summary>
            Insert a single point into a Delaunay triangulation.
            </summary>
            <param name="pt">Point to insert.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.Insert(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f})">
            <summary>
            Insert multiple points into a Delaunay triangulation.
            </summary>
            <param name="ptVec">Points to insert.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.Locate(ST4IVisionCoreNet.Point2f,System.Int32@,System.Int32@)">
            <summary>
            Returns the location of a point within a Delaunay triangulation.
            </summary>
            <param name="pt">Point to locate.</param>
            <param name="edge">Output edge that the point belongs to or is located to the right of it.</param>
            <param name="vertex">Optional output vertex the input point coincides with.</param>
            <returns>an integer which specify one of the following five cases for point location:
            -  The point falls into some facet. The function returns #PTLOC_INSIDE and edge will contain one of edges of the facet.
            -  The point falls onto the edge. The function returns #PTLOC_ON_EDGE and edge will contain this edge.
            -  The point coincides with one of the subdivision vertices. The function returns #PTLOC_VERTEX and vertex will contain a pointer to the vertex.
            -  The point is outside the subdivision reference rectangle. The function returns #PTLOC_OUTSIDE_RECT and no pointers are filled.
            -  One of input arguments is invalid. A runtime error is raised or, if silent or "parent" error processing mode is selected, #PTLOC_ERROR is returned.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.FindNearest(ST4IVisionCoreNet.Point2f,ST4IVisionCoreNet.Point2f@)">
            <summary>
            Finds the subdivision vertex closest to the given point.
            </summary>
            <param name="pt">Input point.</param>
            <param name="nearestPt">Output subdivision vertex point.</param>
            <returns>vertex ID.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.GetEdgeList">
            <summary>
            Returns a list of all edges.
            </summary>
            <returns>Output vector.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.GetLeadingEdgeList">
            <summary>
            Returns a list of the leading edge ID connected to each triangle.
            The function gives one edge ID for each triangle.
            </summary>
            <returns>Output vector.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.GetTriangleList">
            <summary>
            Returns a list of all triangles.
            </summary>
            <returns>Output vector.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.GetVoronoiFacetList(System.Collections.Generic.IEnumerable{System.Int32},ST4IVisionCoreNet.Point2f[][]@,ST4IVisionCoreNet.Point2f[]@)">
            <summary>
            Returns a list of all Voronoi facets.
            </summary>
            <param name="idx">Vector of vertices IDs to consider. For all vertices you can pass empty vector.</param>
            <param name="facetList">Output vector of the Voronoi facets.</param>
            <param name="facetCenters">Output vector of the Voronoi facets center points.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.GetVertex(System.Int32,System.Int32@)">
            <summary>
            Returns vertex location from vertex ID.
            </summary>
            <param name="vertex">vertex ID.</param>
            <param name="firstEdge">The first edge ID which is connected to the vertex.</param>
            <returns>vertex (x,y)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.GetEdge(System.Int32,ST4IVisionCoreNet.NextEdgeType)">
            <summary>
            Returns one of the edges related to the given edge.
            </summary>
            <param name="edge">Subdivision edge ID.</param>
            <param name="nextEdgeType">Parameter specifying which of the related edges to return.
            The following values are possible:
            -   NEXT_AROUND_ORG next around the edge origin ( eOnext on the picture below if e is the input edge)
            -   NEXT_AROUND_DST next around the edge vertex ( eDnext )
            -   PREV_AROUND_ORG previous around the edge origin (reversed eRnext )
            -   PREV_AROUND_DST previous around the edge destination (reversed eLnext )
            -   NEXT_AROUND_LEFT next around the left facet ( eLnext )
            -   NEXT_AROUND_RIGHT next around the right facet ( eRnext )
            -   PREV_AROUND_LEFT previous around the left facet (reversed eOnext )
            -   PREV_AROUND_RIGHT previous around the right facet (reversed eDnext )</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.NextEdge(System.Int32)">
            <summary>
            Subdivision edge ID.
            </summary>
            <param name="edge">Subdivision edge ID.</param>
            <returns>an integer which is next edge ID around the edge origin: eOnext on the picture above if e is the input edge).</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.RotateEdge(System.Int32,System.Int32)">
            <summary>
            Returns another edge of the same quad-edge.
            </summary>
            <param name="edge">Subdivision edge ID.</param>
            <param name="rotate">Parameter specifying which of the edges of the same quad-edge as the input
            one to return. The following values are possible:
            -   0 - the input edge ( e on the picture below if e is the input edge)
            -   1 - the rotated edge ( eRot )
            -   2 - the reversed edge (reversed e (in green))
            -   3 - the reversed rotated edge (reversed eRot (in green))</param>
            <returns>one of the edges ID of the same quad-edge as the input edge.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.SymEdge(System.Int32)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.EdgeOrg(System.Int32,ST4IVisionCoreNet.Point2f@)">
            <summary>
            Returns the edge origin.
            </summary>
            <param name="edge">Subdivision edge ID.</param>
            <param name="orgPt">Output vertex location.</param>
            <returns>vertex ID.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Subdiv2D.EdgeDst(System.Int32,ST4IVisionCoreNet.Point2f@)">
            <summary>
            Returns the edge destination.
            </summary>
            <param name="edge">Subdivision edge ID.</param>
            <param name="dstPt">Output vertex location.</param>
            <returns>vertex ID.</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.NextEdgeType">
            <summary>
            Parameter for Subdiv2D.GetEdge() specifying which of the related edges to return.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NextEdgeType.NEXT_AROUND_ORG">
            <summary>
            next around the edge origin ( eOnext on the picture below if e is the input edge)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NextEdgeType.NEXT_AROUND_DST">
            <summary>
            next around the edge vertex ( eDnext )
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NextEdgeType.PREV_AROUND_ORG">
            <summary>
            previous around the edge origin (reversed eRnext )
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NextEdgeType.PREV_AROUND_DST">
            <summary>
            previous around the edge destination (reversed eLnext )
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NextEdgeType.NEXT_AROUND_LEFT">
            <summary>
            next around the left facet ( eLnext )
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NextEdgeType.NEXT_AROUND_RIGHT">
            <summary>
            next around the right facet ( eRnext )
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NextEdgeType.PREV_AROUND_LEFT">
            <summary>
            previous around the left facet (reversed eOnext )
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.NextEdgeType.PREV_AROUND_RIGHT">
            <summary>
            previous around the right facet (reversed eDnext )
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImgHash.AverageHash">
            <inheritdoc />
            <summary>
            Computes average hash value of the input image.
            This is a fast image hashing algorithm, but only work on simple case. For more details, 
            please refer to @cite lookslikeit
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImgHash.AverageHash.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.AverageHash.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.AverageHash.Create">
            <summary>
            Constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.AverageHash.DisposeManaged">
            <inheritdoc />
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImgHash.BlockMeanHash">
            <inheritdoc />
            <summary>
            Image hash based on block mean.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImgHash.BlockMeanHash.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.BlockMeanHash.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.BlockMeanHash.Create(ST4IVisionCoreNet.ImgHash.BlockMeanHashMode)">
            <summary>
            Create BlockMeanHash object
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.BlockMeanHash.DisposeManaged">
            <inheritdoc />
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.BlockMeanHash.SetMode(ST4IVisionCoreNet.ImgHash.BlockMeanHashMode)">
            <summary>
            
            </summary>
            <param name="mode"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.BlockMeanHash.GetMean">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ImgHash.ColorMomentHash">
            <inheritdoc />
            <summary>
            Image hash based on color moments.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImgHash.ColorMomentHash.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.ColorMomentHash.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.ColorMomentHash.Create">
            <summary>
            Constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.ColorMomentHash.DisposeManaged">
            <inheritdoc />
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.ColorMomentHash.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <inheritdoc />
            <summary>
            Computes color moment hash of the input, the algorithm is come from the paper "Perceptual Hashing for Color Images Using Invariant Moments"
            </summary>
            <param name="inputArr">input image want to compute hash value, type should be CV_8UC4, CV_8UC3 or CV_8UC1.</param>
            <param name="outputArr">42 hash values with type CV_64F(double)</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ImgHash.BlockMeanHashMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImgHash.BlockMeanHashMode.Mode0">
            <summary>
            use fewer block and generate 16*16/8 uchar hash value
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImgHash.BlockMeanHashMode.Mode1">
            <summary>
            use block blocks(step sizes/2), generate 31*31/8 + 1 uchar hash value
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ImgHash.ImgHashBase">
            <inheritdoc />
            <summary>
            The base class for image hash algorithms
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.ImgHashBase.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Computes hash of the input image
            </summary>
            <param name="inputArr">input image want to compute hash value</param>
            <param name="outputArr">hash of the image</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.ImgHashBase.Compare(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Compare the hash value between inOne and inTwo
            </summary>
            <param name="hashOne">Hash value one</param>
            <param name="hashTwo">Hash value two</param>
            <returns>value indicate similarity between inOne and inTwo, the meaning of the value vary from algorithms to algorithms</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ImgHash.MarrHildrethHash">
            <inheritdoc />
            <summary>
            Marr-Hildreth Operator Based Hash, slowest but more discriminative.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImgHash.MarrHildrethHash.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.MarrHildrethHash.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.MarrHildrethHash.Create(System.Single,System.Single)">
            <summary>
            Create BlockMeanHash object
            </summary>
            <param name="alpha">int scale factor for marr wavelet (default=2).</param>
            <param name="scale">int level of scale factor (default = 1)</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.MarrHildrethHash.DisposeManaged">
            <inheritdoc />
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.MarrHildrethHash.SetKernelParam(System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="alpha">int scale factor for marr wavelet (default=2).</param>
            <param name="scale">int level of scale factor (default = 1)</param>
        </member>
        <member name="P:ST4IVisionCoreNet.ImgHash.MarrHildrethHash.Alpha">
            <summary>
            int scale factor for marr wavelet (default=2).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ImgHash.MarrHildrethHash.Scale">
            <summary>
            int level of scale factor (default = 1)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.MarrHildrethHash.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <inheritdoc />
            <summary>
            Computes average hash value of the input image
            </summary>
            <param name="inputArr">input image want to compute hash value, type should be CV_8UC4, CV_8UC3, CV_8UC1.</param>
            <param name="outputArr">Hash value of input, it will contain 16 hex decimal number, return type is CV_8U</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ImgHash.PHash">
            <inheritdoc />
            <summary>
            pHash: Slower than average_hash, but tolerant of minor modifications.
            This algorithm can combat more variation than averageHash, for more details please refer to @cite lookslikeit
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImgHash.PHash.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.PHash.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.PHash.Create">
            <summary>
            Constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.PHash.DisposeManaged">
            <inheritdoc />
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.PHash.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <inheritdoc />
            <summary>
            Computes pHash value of the input image
            </summary>
            <param name="inputArr">input image want to compute hash value, type should be CV_8UC4, CV_8UC3, CV_8UC1.</param>
            <param name="outputArr">Hash value of input, it will contain 8 uchar value</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ImgHash.RadialVarianceHash">
            <inheritdoc />
            <summary>
            Image hash based on Radon transform.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ImgHash.RadialVarianceHash.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.RadialVarianceHash.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.RadialVarianceHash.Create(System.Double,System.Int32)">
            <summary>
            Create BlockMeanHash object
            </summary>
            <param name="sigma">Gaussian kernel standard deviation</param>
            <param name="numOfAngleLine">The number of angles to consider</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.RadialVarianceHash.DisposeManaged">
            <inheritdoc />
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ImgHash.RadialVarianceHash.Sigma">
            <summary>
            Gaussian kernel standard deviation
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ImgHash.RadialVarianceHash.NumOfAngleLine">
            <summary>
            The number of angles to consider
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ImgHash.RadialVarianceHash.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <inheritdoc />
            <summary>
            Computes average hash value of the input image
            </summary>
            <param name="inputArr">input image want to compute hash value, type should be CV_8UC4, CV_8UC3, CV_8UC1.</param>
            <param name="outputArr">Hash value of input</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.LineDescriptor.KeyLine">
             <summary>
             A class to represent a line
            
             As aformentioned, it is been necessary to design a class that fully stores the information needed to 
             characterize completely a line and plot it on image it was extracted from, when required.
            
             *KeyLine* class has been created for such goal; it is mainly inspired to Feature2d's KeyPoint class,
             since KeyLine shares some of* KeyPoint*'s fields, even if a part of them assumes a different
             meaning, when speaking about lines.In particular:
            
             -   the* class_id* field is used to gather lines extracted from different octaves which refer to
             same line inside original image (such lines and the one they represent in original image share
             the same* class_id* value)
             -   the* angle* field represents line's slope with respect to (positive) X axis
             -   the* pt* field represents line's midpoint
             -   the* response* field is computed as the ratio between the line's length and maximum between
             image's width and height
             -   the* size* field is the area of the smallest rectangle containing line
            
             Apart from fields inspired to KeyPoint class, KeyLines stores information about extremes of line in
             original image and in octave it was extracted from, about line's length and number of pixels it
             covers.
             </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.Angle">
            <summary>
            orientation of the line
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.ClassId">
            <summary>
            object ID, that can be used to cluster keylines by the line they represent
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.Octave">
            <summary>
            octave (pyramid layer), from which the keyline has been extracted
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.Pt">
            <summary>
            coordinates of the middlepoint
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.Response">
            <summary>
            the response, by which the strongest keylines have been selected.
            It's represented by the ratio between line's length and maximum between
            image's width and height
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.Size">
            <summary>
            minimum area containing line
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.StartPointX">
            <summary>
            lines' extremes in original image
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.StartPointY">
            <summary>
            lines' extremes in original image
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.EndPointX">
            <summary>
            lines' extremes in original image
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.EndPointY">
            <summary>
            lines' extremes in original image
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.SPointInOctaveX">
            <summary>
            line's extremes in image it was extracted from
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.SPointInOctaveY">
            <summary>
            line's extremes in image it was extracted from
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.EPointInOctaveX">
            <summary>
            line's extremes in image it was extracted from
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.EPointInOctaveY">
            <summary>
            line's extremes in image it was extracted from
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.LineLength">
            <summary>
            the length of line
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.LineDescriptor.KeyLine.NumOfPixels">
            <summary>
            number of pixels covered by the line
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineDescriptor.KeyLine.StartPoint">
            <summary>
            Returns the start point of the line in the original image
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineDescriptor.KeyLine.EndPoint">
            <summary>
            Returns the end point of the line in the original image
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineDescriptor.KeyLine.StartPointInOctave">
            <summary>
            Returns the start point of the line in the octave it was extracted from
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.LineDescriptor.KeyLine.EndPointInOctave">
            <summary>
            Returns the end point of the line in the octave it was extracted from
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.LineDescriptor.KeyLine.#ctor(System.Single,System.Int32,System.Int32,ST4IVisionCoreNet.Point2f,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="angle"></param>
            <param name="classId"></param>
            <param name="octave"></param>
            <param name="pt"></param>
            <param name="response"></param>
            <param name="size"></param>
            <param name="startPointX"></param>
            <param name="startPointY"></param>
            <param name="endPointX"></param>
            <param name="endPointY"></param>
            <param name="sPointInOctaveX"></param>
            <param name="sPointInOctaveY"></param>
            <param name="ePointInOctaveX"></param>
            <param name="ePointInOctaveY"></param>
            <param name="lineLength"></param>
            <param name="numOfPixels"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.ANN_MLP">
            <summary>
            Artificial Neural Networks - Multi-Layer Perceptrons.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::ANN_MLP*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.Load(System.String)">
            <summary>
            Loads and creates a serialized ANN from a file.
            Use ANN::save to serialize and store an ANN to disk.
            Load the ANN from this file again, by calling this function with the path to the file.
            </summary>
            <param name="filePath">path to serialized ANN</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">he string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.ANN_MLP.TermCriteria">
            <summary>
            Termination criteria of the training algorithm.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.ANN_MLP.BackpropWeightScale">
            <summary>
            Strength of the weight gradient term.
            The recommended value is about 0.1. Default value is 0.1.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.ANN_MLP.BackpropMomentumScale">
            <summary>
            Strength of the momentum term (the difference between weights on the 2 previous iterations).
            This parameter provides some inertia to smooth the random fluctuations of the weights. 
            It can vary from 0 (the feature is disabled) to 1 and beyond. The value 0.1 or 
            so is good enough. Default value is 0.1.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.ANN_MLP.RpropDW0">
            <summary>
            Initial value Delta_0 of update-values Delta_{ij}. Default value is 0.1.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.ANN_MLP.RpropDWPlus">
            <summary>
            Increase factor eta^+.
            It must be &gt;1. Default value is 1.2.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.ANN_MLP.RpropDWMinus">
            <summary>
            Decrease factor eta^-.
            It must be \&gt;1. Default value is 0.5.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.ANN_MLP.RpropDWMin">
            <summary>
            Update-values lower limit Delta_{min}.
            It must be positive. Default value is FLT_EPSILON.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.ANN_MLP.RpropDWMax">
            <summary>
            Update-values upper limit Delta_{max}.
            It must be &gt;1. Default value is 50.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.SetTrainMethod(ST4IVisionCoreNet.ML.ANN_MLP.TrainingMethods,System.Double,System.Double)">
            <summary>
            Sets training method and common parameters.
            </summary>
            <param name="method">Default value is ANN_MLP::RPROP. See ANN_MLP::TrainingMethods.</param>
            <param name="param1">passed to setRpropDW0 for ANN_MLP::RPROP and to setBackpropWeightScale for ANN_MLP::BACKPROP and to initialT for ANN_MLP::ANNEAL.</param>
            <param name="param2">passed to setRpropDWMin for ANN_MLP::RPROP and to setBackpropMomentumScale for ANN_MLP::BACKPROP and to finalT for ANN_MLP::ANNEAL.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.GetTrainMethod">
            <summary>
            Returns current training method
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.SetActivationFunction(ST4IVisionCoreNet.ML.ANN_MLP.ActivationFunctions,System.Double,System.Double)">
            <summary>
            Initialize the activation function for each neuron.
            Currently the default and the only fully supported activation function is ANN_MLP::SIGMOID_SYM.
            </summary>
            <param name="type">The type of activation function. See ANN_MLP::ActivationFunctions.</param>
            <param name="param1">The first parameter of the activation function, \f$\alpha\f$. Default value is 0.</param>
            <param name="param2">The second parameter of the activation function, \f$\beta\f$. Default value is 0.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.SetLayerSizes(ST4IVisionCoreNet.InputArray)">
            <summary>
            Integer vector specifying the number of neurons in each layer including the input and output layers.
            The very first element specifies the number of elements in the input layer.
            The last element - number of elements in the output layer.Default value is empty Mat.
            </summary>
            <param name="layerSizes"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ANN_MLP.GetLayerSizes">
            <summary>
            Integer vector specifying the number of neurons in each layer including the input and output layers.
            The very first element specifies the number of elements in the input layer.
            The last element - number of elements in the output layer.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.ANN_MLP.ActivationFunctions">
            <summary>
            possible activation functions
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ANN_MLP.ActivationFunctions.Identity">
            <summary>
            Identity function: $f(x)=x
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ANN_MLP.ActivationFunctions.SigmoidSym">
            <summary>
            Symmetrical sigmoid: f(x)=\beta*(1-e^{-\alpha x})/(1+e^{-\alpha x}
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ANN_MLP.ActivationFunctions.Gaussian">
            <summary>
            Gaussian function: f(x)=\beta e^{-\alpha x*x}
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.ANN_MLP.TrainFlags">
            <summary>
            Train options
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ANN_MLP.TrainFlags.UpdateWeights">
            <summary>
            Update the network weights, rather than compute them from scratch. 
            In the latter case the weights are initialized using the Nguyen-Widrow algorithm.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ANN_MLP.TrainFlags.NoInputScale">
            <summary>
            Do not normalize the input vectors. 
            If this flag is not set, the training algorithm normalizes each input feature 
            independently, shifting its mean value to 0 and making the standard deviation 
            equal to 1. If the network is assumed to be updated frequently, the new 
            training data could be much different from original one. In this case, 
            you should take care of proper normalization.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ANN_MLP.TrainFlags.NoOutputScale">
            <summary>
            Do not normalize the output vectors. If the flag is not set, 
            the training algorithm normalizes each output feature independently, 
            by transforming it to the certain range depending on the used activation function.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.ANN_MLP.TrainingMethods">
            <summary>
            Available training methods
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ANN_MLP.TrainingMethods.BackProp">
            <summary>
            The back-propagation algorithm.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ANN_MLP.TrainingMethods.RProp">
            <summary>
            The RPROP algorithm. See @cite RPROP93 for details.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.Boost">
            <summary>
            Boosted tree classifier derived from DTrees
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.Boost.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::Boost*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.Boost.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.Boost.Load(System.String)">
            <summary>
            Loads and creates a serialized model from a file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.Boost.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">he string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.Boost.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.Boost.BoostType">
            <summary>
            Type of the boosting algorithm.
            See Boost::Types. Default value is Boost::REAL.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.Boost.WeakCount">
            <summary>
            The number of weak classifiers. 
            Default value is 100.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.Boost.WeightTrimRate">
            <summary>
            A threshold between 0 and 1 used to save computational time. 
            Samples with summary weight \f$\leq 1 - weight_trim_rate
            do not participate in the *next* iteration of training. 
            Set this parameter to 0 to turn off this functionality. Default value is 0.95.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.Boost.Types">
            <summary>
            Boosting type.
            Gentle AdaBoost and Real AdaBoost are often the preferable choices.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.Boost.Types.Discrete">
            <summary>
            Discrete AdaBoost.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.Boost.Types.Real">
            <summary>
            Real AdaBoost. It is a technique that utilizes confidence-rated predictions
            and works well with categorical data.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.Boost.Types.Logit">
            <summary>
            LogitBoost. It can produce good regression fits.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.Boost.Types.Gentle">
            <summary>
            Gentle AdaBoost. It puts less weight on outlier data points and for that
            reason is often good with regression data.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.DTrees">
            <summary>
            Decision tree
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::SVM*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.Load(System.String)">
            <summary>
            Loads and creates a serialized model from a file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">he string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.MaxCategories">
            <summary>
            Cluster possible values of a categorical variable into 
            K &lt; =maxCategories clusters to find a suboptimal split.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.MaxDepth">
            <summary>
            The maximum possible depth of the tree.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.MinSampleCount">
            <summary>
            If the number of samples in a node is less than this parameter then the 
            node will not be split. Default value is 10.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.CVFolds">
            <summary>
            If CVFolds \> 1 then algorithms prunes the built decision tree using K-fold 
            cross-validation procedure where K is equal to CVFolds. Default value is 10.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.UseSurrogates">
            <summary>
            If true then surrogate splits will be built.
            These splits allow to work with missing data and compute variable 
            importance correctly. Default value is false.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.Use1SERule">
            <summary>
            If true then a pruning will be harsher.
            This will make a tree more compact and more resistant to the training 
            data noise but a bit less accurate. Default value is true.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.TruncatePrunedTree">
            <summary>
            If true then pruned branches are physically removed from the tree.
            Otherwise they are retained and it is possible to get results from the 
            original unpruned (or pruned less aggressively) tree. Default value is true.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.RegressionAccuracy">
            <summary>
            Termination criteria for regression trees.
            If all absolute differences between an estimated value in a node and 
            values of train samples in this node are less than this parameter 
            then the node will not be split further. Default value is 0.01f.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.DTrees.Priors">
            <summary>
            The array of a priori class probabilities, sorted by the class label value.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.GetRoots">
            <summary>
            Returns indices of root nodes
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.GetNodes">
            <summary>
            Returns all the nodes. 
            all the node indices are indices in the returned vector
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.GetSplits">
            <summary>
            Returns all the splits.
            all the split indices are indices in the returned vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.DTrees.GetSubsets">
            <summary>
            Returns all the bitsets for categorical splits.
            Split::subsetOfs is an offset in the returned vector
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.DTrees.Node">
            <summary>
            The class represents a decision tree node.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Node.Value">
            <summary>
            Value at the node: a class label in case of classification or estimated 
            function value in case of regression.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Node.ClassIdx">
            <summary>
            Class index normalized to 0..class_count-1 range and assigned to the 
            node. It is used internally in classification trees and tree ensembles.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Node.Parent">
            <summary>
            Index of the parent node
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Node.Left">
            <summary>
            Index of the left child node
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Node.Right">
            <summary>
            Index of right child node
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Node.DefaultDir">
            <summary>
            Default direction where to go (-1: left or +1: right). It helps in the
            case of missing values.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Node.Split">
            <summary>
            Index of the first split
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.DTrees.Split">
            <summary>
            The class represents split in a decision tree.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Split.VarIdx">
            <summary>
            Index of variable on which the split is created.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Split.Inversed">
            <summary>
            If not 0, then the inverse split rule is used (i.e. left and right
            branches are exchanged in the rule expressions below).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Split.Quality">
            <summary>
            The split quality, a positive number. It is used to choose the best split.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Split.Next">
            <summary>
            Index of the next split in the list of splits for the node
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Split.C">
            <summary>
            The threshold value in case of split on an ordered variable.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.DTrees.Split.SubsetOfs">
            <summary>
            Offset of the bitset used by the split on a categorical variable.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.SampleTypes">
            <summary>
            Sample types
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SampleTypes.RowSample">
            <summary>
            each training sample is a row of samples
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SampleTypes.ColSample">
            <summary>
            each training sample occupies a column of samples
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.KNearest">
            <summary>
            K nearest neighbors classifier
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.KNearest.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::KNearest*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.KNearest.Create">
            <summary>
            Creates the empty model
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.KNearest.Load(System.String)">
            <summary>
            Loads and creates a serialized model from a file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.KNearest.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">he string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.KNearest.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.KNearest.DefaultK">
            <summary>
            Default number of neighbors to use in predict method.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.KNearest.IsClassifier">
            <summary>
            Whether classification or regression model should be trained.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.KNearest.Emax">
            <summary>
            Parameter for KDTree implementation
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.KNearest.AlgorithmType">
            <summary>
            Algorithm type, one of KNearest::Types.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.KNearest.FindNearest(ST4IVisionCoreNet.InputArray,System.Int32,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Finds the neighbors and predicts responses for input vectors.
            </summary>
            <param name="samples">Input samples stored by rows. 
            It is a single-precision floating-point matrix of `[number_of_samples] * k` size.</param>
            <param name="k">Number of used nearest neighbors. Should be greater than 1.</param>
            <param name="results">Vector with results of prediction (regression or classification) for each 
            input sample. It is a single-precision floating-point vector with `[number_of_samples]` elements.</param>
            <param name="neighborResponses">neighborResponses Optional output values for corresponding neighbors. 
            It is a single-precision floating-point matrix of `[number_of_samples] * k` size.</param>
            <param name="dist">Optional output distances from the input vectors to the corresponding neighbors. 
            It is a single-precision floating-point matrix of `[number_of_samples] * k` size.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.KNearest.Types">
            <summary>
            Implementations of KNearest algorithm
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.LogisticRegression">
            <summary>
            Implements Logistic Regression classifier.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.LogisticRegression.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::LogisticRegression*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.LogisticRegression.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.LogisticRegression.Load(System.String)">
            <summary>
            Loads and creates a serialized model from a file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.LogisticRegression.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">he string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.LogisticRegression.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.LogisticRegression.LearningRate">
            <summary>
            Learning rate
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.LogisticRegression.Iterations">
            <summary>
            Number of iterations.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.LogisticRegression.Regularization">
            <summary>
            Kind of regularization to be applied. See LogisticRegression::RegKinds.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.LogisticRegression.TrainMethod">
            <summary>
            Kind of training method used. See LogisticRegression::Methods.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.LogisticRegression.MiniBatchSize">
            <summary>
            Specifies the number of training samples taken in each step of Mini-Batch Gradient. 
            Descent. Will only be used if using LogisticRegression::MINI_BATCH training algorithm. 
            It has to take values less than the total number of training samples.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.LogisticRegression.TermCriteria">
            <summary>
            Termination criteria of the training algorithm.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.LogisticRegression.Predict(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Predicts responses for input samples and returns a float type.
            </summary>
            <param name="samples">The input data for the prediction algorithm. Matrix [m x n], 
            where each row contains variables (features) of one object being classified. 
            Should have data type CV_32F.</param>
            <param name="results">Predicted labels as a column matrix of type CV_32S.</param>
            <param name="flags">Not used.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.LogisticRegression.GetLearntThetas">
            <summary>
            This function returns the trained parameters arranged across rows.
             For a two class classification problem, it returns a row matrix. 
            It returns learnt parameters of the Logistic Regression as a matrix of type CV_32F.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.LogisticRegression.RegKinds">
            <summary>
            Regularization kinds
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.LogisticRegression.RegKinds.RegDisable">
            <summary>
            Regularization disabled
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.LogisticRegression.RegKinds.RegL1">
            <summary>
            L1 norm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.LogisticRegression.RegKinds.RegL2">
            <summary>
            L2 norm
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.LogisticRegression.Methods">
            <summary>
            Training methods
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.LogisticRegression.Methods.Batch">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.LogisticRegression.Methods.MiniBatch">
            <summary>
            Set MiniBatchSize to a positive integer when using this method.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.NormalBayesClassifier">
            <summary>
            Bayes classifier for normally distributed data
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.NormalBayesClassifier.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::NormalBayesClassifier*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.NormalBayesClassifier.Create">
            <summary>
            Creates empty model. 
            Use StatModel::train to train the model after creation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.NormalBayesClassifier.Load(System.String)">
            <summary>
            Loads and creates a serialized model from a file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.NormalBayesClassifier.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">he string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.NormalBayesClassifier.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.NormalBayesClassifier.PredictProb(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Predicts the response for sample(s).
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <param name="outputProbs"></param>
            <param name="flags"></param>
            <returns></returns>
            <remarks>
            The method estimates the most probable classes for input vectors. Input vectors (one or more)
            are stored as rows of the matrix inputs. In case of multiple input vectors, there should be one 
            output vector outputs. The predicted class for a single input vector is returned by the method. 
            The vector outputProbs contains the output probabilities corresponding to each element of result.
            </remarks>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.ParamGrid">
            <summary>
            The structure represents the logarithmic grid range of statmodel parameters.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ParamGrid.MinVal">
            <summary>
            Minimum value of the statmodel parameter. Default value is 0.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ParamGrid.MaxVal">
            <summary>
            Maximum value of the statmodel parameter. Default value is 0.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.ParamGrid.LogStep">
            <summary>
            Logarithmic step for iterating the statmodel parameter.
            </summary>
            <remarks>
            The grid determines the following iteration sequence of the statmodel parameter values:
            \f[(minVal, minVal*step, minVal*{step}^2, \dots,  minVal*{logStep}^n),\f]
            where \f$n\f$ is the maximal index satisfying
            \f[\texttt{minVal} * \texttt{logStep} ^n &lt; \texttt{maxVal}\f]
            The grid is logarithmic, so logStep must always be greater then 1. Default value is 1.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.ParamGrid.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructor with parameters
            </summary>
            <param name="minVal"></param>
            <param name="maxVal"></param>
            <param name="logStep"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.RTrees">
            <summary>
            The class implements the random forest predictor.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.RTrees.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::RTrees*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.RTrees.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.RTrees.Load(System.String)">
            <summary>
            Loads and creates a serialized model from a file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.RTrees.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">he string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.RTrees.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.RTrees.CalculateVarImportance">
            <summary>
            If true then variable importance will be calculated and then 
            it can be retrieved by RTrees::getVarImportance. Default value is false.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.RTrees.ActiveVarCount">
            <summary>
            The size of the randomly selected subset of features at each tree node 
            and that are used to find the best split(s).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.RTrees.TermCriteria">
            <summary>
            The termination criteria that specifies when the training algorithm stops.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.RTrees.GetVarImportance">
            <summary>
            Returns the variable importance array. 
            The method returns the variable importance vector, computed at the training 
            stage when CalculateVarImportance is set to true. If this flag was set to false, 
            the empty matrix is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.StatModel">
            <summary>
            Base class for statistical models in ML
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.StatModel.GetVarCount">
            <summary>
            Returns the number of variables in training samples
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.StatModel.Empty">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.StatModel.IsTrained">
            <summary>
            Returns true if the model is trained
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.StatModel.IsClassifier">
            <summary>
            Returns true if the model is classifier
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.StatModel.Train(ST4IVisionCoreNet.ML.TrainData,System.Int32)">
            <summary>
            Trains the statistical model
            </summary>
            <param name="trainData">training data that can be loaded from file using TrainData::loadFromCSV 
            or created with TrainData::create.</param>
            <param name="flags"> optional flags, depending on the model. Some of the models can be updated with the 
            new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP).</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.StatModel.Train(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.ML.SampleTypes,ST4IVisionCoreNet.InputArray)">
            <summary>
            Trains the statistical model
            </summary>
            <param name="samples">training samples</param>
            <param name="layout">SampleTypes value</param>
            <param name="responses">vector of responses associated with the training samples.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.StatModel.CalcError(ST4IVisionCoreNet.ML.TrainData,System.Boolean,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Computes error on the training or test dataset
            </summary>
            <param name="data">the training data</param>
            <param name="test">if true, the error is computed over the test subset of the data, 
            otherwise it's computed over the training subset of the data. Please note that if you 
            loaded a completely different dataset to evaluate already trained classifier, you will 
            probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio 
            and specify test=false, so that the error is computed for the whole new set. Yes, this 
            sounds a bit confusing.</param>
            <param name="resp">the optional output responses.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.StatModel.Predict(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.ML.StatModel.Flags)">
            <summary>
            Predicts response(s) for the provided sample(s)
            </summary>
            <param name="samples">The input samples, floating-point matrix</param>
            <param name="results">The optional output matrix of results.</param>
            <param name="flags">The optional flags, model-dependent.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.StatModel.Flags">
            <summary>
            Predict options
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.StatModel.Flags.RawOutput">
            <summary>
            makes the method return the raw results (the sum), not the class label
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.SVM">
            <summary>
            Support Vector Machines
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::SVM*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.Create">
            <summary>
            Creates empty model.
            Use StatModel::Train to train the model. 
            Since %SVM has several parameters, you may want to find the best 
            parameters for your problem, it can be done with SVM::TrainAuto.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.Load(System.String)">
            <summary>
            Loads and creates a serialized svm from a file.
            Use SVM::save to serialize and store an SVM to disk.
            Load the SVM from this file again, by calling this function with the path to the file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">The string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.Type">
            <summary>
            Type of a %SVM formulation. 
            Default value is SVM::C_SVC.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.Gamma">
            <summary>
            Parameter gamma of a kernel function.
            For SVM::POLY, SVM::RBF, SVM::SIGMOID or SVM::CHI2. Default value is 1. 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.Coef0">
            <summary>
            Parameter coef0 of a kernel function.
            For SVM::POLY or SVM::SIGMOID. Default value is 0.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.Degree">
            <summary>
            Parameter degree of a kernel function.
            For SVM::POLY. Default value is 0.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.C">
            <summary>
            Parameter C of a %SVM optimization problem.
            For SVM::C_SVC, SVM::EPS_SVR or SVM::NU_SVR. Default value is 0.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.Nu">
            <summary>
            Parameter nu of a %SVM optimization problem.
            For SVM::NU_SVC, SVM::ONE_CLASS or SVM::NU_SVR. Default value is 0.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.P">
            <summary>
            Parameter epsilon of a %SVM optimization problem.
            For SVM::EPS_SVR. Default value is 0.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.ClassWeights">
            <summary>
            Optional weights in the SVM::C_SVC problem, assigned to particular classes.
            </summary>
            <remarks>
            They are multiplied by _C_ so the parameter _C_ of class _i_ becomes `classWeights(i) * C`. 
            Thus these weights affect the misclassification penalty for different classes. 
            The larger weight, the larger penalty on misclassification of data from the 
            corresponding class. Default value is empty Mat.
            </remarks>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.TermCriteria">
            <summary>
            Termination criteria of the iterative SVM training procedure 
            which solves a partial case of constrained quadratic optimization problem.
            </summary>
            <remarks>
            You can specify tolerance and/or the maximum number of iterations. 
            Default value is `TermCriteria( TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, FLT_EPSILON )`;
            </remarks>
        </member>
        <member name="P:ST4IVisionCoreNet.ML.SVM.KernelType">
            <summary>
            Type of a %SVM kernel. See SVM::KernelTypes. Default value is SVM::RBF.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.TrainAuto(ST4IVisionCoreNet.ML.TrainData,System.Int32,System.Nullable{ST4IVisionCoreNet.ML.ParamGrid},System.Nullable{ST4IVisionCoreNet.ML.ParamGrid},System.Nullable{ST4IVisionCoreNet.ML.ParamGrid},System.Nullable{ST4IVisionCoreNet.ML.ParamGrid},System.Nullable{ST4IVisionCoreNet.ML.ParamGrid},System.Nullable{ST4IVisionCoreNet.ML.ParamGrid},System.Boolean)">
            <summary>
            Trains an %SVM with optimal parameters.
            </summary>
            <param name="data">the training data that can be constructed using 
            TrainData::create or TrainData::loadFromCSV.</param>
            <param name="kFold">Cross-validation parameter. The training set is divided into kFold subsets. 
            One subset is used to test the model, the others form the train set. So, the %SVM algorithm is 
            executed kFold times.</param>
            <param name="cGrid">grid for C</param>
            <param name="gammaGrid">grid for gamma</param>
            <param name="pGrid">grid for p</param>
            <param name="nuGrid">grid for nu</param>
            <param name="coeffGrid">grid for coeff</param>
            <param name="degreeGrid">grid for degree</param>
            <param name="balanced">If true and the problem is 2-class classification then the method creates 
            more balanced cross-validation subsets that is proportions between classes in subsets are close 
            to such proportion in the whole train dataset.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.GetSupportVectors">
            <summary>
            Retrieves all the support vectors
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.GetDecisionFunction(System.Int32,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Retrieves the decision function
            </summary>
            <param name="i">i the index of the decision function. 
            If the problem solved is regression, 1-class or 2-class classification, then 
            there will be just one decision function and the index should always be 0. 
            Otherwise, in the case of N-class classification, there will be N(N-1)/2 decision functions.</param>
            <param name="alpha">alpha the optional output vector for weights, corresponding to 
            different support vectors. In the case of linear %SVM all the alpha's will be 1's.</param>
            <param name="svidx">the optional output vector of indices of support vectors 
            within the matrix of support vectors (which can be retrieved by SVM::getSupportVectors). 
            In the case of linear %SVM each decision function consists of a single "compressed" support vector.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.SVM.GetDefaultGrid(ST4IVisionCoreNet.ML.SVM.ParamTypes)">
            <summary>
            Generates a grid for SVM parameters.
            </summary>
            <param name="paramId">SVM parameters IDs that must be one of the SVM::ParamTypes. 
            The grid is generated for the parameter with this ID.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.SVM.Types">
            <summary>
            SVM type
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.Types.CSvc">
            <summary>
            C-Support Vector Classification. n-class classification (n \f$\geq\f$ 2), 
            allows imperfect separation of classes with penalty multiplier C for outliers.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.Types.NuSvc">
            <summary>
            nu-Support Vector Classification. n-class classification with possible
            imperfect separation. Parameter \f$\nu\f$ (in the range 0..1, the larger 
            the value, the smoother the decision boundary) is used instead of C.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.Types.OneClass">
            <summary>
            Distribution Estimation (One-class %SVM). All the training data are from
            the same class, %SVM builds a boundary that separates the class from the 
            rest of the feature space.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.Types.EpsSvr">
            <summary>
            epsilon-Support Vector Regression. 
            The distance between feature vectors from the training set and the fitting 
            hyper-plane must be less than p. For outliers the penalty multiplier C is used.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.Types.NuSvr">
            <summary>
            nu-Support Vector Regression. \f$\nu\f$ is used instead of p.
            See @cite LibSVM for details.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.SVM.KernelTypes">
            <summary>
            SVM kernel type
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.KernelTypes.Custom">
            <summary>
            Returned by SVM::getKernelType in case when custom kernel has been set
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.KernelTypes.Linear">
            <summary>
            Linear kernel. No mapping is done, linear discrimination (or regression) is
            done in the original feature space. It is the fastest option. \f$K(x_i, x_j) = x_i^T x_j\f$.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.KernelTypes.Poly">
            <summary>
            Polynomial kernel:
            \f$K(x_i, x_j) = (\gamma x_i^T x_j + coef0)^{degree}, \gamma &gt; 0\f$.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.KernelTypes.Rbf">
            <summary>
            Radial basis function (RBF), a good choice in most cases.
            \f$K(x_i, x_j) = e^{-\gamma ||x_i - x_j||^2}, \gamma > 0\f$.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.KernelTypes.Sigmoid">
            <summary>
            Sigmoid kernel: 
            \f$K(x_i, x_j) = \tanh(\gamma x_i^T x_j + coef0)\f$.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.KernelTypes.Chi2">
            <summary>
            Exponential Chi2 kernel, similar to the RBF kernel:
            \f$K(x_i, x_j) = e^{-\gamma \chi^2(x_i,x_j)}, \chi^2(x_i,x_j) = (x_i-x_j)^2/(x_i+x_j), \gamma &gt; 0\f$. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.ML.SVM.KernelTypes.Inter">
            <summary>
            Histogram intersection kernel. 
            A fast kernel. \f$K(x_i, x_j) = min(x_i,x_j)\f$. 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.SVM.ParamTypes">
            <summary>
            SVM params type
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ML.TrainData">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ML.TrainData.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.EM">
            <summary>
            The class implements the Expectation Maximization algorithm.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.#ctor(System.IntPtr)">
            <summary>
            Creates instance by pointer cv::Ptr&lt;EM&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.Create">
            <summary>
            Creates empty EM model. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.Load(System.String)">
            <summary>
            Loads and creates a serialized model from a file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.LoadFromString(System.String)">
            <summary>
            Loads algorithm from a String.
            </summary>
            <param name="strModel">he string variable containing the model you want to load.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.EM.ClustersNumber">
            <summary>
            The number of mixture components in the Gaussian mixture model.
            Default value of the parameter is EM::DEFAULT_NCLUSTERS=5. 
            Some of EM implementation could determine the optimal number of mixtures 
            within a specified value range, but that is not the case in ML yet.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.EM.CovarianceMatrixType">
            <summary>
            Constraint on covariance matrices which defines type of matrices.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.EM.TermCriteria">
            <summary>
            The termination criteria of the %EM algorithm.
            The EM algorithm can be terminated by the number of iterations 
            termCrit.maxCount (number of M-steps) or when relative change of likelihood 
            logarithm is less than termCrit.epsilon. 
            Default maximum number of iterations is EM::DEFAULT_MAX_ITERS=100.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.GetWeights">
            <summary>
            Returns weights of the mixtures.
            Returns vector with the number of elements equal to the number of mixtures.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.GetMeans">
            <summary>
            Returns the cluster centers (means of the Gaussian mixture).
            Returns matrix with the number of rows equal to the number of mixtures and 
            number of columns equal to the space dimensionality.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.GetCovs">
            <summary>
            Returns covariation matrices.
            Returns vector of covariation matrices. Number of matrices is the number of 
            gaussian mixtures, each matrix is a square floating-point matrix NxN, where N is the space dimensionality.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.TrainEM(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Estimate the Gaussian mixture parameters from a samples set.
            </summary>
            <param name="samples">Samples from which the Gaussian mixture model will be estimated. It should be a
            one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type
            it will be converted to the inner matrix of such type for the further computing.</param>
            <param name="logLikelihoods">The optional output matrix that contains a likelihood logarithm value for
            each sample. It has \f$nsamples \times 1\f$ size and CV_64FC1 type.</param>
            <param name="labels">The optional output "class label" for each sample:
            \f$\texttt{labels}_i=\texttt{arg max}_k(p_{i,k}), i=1..N\f$ (indices of the most probable
            mixture component for each sample). It has \f$nsamples \times 1\f$ size and CV_32SC1 type.</param>
            <param name="probs">The optional output matrix that contains posterior probabilities of each Gaussian
            mixture component given the each sample. It has \f$nsamples \times nclusters\f$ size and CV_64FC1 type.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.TrainE(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Estimate the Gaussian mixture parameters from a samples set.
            </summary>
            <param name="samples">Samples from which the Gaussian mixture model will be estimated. It should be a
            one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type
            it will be converted to the inner matrix of such type for the further computing.</param>
            <param name="means0">Initial means \f$a_k\f$ of mixture components. It is a one-channel matrix of
            \f$nclusters \times dims\f$ size. If the matrix does not have CV_64F type it will be
            converted to the inner matrix of such type for the further computing.</param>
            <param name="covs0">The vector of initial covariance matrices \f$S_k\f$ of mixture components. Each of
            covariance matrices is a one-channel matrix of \f$dims \times dims\f$ size. If the matrices
            do not have CV_64F type they will be converted to the inner matrices of such type for the further computing.</param>
            <param name="weights0">Initial weights \f$\pi_k\f$ of mixture components. It should be a one-channel
            floating-point matrix with \f$1 \times nclusters\f$ or \f$nclusters \times 1\f$ size.</param>
            <param name="logLikelihoods">The optional output matrix that contains a likelihood logarithm value for
            each sample. It has \f$nsamples \times 1\f$ size and CV_64FC1 type.</param>
            <param name="labels">The optional output "class label" for each sample:
            \f$\texttt{labels}_i=\texttt{arg max}_k(p_{i,k}), i=1..N\f$ (indices of the most probable
            mixture component for each sample). It has \f$nsamples \times 1\f$ size and CV_32SC1 type.</param>
            <param name="probs">The optional output matrix that contains posterior probabilities of each Gaussian
            mixture component given the each sample. It has \f$nsamples \times nclusters\f$ size and CV_64FC1 type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.TrainM(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Estimate the Gaussian mixture parameters from a samples set.
            </summary>
            <param name="samples">Samples from which the Gaussian mixture model will be estimated. It should be a
            one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type
            it will be converted to the inner matrix of such type for the further computing.</param>
            <param name="probs0">the probabilities</param>
            <param name="logLikelihoods">The optional output matrix that contains a likelihood logarithm value for
            each sample. It has \f$nsamples \times 1\f$ size and CV_64FC1 type.</param>
            <param name="labels">The optional output "class label" for each sample:
            \f$\texttt{labels}_i=\texttt{arg max}_k(p_{i,k}), i=1..N\f$ (indices of the most probable
            mixture component for each sample). It has \f$nsamples \times 1\f$ size and CV_32SC1 type.</param>
            <param name="probs">The optional output matrix that contains posterior probabilities of each Gaussian
            mixture component given the each sample. It has \f$nsamples \times nclusters\f$ size and CV_64FC1 type.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.EM.Predict2(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Predicts the response for sample
            </summary>
            <param name="sample">A sample for classification. It should be a one-channel matrix of
            \f$1 \times dims\f$ or \f$dims \times 1\f$ size.</param>
            <param name="probs">Optional output matrix that contains posterior probabilities of each component
            given the sample. It has \f$1 \times nclusters\f$ size and CV_64FC1 type.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.EMTypes">
            <summary>
            Type of covariation matrices
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EMTypes.CovMatSpherical">
            <summary>
            A scaled identity matrix \f$\mu_k * I\f$. 
            There is the only parameter \f$\mu_k\f$ to be estimated for each matrix. 
            The option may be used in special cases, when the constraint is relevant, 
            or as a first step in the optimization (for example in case when the data is 
            preprocessed with PCA). The results of such preliminary estimation may be 
            passed again to the optimization procedure, this time with covMatType=EM::COV_MAT_DIAGONAL.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EMTypes.CovMatDiagonal">
            <summary>
            A diagonal matrix with positive diagonal elements. 
            The number of free parameters is d for each matrix. 
            This is most commonly used option yielding good estimation results. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EMTypes.CovMatGeneric">
            <summary>
            A symmetric positively defined matrix. The number of free parameters in each 
            matrix is about \f$d^2/2\f$. It is not recommended to use this option, unless 
            there is pretty accurate initial estimation of the parameters and/or a huge number 
            of training samples.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EMTypes.CovMatDefault">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.EMStartStep">
            <summary>
            The initial step the algorithm starts from
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EMStartStep.E">
            <summary>
            The algorithm starts with E-step. 
            At least, the initial values of mean vectors, CvEMParams.Means must be passed. 
            Optionally, the user may also provide initial values for weights (CvEMParams.Weights) 
            and/or covariation matrices (CvEMParams.Covs).
            [CvEM::START_E_STEP]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EMStartStep.M">
            <summary>
            The algorithm starts with M-step. The initial probabilities p_i,k must be provided.
            [CvEM::START_M_STEP]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EMStartStep.Auto">
            <summary>
            No values are required from the user, k-means algorithm is used to estimate initial mixtures parameters. 
            [CvEM::START_AUTO_STEP]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CascadeClassifier">
            <summary>
            Cascade classifier class for object detection.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.#ctor(System.String)">
            <summary>
            Loads a classifier from a file.
            </summary>
            <param name="fileName">Name of the file from which the classifier is loaded.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.Empty">
            <summary>
            Checks whether the classifier has been loaded.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.Load(System.String)">
            <summary>
            Loads a classifier from a file.
            </summary>
            <param name="fileName">Name of the file from which the classifier is loaded. 
            The file may contain an old HAAR classifier trained by the haartraining application 
            or a new cascade classifier trained by the traincascade application.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.Read(ST4IVisionCoreNet.FileNode)">
            <summary>
            Reads a classifier parameters from a file storage
            </summary>
            <param name="fn"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.DetectMultiScale(ST4IVisionCoreNet.Mat,System.Double,System.Int32,ST4IVisionCoreNet.HaarDetectionTypes,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles.
            </summary>
            <param name="image">Matrix of the type CV_8U containing an image where objects are detected.</param>
            <param name="scaleFactor">Parameter specifying how much the image size is reduced at each image scale.</param>
            <param name="minNeighbors">Parameter specifying how many neighbors each candidate rectangle should have to retain it.</param>
            <param name="flags">Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. 
            It is not used for a new cascade.</param>
            <param name="minSize">Minimum possible object size. Objects smaller than that are ignored.</param>
            <param name="maxSize">Maximum possible object size. Objects larger than that are ignored.</param>
            <returns>Vector of rectangles where each rectangle contains the detected object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.DetectMultiScale(ST4IVisionCoreNet.Mat,System.Int32[]@,System.Double[]@,System.Double,System.Int32,ST4IVisionCoreNet.HaarDetectionTypes,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},System.Boolean)">
            <summary>
            Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles.
            </summary>
            <param name="image">Matrix of the type CV_8U containing an image where objects are detected.</param>
            <param name="rejectLevels"></param>
            <param name="levelWeights"></param>
            <param name="scaleFactor">Parameter specifying how much the image size is reduced at each image scale.</param>
            <param name="minNeighbors">Parameter specifying how many neighbors each candidate rectangle should have to retain it.</param>
            <param name="flags">Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. 
            It is not used for a new cascade.</param>
            <param name="minSize">Minimum possible object size. Objects smaller than that are ignored.</param>
            <param name="maxSize">Maximum possible object size. Objects larger than that are ignored.</param>
            <param name="outputRejectLevels"></param>
            <returns>Vector of rectangles where each rectangle contains the detected object.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.IsOldFormatCascade">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.GetOriginalWindowSize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CascadeClassifier.GetFeatureType">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.HaarDetectionTypes">
            <summary>
            Modes of operation for cvHaarDetectObjects
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HaarDetectionTypes.DoCannyPruning">
            <summary>
            If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. 
            The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing.
            [CV_HAAR_DO_CANNY_PRUNING]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HaarDetectionTypes.ScaleImage">
            <summary>
            For each scale factor used the function will downscale the image rather than "zoom" the feature coordinates in the classifier cascade. 
            Currently, the option can only be used alone, i.e. the flag can not be set together with the others.
            [CV_HAAR_SCALE_IMAGE]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HaarDetectionTypes.FindBiggestObject">
            <summary>
            If it is set, the function finds the largest object (if any) in the image. That is, the output sequence will contain one (or zero) element(s).
            [CV_HAAR_FIND_BIGGEST_OBJECT]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HaarDetectionTypes.DoRoughSearch">
            <summary>
            It should be used only when FindBiggestObject is set and min_neighbors > 0. 
            If the flag is set, the function does not look for candidates of a smaller size 
            as soon as it has found the object (with enough neighbor candidates) at the current scale. 
            Typically, when min_neighbors is fixed, the mode yields less accurate (a bit larger) object rectangle 
            than the regular single-object mode (flags=FindBiggestObject), 
            but it is much faster, up to an order of magnitude. A greater value of min_neighbors may be specified to improve the accuracy.
            [CV_HAAR_DO_ROUGH_SEARCH]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.HistogramNormType">
            <summary>
            L2-Hys normalization method
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HistogramNormType.L2Hys">
            <summary>
            [HOGDescriptor::L2Hys]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.HOGDescriptor">
            <summary>
            HOG (Histogram-of-Oriented-Gradients) Descriptor and Object Detector
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HOGDescriptor.L2Hys">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HOGDescriptor.DefaultNlevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HOGDescriptor.DefaultPeopleDetector">
            <summary>
            Returns coefficients of the classifier trained for people detection (for default window size).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.HOGDescriptor.DaimlerPeopleDetector">
            <summary>
            This field returns 1981 SVM coeffs obtained from daimler's base.
            To use these coeffs the detection window size should be (48,96)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.#ctor(System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},System.Int32,System.Int32,System.Double,ST4IVisionCoreNet.HistogramNormType,System.Double,System.Boolean,System.Int32)">
            <summary>
            Creates the HOG descriptor and detector.
            </summary>
            <param name="winSize">Detection window size. Align to block size and block stride.</param>
            <param name="blockSize">Block size in pixels. Align to cell size. Only (16,16) is supported for now.</param>
            <param name="blockStride">Block stride. It must be a multiple of cell size.</param>
            <param name="cellSize">Cell size. Only (8, 8) is supported for now.</param>
            <param name="nbins">Number of bins. Only 9 bins per cell are supported for now.</param>
            <param name="derivAperture"></param>
            <param name="winSigma">Gaussian smoothing window parameter.</param>
            <param name="histogramNormType"></param>
            <param name="l2HysThreshold">L2-Hys normalization method shrinkage.</param>
            <param name="gammaCorrection">Flag to specify whether the gamma correction preprocessing is required or not.</param>
            <param name="nlevels">Maximum number of detection window increases.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.#ctor(System.String)">
            <summary>
            Construct from a file containing HOGDescriptor properties and coefficients for the linear SVM classifier.
            </summary>
            <param name="fileName">The file name containing HOGDescriptor properties and coefficients for the linear SVM classifier.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.WinSize">
            <summary>
            Detection window size. Align to block size and block stride. Default value is Size(64,128).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.BlockSize">
            <summary>
            Block size in pixels. Align to cell size. Default value is Size(16,16).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.BlockStride">
            <summary>
            Block stride. It must be a multiple of cell size. Default value is Size(8,8).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.CellSize">
            <summary>
            Cell size. Default value is Size(8,8).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.Nbins">
            <summary> 
            Number of bins used in the calculation of histogram of gradients. Default value is 9.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.DerivAperture">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.WinSigma">
            <summary>
            Gaussian smoothing window parameter.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.HistogramNormType">
            <summary>
            HistogramNormType
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.L2HysThreshold">
            <summary>
            L2-Hys normalization method shrinkage.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.GammaCorrection">
            <summary>
            Flag to specify whether the gamma correction preprocessing is required or not.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.NLevels">
            <summary>
            Maximum number of detection window increases. Default value is 64
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HOGDescriptor.SignedGradient">
            <summary>
            Indicates signed gradient will be used or not
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.GetDefaultPeopleDetector">
            <summary>
            Returns coefficients of the classifier trained for people detection (for default window size).
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.GetDaimlerPeopleDetector">
            <summary>
            This method returns 1981 SVM coeffs obtained from daimler's base.
            To use these coeffs the detection window size should be (48,96)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.SetSVMDetector(System.Single[])">
            <summary>
            Sets coefficients for the linear SVM classifier.
            </summary>
            <param name="svmDetector">coefficients for the linear SVM classifier.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.Load(System.String,System.String)">
            <summary>
            loads HOGDescriptor parameters and coefficients for the linear SVM classifier from a file.
            </summary>
            <param name="fileName">Path of the file to read.</param>
            <param name="objName">The optional name of the node to read (if empty, the first top-level node will be used).</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.Save(System.String,System.String)">
            <summary>
            saves HOGDescriptor parameters and coefficients for the linear SVM classifier to a file
            </summary>
            <param name="fileName">File name</param>
            <param name="objName">Object name</param>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.GetDescriptorSize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.CheckDetectorSize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.GetWinSigma">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.Compute(ST4IVisionCoreNet.Mat,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},ST4IVisionCoreNet.Point[])">
            <summary>
            Computes HOG descriptors of given image.
            </summary>
            <param name="img">Matrix of the type CV_8U containing an image where HOG features will be calculated.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Padding</param>
            <param name="locations">Vector of Point</param>
            <returns>Matrix of the type CV_32F</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.Detect(ST4IVisionCoreNet.Mat,System.Double,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},ST4IVisionCoreNet.Point[])">
            <summary>
            Performs object detection without a multi-scale window.
            </summary>
            <param name="img">Source image. CV_8UC1 and CV_8UC4 types are supported for now.</param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane. 
            Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient). 
            But if the free coefficient is omitted (which is allowed), you can specify it manually here.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep the CPU interface compatibility. It must be (0,0).</param>
            <param name="searchLocations"></param>
            <returns>Left-top corner points of detected objects boundaries.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.Detect(ST4IVisionCoreNet.Mat,System.Double[]@,System.Double,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},ST4IVisionCoreNet.Point[])">
            <summary>
            Performs object detection without a multi-scale window.
            </summary>
            <param name="img">Source image. CV_8UC1 and CV_8UC4 types are supported for now.</param>
            <param name="weights"></param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane. 
            Usually it is 0 and should be specfied in the detector coefficients (as the last free coefficient). 
            But if the free coefficient is omitted (which is allowed), you can specify it manually here.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep the CPU interface compatibility. It must be (0,0).</param>
            <param name="searchLocations"></param>
            <returns>Left-top corner points of detected objects boundaries.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.DetectMultiScale(ST4IVisionCoreNet.Mat,System.Double,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},System.Double,System.Int32)">
            <summary>
            Performs object detection with a multi-scale window.
            </summary>
            <param name="img">Source image. CV_8UC1 and CV_8UC4 types are supported for now.</param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep the CPU interface compatibility. It must be (0,0).</param>
            <param name="scale">Coefficient of the detection window increase.</param>
            <param name="groupThreshold">Coefficient to regulate the similarity threshold. 
            When detected, some objects can be covered by many rectangles. 0 means not to perform grouping.</param>
            <returns>Detected objects boundaries.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.DetectMultiScale(ST4IVisionCoreNet.Mat,System.Double[]@,System.Double,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size},System.Double,System.Int32)">
            <summary>
            Performs object detection with a multi-scale window.
            </summary>
            <param name="img">Source image. CV_8UC1 and CV_8UC4 types are supported for now.</param>
            <param name="foundWeights"></param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep the CPU interface compatibility. It must be (0,0).</param>
            <param name="scale">Coefficient of the detection window increase.</param>
            <param name="groupThreshold">Coefficient to regulate the similarity threshold. 
            When detected, some objects can be covered by many rectangles. 0 means not to perform grouping.</param>
            <returns>Detected objects boundaries.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.ComputeGradient(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            Computes gradients and quantized gradient orientations.
            </summary>
            <param name="img">Matrix contains the image to be computed</param>
            <param name="grad">Matrix of type CV_32FC2 contains computed gradients</param>
            <param name="angleOfs">Matrix of type CV_8UC2 contains quantized gradient orientations</param>
            <param name="paddingTL">Padding from top-left</param>
            <param name="paddingBR">Padding from bottom-right</param>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.DetectROI(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Point[],ST4IVisionCoreNet.Point[]@,System.Double[]@,System.Double,System.Nullable{ST4IVisionCoreNet.Size},System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            evaluate specified ROI and return confidence value for each location
            </summary>
            <param name="img">Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.</param>
            <param name="locations">Vector of Point</param>
            <param name="foundLocations">Vector of Point where each Point is detected object's top-left point.</param>
            <param name="confidences">confidences</param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane. Usually
            it is 0 and should be specified in the detector coefficients (as the last free coefficient). But if
            the free coefficient is omitted (which is allowed), you can specify it manually here</param>
            <param name="winStride">winStride</param>
            <param name="padding">padding</param>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.DetectMultiScaleROI(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Rect[]@,ST4IVisionCoreNet.DetectionROI[]@,System.Double,System.Int32)">
            <summary>
            evaluate specified ROI and return confidence value for each location in multiple scales
            </summary>
            <param name="img">Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.</param>
            <param name="foundLocations">Vector of rectangles where each rectangle contains the detected object.</param>
            <param name="locations">Vector of DetectionROI</param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specified
            in the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here.</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.HOGDescriptor.GroupRectangles(ST4IVisionCoreNet.Rect[]@,System.Double[]@,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles. (The Python list is not modified in place.)</param>
            <param name="weights">Input/output vector of weights of rectangles. Output vector includes weights of retained and grouped rectangles. (The Python list is not modified in place.)</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.DetectionROI">
            <summary>
            struct for detection region of interest (ROI)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DetectionROI.Scale">
            <summary>
            scale(size) of the bounding box
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DetectionROI.Locations">
            <summary>
            set of requested locations to be evaluated
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DetectionROI.Confidences">
            <summary>
            vector that will contain confidence values for each location
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DetectionROI.#ctor(System.Double,ST4IVisionCoreNet.Point[],System.Double[])">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.QRCodeDetector">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.SetEpsX(System.Double)">
            <summary>
            sets the epsilon used during the horizontal scan of QR code stop marker detection.
            </summary>
            <param name="epsX">Epsilon neighborhood, which allows you to determine the horizontal pattern 
            of the scheme 1:1:3:1:1 according to QR code standard.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.SetEpsY(System.Double)">
            <summary>
            sets the epsilon used during the vertical scan of QR code stop marker detection.
            </summary>
            <param name="epsY">Epsilon neighborhood, which allows you to determine the vertical pattern
            of the scheme 1:1:3:1:1 according to QR code standard.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[]@)">
            <summary>
            Detects QR code in image and returns the quadrangle containing the code.
            </summary>
            <param name="img">grayscale or color (BGR) image containing (or not) QR code.</param>
            <param name="points">Output vector of vertices of the minimum-area quadrangle containing the code.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.Decode(ST4IVisionCoreNet.InputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},ST4IVisionCoreNet.OutputArray)">
            <summary>
            Decodes QR code in image once it's found by the detect() method.
            Returns UTF8-encoded output string or empty string if the code cannot be decoded.
            </summary>
            <param name="img">grayscale or color (BGR) image containing QR code.</param>
            <param name="points">Quadrangle vertices found by detect() method (or some other algorithm).</param>
            <param name="straightQrCode">The optional output image containing rectified and binarized QR code</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.DetectAndDecode(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[]@,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Both detects and decodes QR code
            </summary>
            <param name="img">grayscale or color (BGR) image containing QR code.</param>
            <param name="points">optional output array of vertices of the found QR code quadrangle. Will be empty if not found.</param>
            <param name="straightQrCode">The optional output image containing rectified and binarized QR code</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.DetectMulti(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Point2f[]@)">
            <summary>
            Detects QR codes in image and returns the quadrangles containing the codes.
            </summary>
            <param name="img">grayscale or color (BGR) image containing (or not) QR code.</param>
            <param name="points">Output vector of vertices of the minimum-area quadrangle containing the codes.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.DecodeMulti(ST4IVisionCoreNet.InputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.String[]@)">
            <summary>
            Decodes QR codes in image once it's found by the detect() method.
            Returns UTF8-encoded output string or empty string if the code cannot be decoded.
            </summary>
            <param name="img">grayscale or color (BGR) image containing QR code.</param>
            <param name="points">Quadrangle vertices found by detect() method (or some other algorithm).</param>
            <param name="decodedInfo">UTF8-encoded output vector of string or empty vector of string if the codes cannot be decoded. </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.DecodeMulti(ST4IVisionCoreNet.InputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.String[]@,ST4IVisionCoreNet.Mat[]@)">
            <summary>
            Decodes QR codes in image once it's found by the detect() method.
            Returns UTF8-encoded output string or empty string if the code cannot be decoded.
            </summary>
            <param name="img">grayscale or color (BGR) image containing QR code.</param>
            <param name="points">Quadrangle vertices found by detect() method (or some other algorithm).</param>
            <param name="decodedInfo">UTF8-encoded output vector of string or empty vector of string if the codes cannot be decoded. </param>
            <param name="straightQrCode">The optional output image containing rectified and binarized QR code</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.QRCodeDetector.DecodeMulti(ST4IVisionCoreNet.InputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point2f},System.String[]@,ST4IVisionCoreNet.Mat[]@,System.Boolean)">
            <summary>
            Decodes QR codes in image once it's found by the detect() method.
            Returns UTF8-encoded output string or empty string if the code cannot be decoded.
            </summary>
            <param name="img">grayscale or color (BGR) image containing QR code.</param>
            <param name="points">Quadrangle vertices found by detect() method (or some other algorithm).</param>
            <param name="decodedInfo">UTF8-encoded output vector of string or empty vector of string if the codes cannot be decoded. </param>
            <param name="straightQrCode">The optional output image containing rectified and binarized QR code</param>
            <param name="isOutputStraightQrCode"><see langword="true"/> to output <paramref name="straightQrCode"/></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.SimilarRects">
            <summary>
            Class for grouping object candidates, detected by Cascade Classifier, HOG etc.
            instance of the class is to be passed to cv::partition (see cxoperations.hpp)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SimilarRects.Compare(System.Double,ST4IVisionCoreNet.Rect,ST4IVisionCoreNet.Rect)">
            <summary>
            
            </summary>
            <param name="eps"></param>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.OptFlow.CvOptFlow">
            <summary>
            cv::optflow functions
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.OptFlow.CvOptFlow.UpdateMotionHistory(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,System.Double,System.Double)">
            <summary>
            Updates motion history image using the current silhouette
            </summary>
            <param name="silhouette">Silhouette mask that has non-zero pixels where the motion occurs.</param>
            <param name="mhi">Motion history image that is updated by the function (single-channel, 32-bit floating-point).</param>
            <param name="timestamp">Current time in milliseconds or other units.</param>
            <param name="duration">Maximal duration of the motion track in the same units as timestamp .</param>
        </member>
        <member name="M:ST4IVisionCoreNet.OptFlow.CvOptFlow.CalcMotionGradient(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,System.Int32)">
            <summary>
            Computes the motion gradient orientation image from the motion history image
            </summary>
            <param name="mhi">Motion history single-channel floating-point image.</param>
            <param name="mask">Output mask image that has the type CV_8UC1 and the same size as mhi. 
            Its non-zero elements mark pixels where the motion gradient data is correct.</param>
            <param name="orientation">Output motion gradient orientation image that has the same type and the same size as mhi. 
            Each pixel of the image is a motion orientation, from 0 to 360 degrees.</param>
            <param name="delta1">Minimal (or maximal) allowed difference between mhi values within a pixel neighborhood.</param>
            <param name="delta2">Maximal (or minimal) allowed difference between mhi values within a pixel neighborhood. 
            That is, the function finds the minimum ( m(x,y) ) and maximum ( M(x,y) ) mhi values over 3x3 neighborhood of each pixel 
            and marks the motion orientation at (x, y) as valid only if: 
            min(delta1, delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1, delta2).</param>
            <param name="apertureSize"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.OptFlow.CvOptFlow.CalcGlobalOrientation(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Double,System.Double)">
            <summary>
            Computes the global orientation of the selected motion history image part
            </summary>
            <param name="orientation">Motion gradient orientation image calculated by the function CalcMotionGradient() .</param>
            <param name="mask">Mask image. It may be a conjunction of a valid gradient mask, also calculated by CalcMotionGradient() ,
            and the mask of a region whose direction needs to be calculated.</param>
            <param name="mhi">Motion history image calculated by UpdateMotionHistory() .</param>
            <param name="timestamp">Timestamp passed to UpdateMotionHistory() .</param>
            <param name="duration">Maximum duration of a motion track in milliseconds, passed to UpdateMotionHistory() .</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.OptFlow.CvOptFlow.SegmentMotion(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.Rect[]@,System.Double,System.Double)">
            <summary>
            Splits a motion history image into a few parts corresponding to separate independent motions 
            (for example, left hand, right hand).
            </summary>
            <param name="mhi">Motion history image.</param>
            <param name="segmask">Image where the found mask should be stored, single-channel, 32-bit floating-point.</param>
            <param name="boundingRects">Vector containing ROIs of motion connected components.</param>
            <param name="timestamp">Current time in milliseconds or other units.</param>
            <param name="segThresh">Segmentation threshold that is recommended to be equal to the interval between motion history “steps” or greater.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.OptFlow.CvOptFlow.CalcOpticalFlowSF(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            computes dense optical flow using Simple Flow algorithm
            </summary>
            <param name="from">First 8-bit 3-channel image.</param>
            <param name="to">Second 8-bit 3-channel image</param>
            <param name="flow">Estimated flow</param>
            <param name="layers">Number of layers</param>
            <param name="averagingBlockSize">Size of block through which we sum up when calculate cost function for pixel</param>
            <param name="maxFlow">maximal flow that we search at each level</param>
        </member>
        <member name="M:ST4IVisionCoreNet.OptFlow.CvOptFlow.CalcOpticalFlowSF(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            computes dense optical flow using Simple Flow algorithm
            </summary>
            <param name="from">First 8-bit 3-channel image.</param>
            <param name="to">Second 8-bit 3-channel image</param>
            <param name="flow">Estimated flow</param>
            <param name="layers">Number of layers</param>
            <param name="averagingBlockSize">Size of block through which we sum up when calculate cost function for pixel</param>
            <param name="maxFlow">maximal flow that we search at each level</param>
            <param name="sigmaDist">vector smooth spatial sigma parameter</param>
            <param name="sigmaColor">vector smooth color sigma parameter</param>
            <param name="postprocessWindow">window size for postprocess cross bilateral filter</param>
            <param name="sigmaDistFix">spatial sigma for postprocess cross bilateralf filter</param>
            <param name="sigmaColorFix">color sigma for postprocess cross bilateral filter</param>
            <param name="occThr">threshold for detecting occlusions</param>
            <param name="upscaleAveragingRadius">window size for bilateral upscale operation</param>
            <param name="upscaleSigmaDist">spatial sigma for bilateral upscale operation</param>
            <param name="upscaleSigmaColor">color sigma for bilateral upscale operation</param>
            <param name="speedUpThr">threshold to detect point with irregular flow - where flow should be recalculated after upscale</param>
        </member>
        <member name="M:ST4IVisionCoreNet.OptFlow.CvOptFlow.CalcOpticalFlowSparseToDense(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Single,System.Boolean,System.Single,System.Single)">
            <summary>
            Fast dense optical flow based on PyrLK sparse matches interpolation.
            </summary>
            <param name="from">first 8-bit 3-channel or 1-channel image.</param>
            <param name="to">second 8-bit 3-channel or 1-channel image of the same size as from</param>
            <param name="flow">computed flow image that has the same size as from and CV_32FC2 type</param>
            <param name="gridStep">stride used in sparse match computation. Lower values usually
            result in higher quality but slow down the algorithm.</param>
            <param name="k">number of nearest-neighbor matches considered, when fitting a locally affine
            model. Lower values can make the algorithm noticeably faster at the cost of some quality degradation.</param>
            <param name="sigma">parameter defining how fast the weights decrease in the locally-weighted affine
            fitting. Higher values can help preserve fine details, lower values can help to get rid of the noise in the output flow.</param>
            <param name="usePostProc">defines whether the ximgproc::fastGlobalSmootherFilter() is used for post-processing after interpolation</param>
            <param name="fgsLambda">see the respective parameter of the ximgproc::fastGlobalSmootherFilter()</param>
            <param name="fgsSigma">see the respective parameter of the ximgproc::fastGlobalSmootherFilter()</param>
        </member>
        <member name="T:ST4IVisionCoreNet.CalibrateCRF">
            <summary>
            The base class for camera response calibration algorithms.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CalibrateCRF.Process(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Recovers inverse camera response.
            </summary>
            <param name="src">vector of input images</param>
            <param name="dst">256x1 matrix with inverse camera response function</param>
            <param name="times">vector of exposure time values for each image</param>
        </member>
        <member name="T:ST4IVisionCoreNet.CalibrateDebevec">
            <summary>
            CalibrateDebevec object
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CalibrateDebevec.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::CalibrateDebevec*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CalibrateDebevec.Create(System.Int32,System.Single,System.Boolean)">
            <summary>
            Creates the empty model.
            </summary>
            <param name="samples">number of pixel locations to use</param>
            <param name="lambda">smoothness term weight. Greater values produce smoother results, 
            but can alter the response.</param>
            <param name="random">if true sample pixel locations are chosen at random, 
            otherwise the form a rectangular grid.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CalibrateDebevec.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CalibrateDebevec.Lambda">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CalibrateDebevec.Samples">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CalibrateDebevec.Random">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CalibrateRobertson">
            <summary>
            CalibrateRobertson object
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CalibrateRobertson.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::CalibrateRobertson*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CalibrateRobertson.Create(System.Int32,System.Single)">
            <summary>
            Creates CalibrateRobertson object
            </summary>
            <param name="maxIter">maximal number of Gauss-Seidel solver iterations.</param>
            <param name="threshold">target difference between results of two successive steps of the minimization.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.CalibrateRobertson.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CalibrateRobertson.MaxIter">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CalibrateRobertson.Threshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.CalibrateRobertson.Radiance">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.EdgePreservingMethods">
            <summary>
            Edge preserving filters
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EdgePreservingMethods.RecursFilter">
             <summary>
            Recursive Filtering
             </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.EdgePreservingMethods.NormconvFilter">
            <summary>
            Normalized Convolution Filtering
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.InpaintMethod">
            <summary>
            The inpainting method
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InpaintMethod.NS">
            <summary>
            Navier-Stokes based method.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.InpaintMethod.Telea">
            <summary>
            The method by Alexandru Telea
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MergeDebevec">
             <summary>
             The resulting HDR image is calculated as weighted average of the exposures considering exposure
             values and camera response.
            
             For more information see @cite DM97 .
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MergeDebevec.#ctor(System.IntPtr)">
            <summary>
            Creates instance by MergeDebevec*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MergeDebevec.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MergeDebevec.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MergeExposures">
            <summary>
            The base class algorithms that can merge exposure sequence to a single image.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MergeExposures.Process(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray,System.Collections.Generic.IEnumerable{System.Single},ST4IVisionCoreNet.InputArray)">
            <summary>
            Merges images.
            </summary>
            <param name="src">vector of input images</param>
            <param name="dst">result image</param>
            <param name="times">vector of exposure time values for each image</param>
            <param name="response"> 256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.MergeMertens">
             <summary>
             Pixels are weighted using contrast, saturation and well-exposedness measures, than images are combined using laplacian pyramids.
            
             The resulting image weight is constructed as weighted average of contrast, saturation and well-exposedness measures.
            
             The resulting image doesn't require tonemapping and can be converted to 8-bit image by multiplying by 255,
             but it's recommended to apply gamma correction and/or linear tonemapping.
            
             For more information see @cite MK07 .
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MergeMertens.#ctor(System.IntPtr)">
            <summary>
            Creates instance by MergeMertens*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.MergeMertens.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.MergeMertens.Process(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray)">
            <summary>
            Short version of process, that doesn't take extra arguments.
            </summary>
            <param name="src">vector of input images</param>
            <param name="dst">result image</param>
        </member>
        <member name="M:ST4IVisionCoreNet.MergeMertens.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.SeamlessCloneMethods">
            <summary>
            SeamlessClone method
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SeamlessCloneMethods.NormalClone">
            <summary>
            The power of the method is fully expressed when inserting objects with 
            complex outlines into a new background.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SeamlessCloneMethods.MixedClone">
            <summary>
            The classic method, color-based selection and alpha masking might be time 
            consuming and often leaves an undesirable halo. Seamless cloning, even averaged 
            with the original image, is not effective. Mixed seamless cloning based on a 
            loose selection proves effective.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.SeamlessCloneMethods.MonochromeTransfer">
            <summary>
            Feature exchange allows the user to easily replace certain features of one 
            object by alternative features.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Tonemap">
            <summary>
            Base class for tonemapping algorithms - tools that are used to map HDR image to 8-bit range.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tonemap.#ctor">
            <summary>
            Constructor used by Tonemap.Create
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tonemap.#ctor(System.IntPtr)">
            <summary>
            Constructor used by subclasses
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tonemap.Create(System.Single)">
            <summary>
            Creates simple linear mapper with gamma correction
            </summary>
            <param name="gamma">positive value for gamma correction.
            Gamma value of 1.0 implies no correction, gamma equal to 2.2f is suitable for most displays.
            Generally gamma &gt; 1 brightens the image and gamma &lt; 1 darkens it.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Tonemap.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tonemap.Process(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Tonemaps image
            </summary>
            <param name="src">source image - CV_32FC3 Mat (float 32 bits 3 channels)</param>
            <param name="dst">destination image - CV_32FC3 Mat with values in [0, 1] range</param>
        </member>
        <member name="P:ST4IVisionCoreNet.Tonemap.Gamma">
            <summary>
            Gets or sets positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma
            equal to 2.2f is suitable for most displays.
            Generally gamma &gt; 1 brightens the image and gamma &lt; 1 darkens it.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.TonemapDrago">
             <summary>
             Adaptive logarithmic mapping is a fast global tonemapping algorithm that scales the image in logarithmic domain.
            
             Since it's a global operator the same function is applied to all the pixels, it is controlled by the bias parameter.
             Optional saturation enhancement is possible as described in @cite FL02. For more information see @cite DM03.
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapDrago.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapDrago.Create(System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapDrago object
            </summary>
            <param name="gamma">positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma
            equal to 2.2f is suitable for most displays.
            Generally gamma &gt; 1 brightens the image and gamma &lt; 1 darkens it.</param>
            <param name="saturation">positive saturation enhancement value. 1.0 preserves saturation, values greater 
            than 1 increase saturation and values less than 1 decrease it.</param>
            <param name="bias">value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best 
            results, default value is 0.85.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapDrago.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.TonemapDrago.Saturation">
            <summary>
            Gets or sets positive saturation enhancement value. 1.0 preserves saturation, values greater 
            than 1 increase saturation and values less than 1 decrease it.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.TonemapDrago.Bias">
            <summary>
            Gets or sets value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best 
            results, default value is 0.85.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.TonemapMantiuk">
             <summary>
             This algorithm transforms image to contrast using gradients on all levels of gaussian pyramid,
             transforms contrast values to HVS response and scales the response. After this the image is
             reconstructed from new contrast values.
            
             For more information see @cite MM06.
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapMantiuk.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapMantiuk.Create(System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapMantiuk object
            </summary>
            <param name="gamma">positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma
            equal to 2.2f is suitable for most displays.
            Generally gamma &gt; 1 brightens the image and gamma &lt; 1 darkens it.</param>
            <param name="scale">contrast scale factor. HVS response is multiplied by this parameter, thus compressing
            dynamic range. Values from 0.6 to 0.9 produce best results.</param>
            <param name="saturation"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapMantiuk.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.TonemapMantiuk.Scale">
            <summary>
            Gets or sets contrast scale factor. HVS response is multiplied by this parameter, thus compressing
            dynamic range. Values from 0.6 to 0.9 produce best results.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.TonemapMantiuk.Saturation">
            <summary>
            Gets or sets positive saturation enhancement value. 1.0 preserves saturation, values greater 
            than 1 increase saturation and values less than 1 decrease it.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.TonemapReinhard">
             <summary>
             This is a global tonemapping operator that models human visual system.
            
             Mapping function is controlled by adaptation parameter, that is computed using light adaptation and 
             color adaptation. For more information see @cite RD05.
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapReinhard.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapReinhard.Create(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapReinhard object
            </summary>
            <param name="gamma">positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma
            equal to 2.2f is suitable for most displays.
            Generally gamma &gt; 1 brightens the image and gamma &lt; 1 darkens it.</param>
            <param name="intensity">result intensity in [-8, 8] range. Greater intensity produces brighter results.</param>
            <param name="lightAdapt">light adaptation in [0, 1] range. If 1 adaptation is based only on pixel 
            value, if 0 it's global, otherwise it's a weighted mean of this two cases.</param>
            <param name="colorAdapt">chromatic adaptation in [0, 1] range. If 1 channels are treated independently,
            if 0 adaptation level is the same for each channel.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.TonemapReinhard.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.TonemapReinhard.Intensity">
            <summary>
            Gets or sets result intensity in [-8, 8] range. Greater intensity produces brighter results.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.TonemapReinhard.LightAdaptation">
            <summary>
            Gets or sets light adaptation in [0, 1] range. If 1 adaptation is based only on pixel 
            value, if 0 it's global, otherwise it's a weighted mean of this two cases.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.TonemapReinhard.ColorAdaptation">
            <summary>
            Gets or sets chromatic adaptation in [0, 1] range. If 1 channels are treated independently,
            if 0 adaptation level is the same for each channel.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Quality.QualityBase">
            <summary>
            Quality Base Class
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Quality.QualityBase.Empty">
            <summary>
            Implements Algorithm::empty()
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBase.GetQualityMap(ST4IVisionCoreNet.OutputArray)">
            <summary>
            Returns output quality map that was generated during computation, if supported by the algorithm
            </summary>
            <param name="dst"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBase.Compute(ST4IVisionCoreNet.InputArray)">
            <summary>
            Compute quality score per channel with the per-channel score in each element of the resulting cv::Scalar.
            See specific algorithm for interpreting result scores
            </summary>
            <param name="img">comparison image, or image to evaluate for no-reference quality algorithms</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBase.Clear">
            <summary>
            Implements Algorithm::clear() 
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Quality.QualityBRISQUE">
            <summary>
            BRISQUE (Blind/Referenceless Image Spatial Quality Evaluator) is a No Reference Image Quality Assessment (NR-IQA) algorithm.
            BRISQUE computes a score based on extracting Natural Scene Statistics(https://en.wikipedia.org/wiki/Scene_statistics)
            and calculating feature vectors. See Mittal et al. @cite Mittal2 for original paper and original implementation @cite Mittal2_software.
            A trained model is provided in the /samples/ directory and is trained on the LIVE-R2 database @cite Sheikh as in the original implementation.
            When evaluated against the TID2008 database @cite Ponomarenko, the SROCC is -0.8424 versus the SROCC of -0.8354 in the original implementation.
            C++ code for the BRISQUE LIVE-R2 trainer and TID2008 evaluator are also provided in the /samples/ directory.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBRISQUE.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBRISQUE.Create(System.String,System.String)">
            <summary>
            Create an object which calculates quality
            </summary>
            <param name="modelFilePath">String which contains a path to the BRISQUE model data, eg. /path/to/brisque_model_live.yml</param>
            <param name="rangeFilePath">String which contains a path to the BRISQUE range data, eg. /path/to/brisque_range_live.yml</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBRISQUE.Create(ST4IVisionCoreNet.ML.SVM,ST4IVisionCoreNet.Mat)">
            <summary>
            Create an object which calculates quality
            </summary>
            <param name="model">cv::ml::SVM* which contains a loaded BRISQUE model</param>
            <param name="range">cv::Mat which contains BRISQUE range data</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBRISQUE.Compute(ST4IVisionCoreNet.InputArray,System.String,System.String)">
            <summary>
            static method for computing quality
            </summary>
            <param name="img">image for which to compute quality</param>
            <param name="modelFilePath">String which contains a path to the BRISQUE model data, eg. /path/to/brisque_model_live.yml</param>
            <param name="rangeFilePath">cv::String which contains a path to the BRISQUE range data, eg. /path/to/brisque_range_live.yml</param>
            <returns>cv::Scalar with the score in the first element.  The score ranges from 0 (best quality) to 100 (worst quality)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBRISQUE.ComputeFeatures(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            static method for computing image features used by the BRISQUE algorithm
            </summary>
            <param name="img">image (BGR(A) or grayscale) for which to compute features</param>
            <param name="features">output row vector of features to cv::Mat or cv::UMat</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityBRISQUE.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Quality.QualityGMSD">
            <summary>
            Full reference GMSD algorithm
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityGMSD.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityGMSD.Create(ST4IVisionCoreNet.InputArray)">
            <summary>
            Create an object which calculates quality
            </summary>
            <param name="ref">input image to use as the source for comparison</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityGMSD.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            static method for computing quality
            </summary>
            <param name="ref"></param>
            <param name="cmp"></param>
            <param name="qualityMap">output quality map, or null</param>
            <returns>cv::Scalar with per-channel quality values.  Values range from 0 (worst) to 1 (best)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityGMSD.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Quality.QualityMSE">
            <summary>
            Full reference mean square error algorithm  https://en.wikipedia.org/wiki/Mean_squared_error
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityMSE.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityMSE.Create(ST4IVisionCoreNet.InputArray)">
            <summary>
            Create an object which calculates quality
            </summary>
            <param name="ref">input image to use as the source for comparison</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityMSE.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            static method for computing quality
            </summary>
            <param name="ref"></param>
            <param name="cmp"></param>
            <param name="qualityMap">output quality map, or null</param>
            <returns>cv::Scalar with per-channel quality values.  Values range from 0 (worst) to 1 (best)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityMSE.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Quality.QualityPSNR">
            <summary>
            Full reference peak signal to noise ratio (PSNR) algorithm  https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityPSNR.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Quality.QualityPSNR.MaxPixelValue">
            <summary>
            get or set the maximum pixel value used for PSNR computation
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityPSNR.Create(ST4IVisionCoreNet.InputArray,System.Double)">
            <summary>
            Create an object which calculates quality
            </summary>
            <param name="ref">input image to use as the source for comparison</param>
            <param name="maxPixelValue">maximum per-channel value for any individual pixel; eg 255 for uint8 image</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityPSNR.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double)">
            <summary>
            static method for computing quality
            </summary>
            <param name="ref"></param>
            <param name="cmp"></param>
            <param name="qualityMap">output quality map, or null</param>
            <param name="maxPixelValue">maximum per-channel value for any individual pixel; eg 255 for uint8 image</param>
            <returns>PSNR value, or double.PositiveInfinity if the MSE between the two images == 0</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualityPSNR.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Quality.QualitySSIM">
            <summary>
            Full reference structural similarity algorithm  https://en.wikipedia.org/wiki/Structural_similarity
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualitySSIM.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualitySSIM.Create(ST4IVisionCoreNet.InputArray)">
            <summary>
            Create an object which calculates quality
            </summary>
            <param name="ref">input image to use as the source for comparison</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualitySSIM.Compute(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            static method for computing quality
            </summary>
            <param name="ref"></param>
            <param name="cmp"></param>
            <param name="qualityMap">output quality map, or null</param>
            <returns>cv::Scalar with per-channel quality values.  Values range from 0 (worst) to 1 (best)</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Quality.QualitySSIM.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.HausdorffDistanceExtractor">
            <summary>
            A simple Hausdorff distance measure between shapes defined by contours
            </summary>
            <remarks>
            according to the paper "Comparing Images using the Hausdorff distance." 
            by D.P. Huttenlocher, G.A. Klanderman, and W.J. Rucklidge. (PAMI 1993). :
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.HausdorffDistanceExtractor.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.HausdorffDistanceExtractor.Create(ST4IVisionCoreNet.DistanceTypes,System.Single)">
            <summary>
            Complete constructor
            </summary>
            <param name="distanceFlag">Flag indicating which norm is used to compute the Hausdorff distance (NORM_L1, NORM_L2).</param>
            <param name="rankProp">fractional value (between 0 and 1).</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.HausdorffDistanceExtractor.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HausdorffDistanceExtractor.DistanceFlag">
            <summary>
            Flag indicating which norm is used to compute the Hausdorff distance (NORM_L1, NORM_L2).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.HausdorffDistanceExtractor.RankProportion">
            <summary>
            fractional value (between 0 and 1).
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.ShapeContextDistanceExtractor">
            <summary>
            Implementation of the Shape Context descriptor and matching algorithm
            </summary>
            <remarks>
            proposed by Belongie et al. in "Shape Matching and Object Recognition Using Shape Contexts" 
            (PAMI2002). This implementation is packaged in a generic scheme, in order to allow 
            you the implementation of the common variations of the original pipeline.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.ShapeContextDistanceExtractor.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ShapeContextDistanceExtractor.Create(System.Int32,System.Int32,System.Single,System.Single,System.Int32)">
            <summary>
            Complete constructor
            </summary>
            <param name="nAngularBins">The number of angular bins in the shape context descriptor.</param>
            <param name="nRadialBins">The number of radial bins in the shape context descriptor.</param>
            <param name="innerRadius">The value of the inner radius.</param>
            <param name="outerRadius">The value of the outer radius.</param>
            <param name="iterations"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.ShapeContextDistanceExtractor.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.AngularBins">
            <summary>
            The number of angular bins in the shape context descriptor.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.RadialBins">
            <summary>
            The number of radial bins in the shape context descriptor.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.InnerRadius">
            <summary>
            The value of the inner radius.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.OuterRadius">
            <summary>
            The value of the outer radius.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.RotationInvariant">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.ShapeContextWeight">
            <summary>
            The weight of the shape context distance in the final distance value.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.ImageAppearanceWeight">
            <summary>
            The weight of the appearance cost in the final distance value.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.BendingEnergyWeight">
            <summary>
            The weight of the Bending Energy in the final distance value.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.Iterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.ShapeContextDistanceExtractor.StdDev">
            <summary>
            The value of the standard deviation for the Gaussian window for the image appearance cost.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ShapeContextDistanceExtractor.SetImages(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Set the images that correspond to each shape. 
            This images are used in the calculation of the Image Appearance cost.
            </summary>
            <param name="image1">Image corresponding to the shape defined by contours1.</param>
            <param name="image2">Image corresponding to the shape defined by contours2.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.ShapeContextDistanceExtractor.GetImages(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Get the images that correspond to each shape. 
            This images are used in the calculation of the Image Appearance cost.
            </summary>
            <param name="image1">Image corresponding to the shape defined by contours1.</param>
            <param name="image2">Image corresponding to the shape defined by contours2.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.ShapeDistanceExtractor">
            <summary>
            Abstract base class for shape distance algorithms.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.ShapeDistanceExtractor.ComputeDistance(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Compute the shape distance between two shapes defined by its contours.
            </summary>
            <param name="contour1">Contour defining first shape.</param>
            <param name="contour2">Contour defining second shape.</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Detail.AffineBestOf2NearestMatcher">
             <summary>
             Features matcher similar to cv::detail::BestOf2NearestMatcher which
             finds two best matches for each feature and leaves the best one only if the
             ratio between descriptor distances is greater than the threshold match_conf.
            
             Unlike cv::detail::BestOf2NearestMatcher this matcher uses affine
             transformation (affine transformation estimate will be placed in matches_info).
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.AffineBestOf2NearestMatcher.#ctor(System.Boolean,System.Boolean,System.Single,System.Int32)">
            <summary>
            Constructs a "best of 2 nearest" matcher that expects affine transformation between images
            </summary>
            <param name="fullAffine">whether to use full affine transformation with 6 degress of freedom
            or reduced transformation with 4 degrees of freedom using only rotation, translation and
            uniform scaling</param>
            <param name="tryUseGpu">Should try to use GPU or not</param>
            <param name="matchConf">Match distances ration threshold</param>
            <param name="numMatchesThresh1">Minimum number of matches required for the 2D affine transform
            estimation used in the inliers classification step</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.AffineBestOf2NearestMatcher.DisposeUnmanaged">
            <summary>
            releases unmanaged resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Detail.BestOf2NearestMatcher">
            <summary>
            Features matcher which finds two best matches for each feature and leaves the best one only if the
            ratio between descriptor distances is greater than the threshold match_conf
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.BestOf2NearestMatcher.#ctor(System.Boolean,System.Single,System.Int32,System.Int32)">
            <summary>
            Constructs a "best of 2 nearest" matcher.
            </summary>
            <param name="tryUseGpu">Should try to use GPU or not</param>
            <param name="matchConf">Match distances ration threshold</param>
            <param name="numMatchesThresh1">Minimum number of matches required for the 2D projective transform
            estimation used in the inliers classification step</param>
            <param name="numMatchesThresh2">Minimum number of matches required for the 2D projective transform
            re-estimation on inliers</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.BestOf2NearestMatcher.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.BestOf2NearestMatcher.DisposeUnmanaged">
            <summary>
            releases unmanaged resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.BestOf2NearestMatcher.CollectGarbage">
            <summary>
            Frees unused memory allocated before if there is any.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Detail.CvDetail">
            <summary>
            cv::detail functions
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.CvDetail.ComputeImageFeatures(ST4IVisionCoreNet.Feature2D,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat})">
            <summary>
            
            </summary>
            <param name="featuresFinder"></param>
            <param name="images"></param>
            <param name="masks"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.CvDetail.ComputeImageFeatures(ST4IVisionCoreNet.Feature2D,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            
            </summary>
            <param name="featuresFinder"></param>
            <param name="image"></param>
            <param name="mask"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Detail.FeaturesMatcher">
            <summary>
            Feature matchers base class.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.FeaturesMatcher.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.FeaturesMatcher.Apply(ST4IVisionCoreNet.Detail.ImageFeatures,ST4IVisionCoreNet.Detail.ImageFeatures)">
            <summary>
            Performs images matching.
            </summary>
            <param name="features1">First image features</param>
            <param name="features2">Second image features</param>
            <returns>Found matches</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.FeaturesMatcher.Apply(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Detail.ImageFeatures},ST4IVisionCoreNet.Mat)">
            <summary>
            Performs images matching.
            </summary>
            <param name="features">Features of the source images</param>
            <param name="mask">Mask indicating which image pairs must be matched</param>
            <returns>Found pairwise matches</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.FeaturesMatcher.IsThreadSafe">
            <summary>
            True, if it's possible to use the same matcher instance in parallel, false otherwise
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.FeaturesMatcher.CollectGarbage">
            <summary>
            Frees unused memory allocated before if there is any.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Detail.ImageFeatures">
            <summary>
            Structure containing image keypoints and descriptors.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.ImageFeatures.#ctor(System.Int32,ST4IVisionCoreNet.Size,System.Collections.Generic.IReadOnlyList{ST4IVisionCoreNet.KeyPoint},ST4IVisionCoreNet.Mat)">
            <summary>
            Constructor
            </summary>
            <param name="imgIdx"></param>
            <param name="imgSize"></param>
            <param name="keypoints"></param>
            <param name="descriptors"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.ImageFeatures.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.ImageFeatures.Dispose(System.Boolean)">
            <summary> 
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.ImageFeatures.Dispose">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.Detail.MatchesInfo">
             <summary>
             Structure containing information about matches between two images.
            
             It's assumed that there is a transformation between those images. Transformation may be 
             homography or affine transformation based on selected matcher.
             </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Detail.MatchesInfo.SrcImgIdx">
            <summary>
            Images indices (optional)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Detail.MatchesInfo.DstImgIdx">
            <summary>
            Images indices (optional)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Detail.MatchesInfo.Matches">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Detail.MatchesInfo.InliersMask">
            <summary>
            Geometrically consistent matches mask
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Detail.MatchesInfo.NumInliers">
            <summary>
            Number of geometrically consistent matches
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Detail.MatchesInfo.H">
            <summary>
            Estimated transformation
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.Detail.MatchesInfo.Confidence">
            <summary>
            Confidence two images are from the same panorama
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.MatchesInfo.#ctor(System.Int32,System.Int32,System.Collections.Generic.IReadOnlyList{ST4IVisionCoreNet.DMatch},System.Collections.Generic.IReadOnlyList{System.Byte},System.Int32,ST4IVisionCoreNet.Mat,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="srcImgIdx"></param>
            <param name="dstImgIdx"></param>
            <param name="matches"></param>
            <param name="inliersMask"></param>
            <param name="numInliers"></param>
            <param name="h"></param>
            <param name="confidence"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.MatchesInfo.#ctor(ST4IVisionCoreNet.Detail.MatchesInfo)">
            <summary>
            Copy constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Detail.MatchesInfo.Dispose">
            <summary>
            Dispose H
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Stitcher">
            <summary>
            High level image stitcher. 
            It's possible to use this class without being aware of the entire stitching 
            pipeline. However, to be able to achieve higher stitching stability and 
            quality of the final images at least being familiar with the theory is recommended
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Stitcher.Status">
            <summary>
            Status code
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Stitcher.Mode.Panorama">
            <summary>
            Mode for creating photo panoramas. Expects images under perspective
            transformation and projects resulting pano to sphere.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Stitcher.Mode.Scans">
            <summary>
            Mode for composing scans. Expects images under affine transformation does
            not compensate exposure by default.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Stitcher.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="p">cv::Stitcher*</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Stitcher.Create(ST4IVisionCoreNet.Stitcher.Mode)">
            <summary>
            Creates a Stitcher configured in one of the stitching modes.
            </summary>
            <param name="mode">Scenario for stitcher operation. This is usually determined by source of images
            to stitch and their transformation.Default parameters will be chosen for operation in given scenario.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Stitcher.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Stitcher.Stitch(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Try to stitch the given images.
            </summary>
            <param name="images">Input images.</param>
            <param name="pano">Final pano.</param>
            <returns>Status code.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Stitcher.Stitch(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.OutputArray)">
            <summary>
            Try to stitch the given images.
            </summary>
            <param name="images">Input images.</param>
            <param name="pano">Final pano.</param>
            <returns>Status code.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Stitcher.Stitch(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Rect[][],ST4IVisionCoreNet.OutputArray)">
            <summary>
            Try to stitch the given images.
            </summary>
            <param name="images">Input images.</param>
            <param name="rois">Region of interest rectangles.</param>
            <param name="pano">Final pano.</param>
            <returns>Status code.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Stitcher.Stitch(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Mat},ST4IVisionCoreNet.Rect[][],ST4IVisionCoreNet.OutputArray)">
            <summary>
            Try to stitch the given images.
            </summary>
            <param name="images">Input images.</param>
            <param name="rois">Region of interest rectangles.</param>
            <param name="pano">Final pano.</param>
            <returns>Status code.</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.BroxOpticalFlow">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BroxOpticalFlow.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BroxOpticalFlow.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BroxOpticalFlow.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.BroxOpticalFlow.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BroxOpticalFlow.Alpha">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BroxOpticalFlow.Gamma">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BroxOpticalFlow.ScaleFactor">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BroxOpticalFlow.InnerIterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BroxOpticalFlow.OuterIterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BroxOpticalFlow.SolverIterations">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.DenseOpticalFlowExt">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DenseOpticalFlowExt.CreateFarneback">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DenseOpticalFlowExt.CreateFarneback_CUDA">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DenseOpticalFlowExt.CreateDualTVL1">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DenseOpticalFlowExt.CreateDualTVL1_CUDA">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DenseOpticalFlowExt.CreateBrox_CUDA">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DenseOpticalFlowExt.CreatePyrLK_CUDA">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.DenseOpticalFlowExt.CollectGarbage">
            <summary>
            Clear all inner buffers.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DenseOpticalFlowExt.Calc(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            
            </summary>
            <param name="frame0"></param>
            <param name="frame1"></param>
            <param name="flow1"></param>
            <param name="flow2"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.DualTVL1OpticalFlow">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.DualTVL1OpticalFlow.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DualTVL1OpticalFlow.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.DualTVL1OpticalFlow.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.DualTVL1OpticalFlow.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DualTVL1OpticalFlow.Tau">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DualTVL1OpticalFlow.Lambda">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DualTVL1OpticalFlow.Theta">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DualTVL1OpticalFlow.ScalesNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DualTVL1OpticalFlow.WarpingsNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DualTVL1OpticalFlow.Epsilon">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DualTVL1OpticalFlow.Iterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.DualTVL1OpticalFlow.UseInitialFlow">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FarnebackOpticalFlow">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FarnebackOpticalFlow.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FarnebackOpticalFlow.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FarnebackOpticalFlow.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FarnebackOpticalFlow.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FarnebackOpticalFlow.PyrScale">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FarnebackOpticalFlow.LevelsNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FarnebackOpticalFlow.WindowSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FarnebackOpticalFlow.Iterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FarnebackOpticalFlow.PolyN">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FarnebackOpticalFlow.PolySigma">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.FarnebackOpticalFlow.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FrameSource">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FrameSource.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FrameSource.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FrameSource.CreateFrameSource_Empty">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FrameSource.CreateFrameSource_Video(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FrameSource.CreateFrameSource_Video_CUDA(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FrameSource.CreateFrameSource_Camera(System.Int32)">
            <summary>
            
            </summary>
            <param name="deviceId"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FrameSource.NextFrame(ST4IVisionCoreNet.OutputArray)">
            <summary>
            
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FrameSource.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.PyrLKOpticalFlow">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.PyrLKOpticalFlow.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.PyrLKOpticalFlow.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.PyrLKOpticalFlow.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.PyrLKOpticalFlow.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.PyrLKOpticalFlow.WindowSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.PyrLKOpticalFlow.MaxLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.PyrLKOpticalFlow.Iterations">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.SuperResolution">
            <summary>
            Base class for Super Resolution algorithms.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.DisposeManaged">
            <inheritdoc />
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.CreateBTVL1">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.CreateBTVL1_CUDA">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.SetInput(ST4IVisionCoreNet.FrameSource)">
            <summary>
            Set input frame source for Super Resolution algorithm.
            </summary>
            <param name="fs">Input frame source</param>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.NextFrame(ST4IVisionCoreNet.OutputArray)">
            <summary>
            Process next frame from input and return output result.
            </summary>
            <param name="frame">Output result</param>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.Reset">
            <summary>
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.CollectGarbage">
            <summary>
            Clear all inner buffers.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.InitImpl(ST4IVisionCoreNet.FrameSource)">
            <summary>
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.SuperResolution.ProcessImpl(ST4IVisionCoreNet.FrameSource,ST4IVisionCoreNet.OutputArray)">
            <summary>
            </summary>
            <param name="fs"></param>
            <param name="output"></param>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.Scale">
            <summary>
            Scale factor
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.Iterations">
            <summary>
            Iterations count
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.Tau">
            <summary>
            Asymptotic value of steepest descent method
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.Lambda">
            <summary>
            Weight parameter to balance data term and smoothness term
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.Alpha">
            <summary>
            Parameter of spacial distribution in Bilateral-TV
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.KernelSize">
            <summary>
            Kernel size of Bilateral-TV filter
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.BlurKernelSize">
            <summary>
            Gaussian blur kernel size
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.BlurSigma">
            <summary>
            Gaussian blur sigma
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.SuperResolution.TemporalAreaRadius">
            <summary>
            Radius of the temporal search area
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Text.BaseOCR">
            <summary>
            base class BaseOCR declares a common API that would be used in a typical text recognition scenario
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.BaseOCR.Run(ST4IVisionCoreNet.Mat,System.String@,ST4IVisionCoreNet.Rect[]@,System.String[]@,System.Single[]@,ST4IVisionCoreNet.Text.ComponentLevels)">
            <summary>
            
            </summary>
            <param name="image"></param>
            <param name="outputText"></param>
            <param name="componentRects"></param>
            <param name="componentTexts"></param>
            <param name="componentConfidences"></param>
            <param name="componentLevel"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.BaseOCR.Run(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.String@,ST4IVisionCoreNet.Rect[]@,System.String[]@,System.Single[]@,ST4IVisionCoreNet.Text.ComponentLevels)">
            <summary>
            
            </summary>
            <param name="image"></param>
            <param name="mask"></param>
            <param name="outputText"></param>
            <param name="componentRects"></param>
            <param name="componentTexts"></param>
            <param name="componentConfidences"></param>
            <param name="componentLevel"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Text.ComponentLevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Text.ComponentLevels.Word">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Text.ComponentLevels.TextLine">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Text.CvText">
            <summary>
            cv::text functions
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.CvText.DetectTextSWT(ST4IVisionCoreNet.InputArray,System.Boolean,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies the Stroke Width Transform operator followed by filtering of connected components of similar Stroke Widths to
            return letter candidates. It also chain them by proximity and size, saving the result in chainBBs.
            </summary>
            <param name="input">input the input image with 3 channels.</param>
            <param name="darkOnLight">a boolean value signifying whether the text is darker or lighter than the background,
            it is observed to reverse the gradient obtained from Scharr operator, and significantly affect the result.</param>
            <param name="draw">an optional Mat of type CV_8UC3 which visualises the detected letters using bounding boxes.</param>
            <param name="chainBBs">an optional parameter which chains the letter candidates according to heuristics in the
            paper and returns all possible regions where text is likely to occur.</param>
            <returns>a vector of resulting bounding boxes where probability of finding text is high</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Text.OCRTesseract">
            <summary>
            Recognize text using the tesseract-ocr API.
            
            Takes image on input and returns recognized text in the output_text parameter.
            Optionallyprovides also the Rects for individual text elements found(e.g.words), 
            and the list of those text elements with their confidence values.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.OCRTesseract.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.OCRTesseract.Create(System.String,System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Creates an instance of the OCRTesseract class. Initializes Tesseract.
            </summary>
            <param name="datapath">datapath the name of the parent directory of tessdata ended with "/", or null to use the system's default directory.</param>
            <param name="language">an ISO 639-3 code or NULL will default to "eng".</param>
            <param name="charWhitelist">specifies the list of characters used for recognition. 
            null defaults to "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".</param>
            <param name="oem">tesseract-ocr offers different OCR Engine Modes (OEM), 
            by deffault tesseract::OEM_DEFAULT is used.See the tesseract-ocr API documentation for other possible values.</param>
            <param name="psmode">tesseract-ocr offers different Page Segmentation Modes (PSM) tesseract::PSM_AUTO (fully automatic layout analysis) is used.
            See the tesseract-ocr API documentation for other possible values.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.OCRTesseract.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.OCRTesseract.Run(ST4IVisionCoreNet.Mat,System.String@,ST4IVisionCoreNet.Rect[]@,System.String[]@,System.Single[]@,ST4IVisionCoreNet.Text.ComponentLevels)">
            <summary>
            Recognize text using the tesseract-ocr API.
            Takes image on input and returns recognized text in the output_text parameter.
            Optionally provides also the Rects for individual text elements found(e.g.words), 
            and the list of those text elements with their confidence values.
            </summary>
            <param name="image">Input image CV_8UC1 or CV_8UC3</param>
            <param name="outputText">Output text of the tesseract-ocr.</param>
            <param name="componentRects">If provided the method will output a list of Rects for the individual 
            text elements found(e.g.words or text lines).</param>
            <param name="componentTexts">If provided the method will output a list of text strings for the 
            recognition of individual text elements found(e.g.words or text lines).</param>
            <param name="componentConfidences">If provided the method will output a list of confidence values 
            for the recognition of individual text elements found(e.g.words or text lines).</param>
            <param name="componentLevel">OCR_LEVEL_WORD (by default), or OCR_LEVEL_TEXT_LINE.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.OCRTesseract.Run(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.String@,ST4IVisionCoreNet.Rect[]@,System.String[]@,System.Single[]@,ST4IVisionCoreNet.Text.ComponentLevels)">
            <summary>
            Recognize text using the tesseract-ocr API.
            Takes image on input and returns recognized text in the output_text parameter.
            Optionally provides also the Rects for individual text elements found(e.g.words), 
            and the list of those text elements with their confidence values.
            </summary>
            <param name="image">Input image CV_8UC1 or CV_8UC3</param>
            <param name="mask"></param>
            <param name="outputText">Output text of the tesseract-ocr.</param>
            <param name="componentRects">If provided the method will output a list of Rects for the individual 
            text elements found(e.g.words or text lines).</param>
            <param name="componentTexts">If provided the method will output a list of text strings for the 
            recognition of individual text elements found(e.g.words or text lines).</param>
            <param name="componentConfidences">If provided the method will output a list of confidence values 
            for the recognition of individual text elements found(e.g.words or text lines).</param>
            <param name="componentLevel">OCR_LEVEL_WORD (by default), or OCR_LEVEL_TEXT_LINE.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.Text.OCRTesseract.SetWhiteList(System.String)">
            <summary>
            
            </summary>
            <param name="charWhitelist"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.TextDetector">
            <summary>
            An abstract class providing interface for text detection algorithms
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TextDetector.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Rect[]@,System.Single[]@)">
            <summary>
            Method that provides a quick and simple interface to detect text inside an image
            </summary>
            <param name="inputImage">an image to process</param>
            <param name="bbox"> a vector of Rect that will store the detected word bounding box</param>
            <param name="confidence">a vector of float that will be updated with the confidence the classifier has for the selected bounding box</param>
        </member>
        <member name="T:ST4IVisionCoreNet.TextDetectorCNN">
            <summary>
            TextDetectorCNN class provides the functionality of text bounding box detection.
            </summary>
            <remarks>
            This class is representing to find bounding boxes of text words given an input image.
            This class uses OpenCV dnn module to load pre-trained model described in @cite LiaoSBWL17.
            The original repository with the modified SSD Caffe version: https://github.com/MhLiao/TextBoxes.
            Model can be downloaded from[DropBox](https://www.dropbox.com/s/g8pjzv2de9gty8g/TextBoxes_icdar13.caffemodel?dl=0).
            Modified.prototxt file with the model description can be found in `opencv_contrib/modules/text/samples/textbox.prototxt`.
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.TextDetectorCNN.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TextDetectorCNN.Create(System.String,System.String,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Size})">
            <summary>
            Creates an instance of the TextDetectorCNN class using the provided parameters.
            </summary>
            <param name="modelArchFilename">the relative or absolute path to the prototxt file describing the classifiers architecture.</param>
            <param name="modelWeightsFilename">the relative or absolute path to the file containing the pretrained weights of the model in caffe-binary form.</param>
            <param name="detectionSizes">a list of sizes for multiscale detection. The values`[(300,300),(700,500),(700,300),(700,700),(1600,1600)]`
            are recommended in @cite LiaoSBWL17 to achieve the best quality.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.TextDetectorCNN.Create(System.String,System.String)">
            <summary>
            Creates an instance of the TextDetectorCNN class using the provided parameters.
            </summary>
            <param name="modelArchFilename">the relative or absolute path to the prototxt file describing the classifiers architecture.</param>
            <param name="modelWeightsFilename">the relative or absolute path to the file containing the pretrained weights of the model in caffe-binary form.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.TextDetectorCNN.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TextDetectorCNN.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Rect[]@,System.Single[]@)">
            <summary>
            Method that provides a quick and simple interface to detect text inside an image
            </summary>
            <param name="inputImage">an image to process</param>
            <param name="bbox"> a vector of Rect that will store the detected word bounding box</param>
            <param name="confidence">a vector of float that will be updated with the confidence the classifier has for the selected bounding box</param>
        </member>
        <member name="T:ST4IVisionCoreNet.Tracking.TrackerCSRT">
            <inheritdoc />
            <summary>
            the CSRT tracker
            The implementation is based on @cite Lukezic_IJCV2018 Discriminative Correlation Filter with Channel and Spatial Reliability
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracking.TrackerCSRT.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracking.TrackerCSRT.Create">
            <summary>
            Constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracking.TrackerCSRT.Create(ST4IVisionCoreNet.Tracking.TrackerCSRT.Params)">
            <summary>
            Constructor
            </summary>
            <param name="parameters">CSRT parameters</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracking.TrackerCSRT.SetInitialMask(ST4IVisionCoreNet.InputArray)">
            <summary>
            
            </summary>
            <param name="mask"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.Tracking.TrackerCSRT.Params">
            <summary>
            CSRT Params
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerCSRT.Params.WindowFunction">
            <summary>
            Window function: "hann", "cheb", "kaiser"
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerCSRT.Params.PsrThreshold">
            <summary>
            we lost the target, if the psr is lower than this.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.Tracking.TrackerKCF">
            <inheritdoc />
            <summary>
            KCF is a novel tracking framework that utilizes properties of circulant matrix to enhance the processing speed.
            * This tracking method is an implementation of @cite KCF_ECCV which is extended to KFC with color-names features(@cite KCF_CN).
            * The original paper of KCF is available at [http://www.robots.ox.ac.uk/~joao/publications/henriques_tpami2015.pdf]
            * as well as the matlab implementation.For more information about KCF with color-names features, please refer to
            * [http://www.cvl.isy.liu.se/research/objrec/visualtracking/colvistrack/index.html].
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracking.TrackerKCF.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracking.TrackerKCF.Create">
            <summary>
            Constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracking.TrackerKCF.Create(ST4IVisionCoreNet.Tracking.TrackerKCF.Params)">
            <summary>
            Constructor
            </summary>
            <param name="parameters">KCF parameters TrackerKCF::Params</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Tracking.TrackerKCF.Params">
            <summary> 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.DetectThresh">
            <summary>
            detection confidence threshold
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.Sigma">
            <summary>
            gaussian kernel bandwidth
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.Lambda">
            <summary>
            regularization
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.InterpFactor">
            <summary>
            linear interpolation factor for adaptation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.OutputSigmaFactor">
            <summary>
            spatial bandwidth (proportional to target)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.PcaLearningRate">
            <summary>
            compression learning rate
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.Resize">
            <summary>
            activate the resize feature to improve the processing speed
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.SplitCoeff">
            <summary>
            split the training coefficients into two matrices
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.WrapKernel">
            <summary>
            wrap around the kernel values
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.CompressFeature">
            <summary>
            activate the pca method to compress the features
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.MaxPatchSize">
            <summary>
            threshold for the ROI size
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.CompressedSize">
            <summary>
            feature size after compression
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.DescPca">
            <summary>
            compressed descriptors of TrackerKCF::MODE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.Tracking.TrackerKCF.Params.DescNpca">
            <summary>
            non-compressed descriptors of TrackerKCF::MODE
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CameraChannels">
            <summary>
            channel indices for multi-head camera live streams
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CameraChannels.OpenNI_DepthMap">
            <summary>
            Depth values in mm (CV_16UC1)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CameraChannels.OpenNI_PointCloudMap">
            <summary>
            XYZ in meters (CV_32FC3)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CameraChannels.OpenNI_DisparityMap">
            <summary>
            Disparity in pixels (CV_8UC1)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CameraChannels.OpenNI_DisparityMap32F">
            <summary>
            Disparity in pixels (CV_32FC1)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CameraChannels.OpenNI_ValidDepthMask">
            <summary>
            CV_8UC1
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CapturePosAviRatio">
            <summary>
            Position in relative units
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CapturePosAviRatio.Start">
            <summary>
            Start of the file
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CapturePosAviRatio.End">
            <summary>
            End of the file
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.CaptureType">
            <summary>
            Capture type of CvCapture (Camera or AVI file)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CaptureType.File">
            <summary>
            Captures from an AVI file
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CaptureType.Camera">
            <summary>
            Captures from digital camera
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.CaptureType.NotSpecified">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoAccelerationType">
            <summary>
            Video Acceleration type
            Used as value in #CAP_PROP_HW_ACCELERATION and #VIDEOWRITER_PROP_HW_ACCELERATION
            note In case of FFmpeg backend, it translated to enum AVHWDeviceType (https://github.com/FFmpeg/FFmpeg/blob/master/libavutil/hwcontext.h)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoAccelerationType.None">
            <summary>
            Do not require any specific H/W acceleration, prefer software processing.
            Reading of this value means that special H/W accelerated handling is not added or not detected by OpenCV.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoAccelerationType.Any">
            <summary>
            Prefer to use H/W acceleration. If no one supported, then fallback to software processing.
            note H/W acceleration may require special configuration of used environment.
            note Results in encoding scenario may differ between software and hardware accelerated encoders.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoAccelerationType.D3D11">
            <summary>
            DirectX 11
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoAccelerationType.VAAPI">
            <summary>
            VAAPI
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoAccelerationType.MFX">
            <summary>
            libmfx (Intel MediaSDK/oneVPL)
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoCaptureAPIs">
            <summary>
            Camera device types
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/videoio/include/opencv2/videoio.hpp#L89
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.ANY">
            <summary>
            Auto detect == 0
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.V4L">
            <summary>
            V4L/V4L2 capturing support
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.V4L2">
            <summary>
            Same as CAP_V4L
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.FIREWIRE">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.FIREWARE">
            <summary>
            Same value as CAP_FIREWIRE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.IEEE1394">
            <summary>
            Same value as CAP_FIREWIRE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.DC1394">
            <summary>
            Same value as CAP_FIREWIRE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.CMU1394">
            <summary>
            Same value as CAP_FIREWIRE
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.DSHOW">
            <summary>
            DirectShow (via videoInput)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.PVAPI">
            <summary>
            PvAPI, Prosilica GigE SDK
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.OPENNI">
            <summary>
            OpenNI (for Kinect)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.OPENNI_ASUS">
            <summary>
            OpenNI (for Asus Xtion)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.ANDROID">
            <summary>
            Android - not used
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.XIAPI">
            <summary>
            XIMEA Camera API
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.AVFOUNDATION">
            <summary>
            AVFoundation framework for iOS (OS X Lion will have the same API)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.GIGANETIX">
            <summary>
            Smartek Giganetix GigEVisionSDK
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.MSMF">
            <summary>
            Microsoft Media Foundation (via videoInput)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.WINRT">
            <summary>
            Microsoft Windows Runtime using Media Foundation
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.INTELPERC">
            <summary>
            RealSense (former Intel Perceptual Computing SDK)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.REALSENSE">
            <summary>
            Synonym for CAP_INTELPERC
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.OPENNI2">
            <summary>
            OpenNI2 (for Kinect)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.OPENNI2_ASUS">
            <summary>
            OpenNI2 (for Asus Xtion and Occipital Structure sensors)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.GPHOTO2">
            <summary>
            gPhoto2 connection
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.GSTREAMER">
            <summary>
            GStreamer
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.FFMPEG">
            <summary>
            Open and record video file or stream using the FFMPEG library
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.IMAGES">
            <summary>
            OpenCV Image Sequence (e.g. img_%02d.jpg)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.ARAVIS">
            <summary>
            Aravis SDK
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.OPENCV_MJPEG">
            <summary>
            Built-in OpenCV MotionJPEG codec
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.INTEL_MFX">
            <summary>
            Intel MediaSDK
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.XINE">
            <summary>
            XINE engine (Linux)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureAPIs.CAP_UEYE">
            <summary>
            uEye Camera API
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoCapturePara">
            <summary>
            Parameters of VideoCature for hardware acceleration
            Please check the link below for current HW acceleration types support matrix
            https://github.com/opencv/opencv/wiki/Video-IO-hardware-acceleration
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapturePara.AccelerationType">
            <summary>
            Used as value in #CAP_PROP_HW_ACCELERATION and #VIDEOWRITER_PROP_HW_ACCELERATION
            note In case of FFmpeg backend, it translated to enum AVHWDeviceType (https://github.com/FFmpeg/FFmpeg/blob/master/libavutil/hwcontext.h)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapturePara.HwDeviceIndex">
            <summary>
            Hardware device index (select GPU if multiple available). Device enumeration is acceleration type specific.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapturePara.#ctor">
            <summary>
            Constructor, parameter of VideoCature for hardware acceleration
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapturePara.#ctor(ST4IVisionCoreNet.VideoAccelerationType,System.Int32)">
            <summary>
            Constructor, parameter of VideoCature for hardware acceleration
            </summary>
            <param name="videoAcceleration">Video Acceleration type</param>
            <param name="deviceIndex">Hardware device index </param>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapturePara.GetParameters">
            <summary>
            Get parameters of VideoCature for hardware acceleration
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoCaptureProperties">
            <summary>
            Property identifiers for CvCapture
            </summary>
            <remarks>
            https://github.com/opencv/opencv/blob/d3bc563c6e01c2bc153f23e7393322a95c7d3974/modules/videoio/include/opencv2/videoio.hpp#L133
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PosMsec">
            <summary>
            Position in milliseconds from the file beginning
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PosFrames">
            <summary>
            Position in frames (only for video files)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PosAviRatio">
            <summary>
            Position in relative units (0 - start of the file, 1 - end of the file)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.FrameWidth">
            <summary>
            Width of frames in the video stream (only for cameras)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.FrameHeight">
            <summary>
            Height of frames in the video stream (only for cameras)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Fps">
            <summary>
            Frame rate (only for cameras)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.FourCC">
            <summary>
            4-character code of codec (only for cameras). 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.FrameCount">
            <summary>
            Number of frames in the video stream
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Format">
            <summary>
            The format of the Mat objects returned by retrieve()
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Mode">
            <summary>
            A backend-specific value indicating the current capture mode
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Brightness">
            <summary>
            Brightness of image (only for cameras) 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Contrast">
            <summary>
            contrast of image (only for cameras) 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Saturation">
            <summary>
            Saturation of image (only for cameras) 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Hue">
            <summary>
            hue of image (only for cameras) 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Gain">
            <summary>
            Gain of the image (only for cameras)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Exposure">
            <summary>
            Exposure (only for cameras)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.ConvertRgb">
            <summary>
            Boolean flags indicating whether images should be converted to RGB
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.WhiteBalanceBlueU">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Rectification">
            <summary>
            TOWRITE (note: only supported by DC1394 v 2.x backend currently)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Monocrome">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Sharpness">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.AutoExposure">
            <summary>
            exposure control done by camera,
            user can adjust refernce level using this feature
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Gamma">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Temperature">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Trigger">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.TriggerDelay">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.WhiteBalanceRedV">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Zoom">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Focus">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Guid">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.IsoSpeed">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.BackLight">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Pan">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Tilt">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Roll">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Iris">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Settings">
            <summary>
            Pop up video/camera filter dialog (note: only supported by DSHOW backend currently. Property value is ignored)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.BufferSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.AutoFocus">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.SARNum">
            <summary>
            Sample aspect ratio: num/den (num)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.SARDen">
            <summary>
            Sample aspect ratio: num/den (den)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Backend">
            <summary>
            Current backend (enum VideoCaptureAPIs). Read-only property
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Channel">
            <summary>
            Video input or Channel Number (only for those cameras that support)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.AutoWB">
            <summary>
            enable/ disable auto white-balance
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.WBTemperature">
            <summary>
            white-balance color temperature
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.CodecPixelFormat">
            <summary>
            (read-only) codec's pixel format. 4-character code - see VideoWriter::fourcc . Subset of [AV_PIX_FMT_*](https://github.com/FFmpeg/FFmpeg/blob/master/libavcodec/raw.c) or -1 if unknown
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.BitRate">
            <summary>
            (read-only) Video bitrate in kbits/s
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OrientationMeta">
            <summary>
            (read-only) Frame rotation defined by stream meta (applicable for FFmpeg back-end only)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OrientationAuto">
            <summary>
            if true - rotates output frames of CvCapture considering video file's metadata  (applicable for FFmpeg back-end only) (https://github.com/opencv/opencv/issues/15499)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.HwAcceleration">
            <summary>
            (open-only) Hardware acceleration type (see VideoAccelerationType). 
            Setting supported only via params parameter in cv::VideoCapture constructor / .open() method. 
            Default value is backend-specific.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.HwDevice">
            <summary>
            (open-only) Hardware device index (select GPU if multiple available). Device enumeration is acceleration type specific.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_OutputMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_FrameMaxDepth">
            <summary>
            in mm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_Baseline">
            <summary>
            in mm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_FocalLength">
            <summary>
            in pixels
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_Registration">
            <summary>
            flag that synchronizes the remapping depth map to image map
            by changing depth generator's view point (if the flag is "on") or
            sets this view point to its normal one (if the flag is "off").
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OPENNI_ApproxFrameSync">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OPENNI_MaxBufferSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OPENNI_CircleBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OPENNI_MaxTimeDuration">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OPENNI_GeneratorPresent">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OPENNI2_Sync">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OPENNI2_Mirror">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_DepthGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_ImageGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_ImageGeneratorPresent">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_ImageGeneratorOutputMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_DepthGeneratorBaseline">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_DepthGeneratorFocalLength">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.OpenNI_DepthGeneratorRegistrationON">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GStreamerQueueLength">
            <summary>
            default is 1
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PvAPIMulticastIP">
            <summary>
            ip for anable multicast master mode. 0 for disable multicast
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PVAPI_FrameStartTriggerMode">
            <summary>
            Determines how a frame is initiated
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PVAPI_DecimationHorizontal">
            <summary>
            Horizontal sub-sampling of the image
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PVAPI_DecimationVertical">
            <summary>
            Vertical sub-sampling of the image
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PVAPI_BinningX">
            <summary>
            Horizontal binning factor
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PVAPI_BinningY">
            <summary>
            Vertical binning factor
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.PVAPI_PixelFormat">
            <summary>
            Pixel format
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_Downsampling">
            <summary>
            Change image resolution by binning or skipping. 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_DataFormat">
            <summary>
            Output data format.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_OffsetX">
            <summary>
            Horizontal offset from the origin to the area of interest (in pixels).
            </summary>        
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_OffsetY">
            <summary>
            Vertical offset from the origin to the area of interest (in pixels).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_TrgSource">
            <summary>
            Defines source of trigger.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_TrgSoftware">
            <summary>
            Generates an internal trigger. PRM_TRG_SOURCE must be set to TRG_SOFTWARE.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_GpiSelector">
            <summary>
            Selects general purpose input 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_GpiMode">
            <summary>
            Set general purpose input mode
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_GpiLevel">
            <summary>
            Get general purpose level
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_GpoSelector">
            <summary>
            Selects general purpose output 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_GpoMode">
            <summary>
            Set general purpose output mode
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_LedSelector">
            <summary>
            Selects camera signalling LED 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_LedMode">
            <summary>
            Define camera signalling LED functionality
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_ManualWB">
            <summary>
            Calculates White Balance(must be called during acquisition)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_AutoWB">
            <summary>
            Automatic white balance
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_AEAG">
            <summary>
            Automatic exposure/gain
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_ExpPriority">
            <summary>
            Exposure priority (0.5 - exposure 50%, gain 50%).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_AEMaxLimit">
            <summary>
            Maximum limit of exposure in AEAG procedure
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_AGMaxLimit">
            <summary>
            Maximum limit of gain in AEAG procedure
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_AEAGLevel">
            <summary>
            Average intensity of output signal AEAG should achieve(in %)
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.XI_Timeout">
            <summary>
            Image capture timeout in milliseconds
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.IOS_DeviceFocus">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.IOS_DeviceExposure">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.IOS_DeviceFlash">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.IOS_DeviceWhiteBalance">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.IOS_DeviceTorch">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GIGA_FrameOffsetX">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GIGA_FrameOffsetY">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GIGA_FrameWidthMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GIGA_FrameHeightMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GIGA_FrameSensWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GIGA_FrameSensHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.INTELPERC_ProfileCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.INTELPERC_ProfileIdx">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.INTELPERC_DepthLowConfidenceValue">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.INTELPERC_DepthSaturationValue">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.INTELPERC_DepthConfidenceThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.INTELPERC_DepthFocalLengthHorz">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.INTELPERC_DepthFocalLengthVert">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GPhoto2_Preview">
            <summary>
            Capture only preview from liveview mode.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GPhoto2_WidgetEnumerate">
            <summary>
            Readonly, returns (const char *).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GPhoto2_ReloadConfig">
            <summary>
            Trigger, only by set. Reload camera settings.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GPhoto2_ReloadOnChange">
            <summary>
            Reload all settings on set.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GPhoto2_CollectMsgs">
            <summary>
            Collect messages with details.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.GPhoto2_FlushMsgs">
            <summary>
            Readonly, returns (const char *).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Speed">
            <summary>
            Exposure speed. Can be readonly, depends on camera program.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.Aperture">
            <summary>
            Aperture. Can be readonly, depends on camera program.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.ExposureProgram">
            <summary>
            Camera exposure program.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCaptureProperties.ViewFinder">
            <summary>
            Enter liveview mode.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoWriterPara">
            <summary>
            Parameters of VideoWriter for hardware acceleration
            Please check the link below for current HW acceleration types support matrix
            https://github.com/opencv/opencv/wiki/Video-IO-hardware-acceleration
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoWriterPara.AccelerationType">
            <summary>
            Used as value in #CAP_PROP_HW_ACCELERATION and #VIDEOWRITER_PROP_HW_ACCELERATION
            note In case of FFmpeg backend, it translated to enum AVHWDeviceType (https://github.com/FFmpeg/FFmpeg/blob/master/libavutil/hwcontext.h)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoWriterPara.HwDeviceIndex">
            <summary>
            Hardware device index (select GPU if multiple available). Device enumeration is acceleration type specific.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriterPara.#ctor">
            <summary>
            Constructor, parameter of VideoWriter for hardware acceleration
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriterPara.#ctor(ST4IVisionCoreNet.VideoAccelerationType,System.Int32)">
            <summary>
            Constructor, parameter of VideoWriter for hardware acceleration
            </summary>
            <param name="videoAcceleration">Video Acceleration type</param>
            <param name="deviceIndex">Hardware device index </param>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriterPara.GetParameters">
            <summary>
            Get parameters of VideoWriter for hardware acceleration
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoWriterProperties">
            <summary>
            VideoWriter generic properties identifier.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoWriterProperties.Quality">
            <summary>
            Current quality (0..100%) of the encoded video stream. Can be adjusted dynamically in some codecs.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoWriterProperties.FrameBytes">
            <summary>
            (Read-only): Size of just encoded video frame. Note that the encoding order may be different from representation order.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoWriterProperties.NStripes">
            <summary>
            Number of stripes for parallel encoding. -1 for auto detection.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoWriterProperties.IsColor">
            <summary>
            If it is not zero, the encoder will expect and encode color frames, otherwise it will work with grayscale frames.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoWriterProperties.Depth">
            <summary>
            Defaults to CV_8U.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoWriterProperties.HwAcceleration">
            <summary>
            (open-only) Hardware acceleration type (see VideoAccelerationType). 
            Setting supported only via params parameter in cv::VideoCapture constructor / .open() method. 
            Default value is backend-specific.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoWriterProperties.HwDevice">
            <summary>
            (open-only) Hardware device index (select GPU if multiple available). Device enumeration is acceleration type specific.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.FourCC">
            <summary>
            4-character code of codec used to compress the frames.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.FourCC.Value">
            <summary>
            int value
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.FromFourChars(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Create from four characters
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <param name="c3"></param>
            <param name="c4"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.FromString(System.String)">
            <summary>
            Create from string (length == 4)
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.op_Implicit(ST4IVisionCoreNet.FourCC)~System.Int32">
            <summary>
            implicit cast to int
            </summary>
            <param name="fourcc"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.ToInt32">
            <summary>
            cast to int
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.op_Implicit(System.Int32)~ST4IVisionCoreNet.FourCC">
            <summary>
            implicit cast from int
            </summary>
            <param name="code"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.FromInt32(System.Int32)">
            <summary>
            cast from int
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.Equals(ST4IVisionCoreNet.FourCC)">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.op_Equality(ST4IVisionCoreNet.FourCC,ST4IVisionCoreNet.FourCC)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.FourCC.op_Inequality(ST4IVisionCoreNet.FourCC,ST4IVisionCoreNet.FourCC)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoCapture">
            <summary>
            Video capturing class 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.VideoCapture.captureType">
            <summary>
            Capture type (File or Camera)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.#ctor">
            <summary>
            Initializes empty capture.
            To use this, you should call Open. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.#ctor(System.Int32,ST4IVisionCoreNet.VideoCaptureAPIs)">
            <summary>
            Opens a camera for video capturing
            </summary>
            <param name="index">id of the video capturing device to open. To open default camera using default backend just pass 0.
            (to backward compatibility usage of camera_id + domain_offset (CAP_*) is valid when apiPreference is CAP_ANY)</param>
            <param name="apiPreference">preferred Capture API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.#ctor(System.Int32,ST4IVisionCoreNet.VideoCaptureAPIs,System.Int32[])">
            <summary>
            Opens a camera for video capturing with API Preference and parameters
            </summary>
            <param name="index">id of the video capturing device to open. To open default camera using default backend just pass 0.
            (to backward compatibility usage of camera_id + domain_offset (CAP_*) is valid when apiPreference is CAP_ANY)</param>
            <param name="apiPreference">preferred Capture API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L.</param>
            <param name="prms">The `params` parameter allows to specify extra parameters encoded as pairs `(paramId_1, paramValue_1, paramId_2, paramValue_2, ...)`. 
            See cv::VideoCaptureProperties</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.#ctor(System.Int32,ST4IVisionCoreNet.VideoCaptureAPIs,ST4IVisionCoreNet.VideoCapturePara)">
            <summary>
            Opens a camera for video capturing with API Preference and parameters
            </summary>
            <param name="index">id of the video capturing device to open. To open default camera using default backend just pass 0.
            (to backward compatibility usage of camera_id + domain_offset (CAP_*) is valid when apiPreference is CAP_ANY)</param>
            <param name="apiPreference">preferred Capture API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L.</param>
            <param name="prms">Parameters of VideoCature for hardware acceleration</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.FromCamera(System.Int32,ST4IVisionCoreNet.VideoCaptureAPIs)">
            <summary>
            Opens a camera for video capturing
            </summary>
            <param name="index">id of the video capturing device to open. To open default camera using default backend just pass 0.
            (to backward compatibility usage of camera_id + domain_offset (CAP_*) is valid when apiPreference is CAP_ANY)</param>
            <param name="apiPreference">preferred Capture API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.#ctor(System.String,ST4IVisionCoreNet.VideoCaptureAPIs)">
            <summary>
            Opens a video file or a capturing device or an IP video stream for video capturing with API Preference
            </summary>
            <param name="fileName">it can be:
            - name of video file (eg. `video.avi`)
            - or image sequence (eg. `img_%02d.jpg`, which will read samples like `img_00.jpg, img_01.jpg, img_02.jpg, ...`)
            - or URL of video stream (eg. `protocol://host:port/script_name?script_params|auth`).
            Note that each video stream or IP camera feed has its own URL scheme. Please refer to the
            documentation of source stream to know the right URL.</param>
            <param name="apiPreference">apiPreference preferred Capture API backends to use. Can be used to enforce a specific reader
            implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.#ctor(System.String,ST4IVisionCoreNet.VideoCaptureAPIs,System.Int32[])">
            <summary>
            Opens a video file or a capturing device or an IP video stream for video capturing with API Preference
            </summary>
            <param name="fileName">it can be:
            - name of video file (eg. `video.avi`)
            - or image sequence (eg. `img_%02d.jpg`, which will read samples like `img_00.jpg, img_01.jpg, img_02.jpg, ...`)
            - or URL of video stream (eg. `protocol://host:port/script_name?script_params|auth`).
            Note that each video stream or IP camera feed has its own URL scheme. Please refer to the
            documentation of source stream to know the right URL.</param>
            <param name="apiPreference">apiPreference preferred Capture API backends to use. Can be used to enforce a specific reader
            implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW.</param>
            <param name="prms">The `params` parameter allows to specify extra parameters encoded as pairs `(paramId_1, paramValue_1, paramId_2, paramValue_2, ...)`. 
            See cv::VideoCaptureProperties</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.#ctor(System.String,ST4IVisionCoreNet.VideoCaptureAPIs,ST4IVisionCoreNet.VideoCapturePara)">
            <summary>
            Opens a video file or a capturing device or an IP video stream for video capturing with API Preference
            </summary>
            <param name="fileName">it can be:
            - name of video file (eg. `video.avi`)
            - or image sequence (eg. `img_%02d.jpg`, which will read samples like `img_00.jpg, img_01.jpg, img_02.jpg, ...`)
            - or URL of video stream (eg. `protocol://host:port/script_name?script_params|auth`).
            Note that each video stream or IP camera feed has its own URL scheme. Please refer to the
            documentation of source stream to know the right URL.</param>
            <param name="apiPreference">apiPreference preferred Capture API backends to use. Can be used to enforce a specific reader
            implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW.</param>
            <param name="prms">Parameters of VideoCature for hardware acceleration</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.FromFile(System.String,ST4IVisionCoreNet.VideoCaptureAPIs)">
            <summary>
            Opens a video file or a capturing device or an IP video stream for video capturing with API Preference
            </summary>
            <param name="fileName">it can be:
            - name of video file (eg. `video.avi`)
            - or image sequence (eg. `img_%02d.jpg`, which will read samples like `img_00.jpg, img_01.jpg, img_02.jpg, ...`)
            - or URL of video stream (eg. `protocol://host:port/script_name?script_params|auth`).
            Note that each video stream or IP camera feed has its own URL scheme. Please refer to the
            documentation of source stream to know the right URL.</param>
            <param name="apiPreference">apiPreference preferred Capture API backends to use. Can be used to enforce a specific reader
            implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.#ctor(System.IntPtr)">
            <summary>
            Initializes from native pointer
            </summary>
            <param name="ptr">CvCapture*</param>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.CaptureType">
            <summary>
            Gets the capture type (File or Camera) 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.PosMsec">
            <summary>
            Gets or sets film current position in milliseconds or video capture timestamp 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.PosFrames">
            <summary>
            Gets or sets 0-based index of the frame to be decoded/captured next
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.PosAviRatio">
            <summary>
            Gets or sets relative position of video file
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.FrameWidth">
            <summary>
            Gets or sets width of frames in the video stream
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.FrameHeight">
            <summary>
            Gets or sets height of frames in the video stream 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Fps">
            <summary>
            Gets or sets frame rate
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.FourCC">
            <summary>
            Gets or sets 4-character code of codec 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.FrameCount">
            <summary>
            Gets number of frames in video file 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Brightness">
            <summary>
            Gets or sets brightness of image (only for cameras) 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Contrast">
            <summary>
            Gets or sets contrast of image (only for cameras) 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Saturation">
            <summary>
            Gets or sets saturation of image (only for cameras) 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Hue">
            <summary>
            Gets or sets hue of image (only for cameras) 
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Format">
            <summary>
            The format of the Mat objects returned by retrieve()
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Mode">
            <summary>
            A backend-specific value indicating the current capture mode
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Gain">
            <summary>
            Gain of the image (only for cameras)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Exposure">
            <summary>
            Exposure (only for cameras)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.ConvertRgb">
            <summary>
            Boolean flags indicating whether images should be converted to RGB
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.WhiteBalanceBlueU">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Rectification">
            <summary>
            TOWRITE (note: only supported by DC1394 v 2.x backend currently)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Monocrome">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Sharpness">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.AutoExposure">
            <summary>
            exposure control done by camera,
            user can adjust refernce level using this feature
            [CV_CAP_PROP_AUTO_EXPOSURE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Gamma">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Temperature">
            <summary>
            
            [CV_CAP_PROP_TEMPERATURE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Trigger">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.TriggerDelay">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.WhiteBalanceRedV">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Zoom">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Focus">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Guid">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.IsoSpeed">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.BackLight">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Pan">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Tilt">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Roll">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Iris">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.Settings">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.BufferSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.AutoFocus">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_OutputMode">
            <summary>
            
            [CV_CAP_PROP_OPENNI_OUTPUT_MODE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_FrameMaxDepth">
            <summary>
            in mm
            [CV_CAP_PROP_OPENNI_FRAME_MAX_DEPTH]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_Baseline">
            <summary>
            in mm
            [CV_CAP_PROP_OPENNI_BASELINE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_FocalLength">
            <summary>
            in pixels
            [CV_CAP_PROP_OPENNI_FOCAL_LENGTH]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_Registration">
            <summary>
            flag that synchronizes the remapping depth map to image map
            by changing depth generator's view point (if the flag is "on") or
            sets this view point to its normal one (if the flag is "off").
            [CV_CAP_PROP_OPENNI_REGISTRATION]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_ImageGeneratorOutputMode">
            <summary>
            
            [CV_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_DepthGeneratorBaseline">
            <summary>
            
            [CV_CAP_OPENNI_DEPTH_GENERATOR_BASELINE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_DepthGeneratorFocalLength">
            <summary>
            
            [CV_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.OpenNI_DepthGeneratorRegistrationON">
            <summary>
            
            [CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.GStreamerQueueLength">
            <summary>
            default is 1
            [CV_CAP_GSTREAMER_QUEUE_LENGTH]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.PvAPIMulticastIP">
            <summary>
            ip for anable multicast master mode. 0 for disable multicast
            [CV_CAP_PROP_PVAPI_MULTICASTIP]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_Downsampling">
            <summary>
            Change image resolution by binning or skipping.  
            [CV_CAP_PROP_XI_DOWNSAMPLING]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_DataFormat">
            <summary>
            Output data format.
            [CV_CAP_PROP_XI_DATA_FORMAT]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_OffsetX">
            <summary>
            Horizontal offset from the origin to the area of interest (in pixels).
            [CV_CAP_PROP_XI_OFFSET_X]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_OffsetY">
            <summary>
            Vertical offset from the origin to the area of interest (in pixels).
            [CV_CAP_PROP_XI_OFFSET_Y]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_TrgSource">
            <summary>
            Defines source of trigger.
            [CV_CAP_PROP_XI_TRG_SOURCE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_TrgSoftware">
            <summary>
            Generates an internal trigger. PRM_TRG_SOURCE must be set to TRG_SOFTWARE.
            [CV_CAP_PROP_XI_TRG_SOFTWARE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_GpiSelector">
            <summary>
            Selects general purpose input
            [CV_CAP_PROP_XI_GPI_SELECTOR]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_GpiMode">
            <summary>
            Set general purpose input mode
            [CV_CAP_PROP_XI_GPI_MODE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_GpiLevel">
            <summary>
            Get general purpose level
            [CV_CAP_PROP_XI_GPI_LEVEL]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_GpoSelector">
            <summary>
            Selects general purpose output 
            [CV_CAP_PROP_XI_GPO_SELECTOR]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_GpoMode">
            <summary>
            Set general purpose output mode
            [CV_CAP_PROP_XI_GPO_MODE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_LedSelector">
            <summary>
            Selects camera signalling LED 
            [CV_CAP_PROP_XI_LED_SELECTOR]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_LedMode">
            <summary>
            Define camera signalling LED functionality
            [CV_CAP_PROP_XI_LED_MODE]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_ManualWB">
            <summary>
            Calculates White Balance(must be called during acquisition)
            [CV_CAP_PROP_XI_MANUAL_WB]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_AutoWB">
            <summary>
            Automatic white balance
            [CV_CAP_PROP_XI_AUTO_WB]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_AEAG">
            <summary>
            Automatic exposure/gain
            [CV_CAP_PROP_XI_AEAG]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_ExpPriority">
            <summary>
            Exposure priority (0.5 - exposure 50%, gain 50%).
            [CV_CAP_PROP_XI_EXP_PRIORITY]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_AEMaxLimit">
            <summary>
            Maximum limit of exposure in AEAG procedure
            [CV_CAP_PROP_XI_AE_MAX_LIMIT]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_AGMaxLimit">
            <summary>
            Maximum limit of gain in AEAG procedure
            [CV_CAP_PROP_XI_AG_MAX_LIMIT]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_AEAGLevel">
            <summary>
            default is 1
            [CV_CAP_PROP_XI_AEAG_LEVEL]
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoCapture.XI_Timeout">
            <summary>
            default is 1
            [CV_CAP_PROP_XI_TIMEOUT]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Open(System.String,ST4IVisionCoreNet.VideoCaptureAPIs)">
            <summary>
            Opens a video file or a capturing device or an IP video stream for video capturing.
            </summary>
            <param name="fileName">it can be:
            - name of video file (eg. `video.avi`)
            - or image sequence (eg. `img_%02d.jpg`, which will read samples like `img_00.jpg, img_01.jpg, img_02.jpg, ...`)
            - or URL of video stream (eg. `protocol://host:port/script_name?script_params|auth`).
            Note that each video stream or IP camera feed has its own URL scheme. Please refer to the
            documentation of source stream to know the right URL.</param>
            <param name="apiPreference">apiPreference preferred Capture API backends to use. Can be used to enforce a specific reader
            implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW.</param>
            <returns>`true` if the file has been successfully opened</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Open(System.Int32,ST4IVisionCoreNet.VideoCaptureAPIs)">
            <summary>
            Opens a camera for video capturing
            </summary>
            <param name="index">id of the video capturing device to open. To open default camera using default backend just pass 0.
            (to backward compatibility usage of camera_id + domain_offset (CAP_*) is valid when apiPreference is CAP_ANY)</param>
            <param name="apiPreference">preferred Capture API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L.</param>
            <returns>`true` if the file has been successfully opened</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.IsOpened">
            <summary>
            Returns true if video capturing has been initialized already.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Release">
            <summary>
            Closes video file or capturing device.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Grab">
             <summary>
             Grabs the next frame from video file or capturing device.
            
             The method/function grabs the next frame from video file or camera and returns true (non-zero) in the case of success.
            
             The primary use of the function is in multi-camera environments, especially when the cameras do not
             have hardware synchronization. That is, you call VideoCapture::grab() for each camera and after that
             call the slower method VideoCapture::retrieve() to decode and get frame from each camera. This way
             the overhead on demosaicing or motion jpeg decompression etc. is eliminated and the retrieved frames
             from different cameras will be closer in time.
            
             Also, when a connected camera is multi-head (for example, a stereo camera or a Kinect device), the
             correct way of retrieving data from it is to call VideoCapture::grab() first and then call
             VideoCapture::retrieve() one or more times with different values of the channel parameter.
             </summary>
             <returns>`true` (non-zero) in the case of success.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Retrieve(ST4IVisionCoreNet.OutputArray,System.Int32)">
             <summary>
             Decodes and returns the grabbed video frame.
            
             The method decodes and returns the just grabbed frame. If no frames has been grabbed
             (camera has been disconnected, or there are no more frames in video file), the method returns false
             and the function returns an empty image (with %cv::Mat, test it with Mat::empty()).
             </summary>
             <param name="image">the video frame is returned here. If no frames has been grabbed the image will be empty.</param>
             <param name="flag">it could be a frame index or a driver specific flag</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Retrieve(ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.CameraChannels)">
            <summary>
            Decodes and returns the grabbed video frame.
            
            The method decodes and returns the just grabbed frame. If no frames has been grabbed
            (camera has been disconnected, or there are no more frames in video file), the method returns false
            and the function returns an empty image (with %cv::Mat, test it with Mat::empty()).
            </summary>
            <param name="image">the video frame is returned here. If no frames has been grabbed the image will be empty.</param>
            <param name="streamIdx">non-zero streamIdx is only valid for multi-head camera live streams</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Retrieve(ST4IVisionCoreNet.Mat,System.Int32)">
             <summary>
             Decodes and returns the grabbed video frame.
            
             The method decodes and returns the just grabbed frame. If no frames has been grabbed
             (camera has been disconnected, or there are no more frames in video file), the method returns false
             and the function returns an empty image (with %cv::Mat, test it with Mat::empty()).
             </summary>
             <param name="image">the video frame is returned here. If no frames has been grabbed the image will be empty.</param>
             <param name="flag">it could be a frame index or a driver specific flag</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Retrieve(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.CameraChannels)">
            <summary>
            Decodes and returns the grabbed video frame.
            
            The method decodes and returns the just grabbed frame. If no frames has been grabbed
            (camera has been disconnected, or there are no more frames in video file), the method returns false
            and the function returns an empty image (with %cv::Mat, test it with Mat::empty()).
            </summary>
            <param name="image">the video frame is returned here. If no frames has been grabbed the image will be empty.</param>
            <param name="streamIdx">non-zero streamIdx is only valid for multi-head camera live streams</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.RetrieveMat">
             <summary>
             Decodes and returns the grabbed video frame.
            
             The method decodes and returns the just grabbed frame. If no frames has been grabbed
             (camera has been disconnected, or there are no more frames in video file), the method returns false
             and the function returns an empty image (with %cv::Mat, test it with Mat::empty()).
             </summary>
             <returns>the video frame is returned here. If no frames has been grabbed the image will be empty.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Read(ST4IVisionCoreNet.OutputArray)">
             <summary>
             Grabs, decodes and returns the next video frame.
            
             The method/function combines VideoCapture::grab() and VideoCapture::retrieve() in one call. This is the
             most convenient method for reading video files or capturing data from decode and returns the just
             grabbed frame. If no frames has been grabbed (camera has been disconnected, or there are no more
             frames in video file), the method returns false and the function returns empty image (with %cv::Mat, test it with Mat::empty()).
             </summary>
             <returns>`false` if no frames has been grabbed</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Read(ST4IVisionCoreNet.Mat)">
             <summary>
             Grabs, decodes and returns the next video frame.
            
             The method/function combines VideoCapture::grab() and VideoCapture::retrieve() in one call. This is the
             most convenient method for reading video files or capturing data from decode and returns the just
             grabbed frame. If no frames has been grabbed (camera has been disconnected, or there are no more
             frames in video file), the method returns false and the function returns empty image (with %cv::Mat, test it with Mat::empty()).
             </summary>
             <returns>`false` if no frames has been grabbed</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Set(ST4IVisionCoreNet.VideoCaptureProperties,System.Double)">
            <summary>
            Sets a property in the VideoCapture.
            </summary>
            <param name="propertyId">Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)
            or one from @ref videoio_flags_others</param>
            <param name="value">Value of the property.</param>
            <returns>`true` if the property is supported by backend used by the VideoCapture instance.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Set(System.Int32,System.Double)">
            <summary>
            Sets a property in the VideoCapture.
            </summary>
            <param name="propertyId">Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)
            or one from @ref videoio_flags_others</param>
            <param name="value">Value of the property.</param>
            <returns>`true` if the property is supported by backend used by the VideoCapture instance.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Get(ST4IVisionCoreNet.VideoCaptureProperties)">
            <summary>
            Returns the specified VideoCapture property
            </summary>
            <param name="propertyId">Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)
            or one from @ref videoio_flags_others</param>
            <returns>Value for the specified property. Value 0 is returned when querying a property that is not supported by the backend used by the VideoCapture instance.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.Get(System.Int32)">
            <summary>
            Returns the specified VideoCapture property
            </summary>
            <param name="propertyId">Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)
            or one from @ref videoio_flags_others</param>
            <returns>Value for the specified property. Value 0 is returned when querying a property that is not supported by the backend used by the VideoCapture instance.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.GetBackendName">
            <summary>
            Returns used backend API name.
            Note that stream should be opened.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.SetExceptionMode(System.Boolean)">
            <summary>
            Switches exceptions mode.
            methods raise exceptions if not successful instead of returning an error code
            </summary>
            <param name="enable"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.GetExceptionMode">
            <summary>
            query if exception mode is active
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoCapture.WaitAny(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.VideoCapture},System.Int32[]@,System.Int64)">
             <summary>
             Wait for ready frames from VideoCapture.
             
             The primary use of the function is in multi-camera environments.
             The method fills the ready state vector, grabs video frame, if camera is ready.
            
             After this call use VideoCapture::retrieve() to decode and fetch frame data.
             </summary>
             <param name="streams">input video streams</param>
             <param name="readyIndex">stream indexes with grabbed frames (ready to use .retrieve() to fetch actual frame)</param>
             <param name="timeoutNs">number of nanoseconds (0 - infinite)</param>
             <exception cref="T:ST4IVisionCoreNet.OpenCVException">Exception %Exception on stream errors (check .isOpened()
             to filter out malformed streams) or VideoCapture type is not supported</exception>
             <returns>`true if streamReady is not empty</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoCapture.IntBytes">
            <summary>
            For accessing each byte of Int32 value
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.VideoWriter">
            <summary>
            AVI Video File Writer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.#ctor(System.String,ST4IVisionCoreNet.FourCC,System.Double,ST4IVisionCoreNet.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Frame rate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.#ctor(System.String,ST4IVisionCoreNet.VideoCaptureAPIs,ST4IVisionCoreNet.FourCC,System.Double,ST4IVisionCoreNet.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="apiPreference">allows to specify API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_GSTREAMER.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Frame rate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.#ctor(System.String,ST4IVisionCoreNet.FourCC,System.Double,ST4IVisionCoreNet.Size,System.Int32[])">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Frame rate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="prms">The `params` parameter allows to specify extra encoder parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .)
            see cv::VideoWriterProperties</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.#ctor(System.String,ST4IVisionCoreNet.FourCC,System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.VideoWriterPara)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Frame rate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="prms">Parameters of VideoWriter for hardware acceleration</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.#ctor(System.String,ST4IVisionCoreNet.VideoCaptureAPIs,ST4IVisionCoreNet.FourCC,System.Double,ST4IVisionCoreNet.Size,System.Int32[])">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="apiPreference">allows to specify API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_GSTREAMER.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Frame rate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="prms">The `params` parameter allows to specify extra encoder parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .)
            see cv::VideoWriterProperties</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.#ctor(System.String,ST4IVisionCoreNet.VideoCaptureAPIs,ST4IVisionCoreNet.FourCC,System.Double,ST4IVisionCoreNet.Size,ST4IVisionCoreNet.VideoWriterPara)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="apiPreference">allows to specify API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_GSTREAMER.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Frame rate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="prms">Parameters of VideoWriter for hardware acceleration</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.#ctor(System.IntPtr)">
            <summary>
            Initializes from native pointer
            </summary>
            <param name="ptr">CvVideoWriter*</param>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoWriter.FileName">
            <summary>
            Get output video file name
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoWriter.Fps">
            <summary>
            Frames per second of the output video
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoWriter.FrameSize">
            <summary>
            Get size of frame image
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.VideoWriter.IsColor">
            <summary>
            Get whether output frames is color or not
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.Open(System.String,ST4IVisionCoreNet.FourCC,System.Double,ST4IVisionCoreNet.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Frame rate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.Open(System.String,ST4IVisionCoreNet.VideoCaptureAPIs,ST4IVisionCoreNet.FourCC,System.Double,ST4IVisionCoreNet.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="apiPreference">allows to specify API backends to use. Can be used to enforce a specific reader implementation
            if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_GSTREAMER.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Frame rate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.IsOpened">
            <summary>
            Returns true if video writer has been successfully initialized.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.Release">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.Write(ST4IVisionCoreNet.InputArray)">
            <summary>
            Writes/appends one frame to video file. 
            </summary>
            <param name="image">the written frame.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.Set(ST4IVisionCoreNet.VideoWriterProperties,System.Double)">
            <summary>
             Sets a property in the VideoWriter.
            </summary>
            <param name="propId">Property identifier from cv::VideoWriterProperties (eg. cv::VIDEOWRITER_PROP_QUALITY) or one of @ref videoio_flags_others</param>
            <param name="value">Value of the property.</param>
            <returns>`true` if the property is supported by the backend used by the VideoWriter instance.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.Get(ST4IVisionCoreNet.VideoWriterProperties)">
            <summary>
            Returns the specified VideoWriter property
            </summary>
            <param name="propId"> Property identifier from cv::VideoWriterProperties (eg. cv::VIDEOWRITER_PROP_QUALITY) or one of @ref videoio_flags_others</param>
            <returns>Value for the specified property. Value 0 is returned when querying a property that is not supported by the backend used by the VideoWriter instance.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.FourCC(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Concatenates 4 chars to a fourcc code.
            This static method constructs the fourcc code of the codec to be used in 
            the constructor VideoWriter::VideoWriter or VideoWriter::open.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.FourCC(System.String)">
            <summary>
            Concatenates 4 chars to a fourcc code.
            This static method constructs the fourcc code of the codec to be used in 
            the constructor VideoWriter::VideoWriter or VideoWriter::open.
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.VideoWriter.GetBackendName">
            <summary>
            Returns used backend API name.
            Note that stream should be opened.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.BackgroundSubtractor">
            <summary>
            The Base Class for Background/Foreground Segmentation.
            The class is only used to define the common interface for
            the whole family of background/foreground segmentation algorithms.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractor.Apply(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double)">
            <summary>
            the update operator that takes the next video frame and returns the current foreground mask as 8-bit binary image.
            </summary>
            <param name="image"></param>
            <param name="fgmask"></param>
            <param name="learningRate"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractor.GetBackgroundImage(ST4IVisionCoreNet.OutputArray)">
            <summary>
            computes a background image
            </summary>
            <param name="backgroundImage"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.BackgroundSubtractorKNN">
            <summary>
            K nearest neigbours algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BackgroundSubtractorKNN.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractorKNN.Create(System.Int32,System.Double,System.Boolean)">
            <summary>
            Creates KNN Background Subtractor
            </summary>
            <param name="history">Length of the history.</param>
            <param name="dist2Threshold">Threshold on the squared distance between the pixel and the sample to decide
            whether a pixel is close to that sample. This parameter does not affect the background update.</param>
            <param name="detectShadows">If true, the algorithm will detect shadows and mark them. It decreases the
            speed a bit, so if you do not need this feature, set the parameter to false.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractorKNN.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorKNN.History">
            <summary>
            Gets or sets the number of last frames that affect the background model.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorKNN.NSamples">
            <summary>
            Gets or sets the number of data samples in the background model
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorKNN.Dist2Threshold">
            <summary>
            Gets or sets the threshold on the squared distance between the pixel and the sample.
            The threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to a data sample.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorKNN.KNNSamples">
            <summary>
            Returns the number of neighbours, the k in the kNN.
            K is the number of samples that need to be within dist2Threshold in order to decide that that
            pixel is matching the kNN background model.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorKNN.DetectShadows">
            <summary>
            Returns the shadow detection flag.
            If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorKNN for details.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorKNN.ShadowValue">
            <summary>
            Gets or sets the shadow value.
            Shadow value is the value used to mark shadows in the foreground mask. Default value is 127.
            Value 0 in the mask always means background, 255 means foreground.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorKNN.ShadowThreshold">
            <summary>
            Gets or sets the shadow threshold.
            A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in
            the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel
            is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara,
            *Detecting Moving Shadows...*, IEEE PAMI,2003.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.BackgroundSubtractorMOG2">
            <summary>
            The Base Class for Background/Foreground Segmentation.
            The class is only used to define the common interface for
            the whole family of background/foreground segmentation algorithms.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.BackgroundSubtractorMOG2.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractorMOG2.Create(System.Int32,System.Double,System.Boolean)">
            <summary>
            Creates MOG2 Background Subtractor.
            </summary>
            <param name="history">Length of the history.</param>
            <param name="varThreshold">Threshold on the squared Mahalanobis distance between the pixel and the model
            to decide whether a pixel is well described by the background model. This parameter does not affect the background update.</param>
            <param name="detectShadows">If true, the algorithm will detect shadows and mark them. It decreases the speed a bit,
            so if you do not need this feature, set the parameter to false.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.BackgroundSubtractorMOG2.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.History">
            <summary>
            Gets or sets the number of last frames that affect the background model.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.NMixtures">
            <summary>
            Gets or sets the number of gaussian components in the background model.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.BackgroundRatio">
            <summary>
            Gets or sets the "background ratio" parameter of the algorithm.
            If a foreground pixel keeps semi-constant value for about backgroundRatio\*history frames, it's
            considered background and added to the model as a center of a new component. It corresponds to TB
            parameter in the paper.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.VarThreshold">
            <summary>
            Gets or sets the variance threshold for the pixel-model match.
            The main threshold on the squared Mahalanobis distance to decide if the sample is well described by
            the background model or not. Related to Cthr from the paper.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.VarThresholdGen">
            <summary>
            Gets or sets the variance threshold for the pixel-model match used for new mixture component generation. 
            Threshold for the squared Mahalanobis distance that helps decide when a sample is close to the
            existing components (corresponds to Tg in the paper). If a pixel is not close to any component, it
            is considered foreground or added as a new component. 3 sigma =\> Tg=3\*3=9 is default. A smaller Tg
            value generates more components. A higher Tg value may result in a small number of components but they can grow too large.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.VarInit">
            <summary>
            Gets or sets the initial variance of each gaussian component.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.VarMin">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.VarMax">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.ComplexityReductionThreshold">
            <summary>
            Gets or sets the complexity reduction threshold.
            This parameter defines the number of samples needed to accept to prove the component exists. CT=0.05 
            is a default value for all the samples. By setting CT=0 you get an algorithm very similar to the standard Stauffer&amp;Grimson algorithm.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.DetectShadows">
            <summary>
            Gets or sets the shadow detection flag.
            If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorKNN for details.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.ShadowValue">
            <summary>
            Gets or sets the shadow value.
            Shadow value is the value used to mark shadows in the foreground mask. Default value is 127.
            Value 0 in the mask always means background, 255 means foreground.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.BackgroundSubtractorMOG2.ShadowThreshold">
            <summary>
            Gets or sets the shadow threshold. 
            A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in
            the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel
            is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara,
            *Detecting Moving Shadows...*, IEEE PAMI,2003.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.MotionTypes">
            <summary>
            [findTransformECC] specifying the type of motion
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MotionTypes.Translation">
            <summary>
            sets a translational motion model; warpMatrix is \f$2\times 3\f$ with
            the first \f$2\times 2\f$ part being the unity matrix and the rest two parameters being estimated.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MotionTypes.Euclidean">
            <summary>
            sets a Euclidean (rigid) transformation as motion model; three parameters are estimated; warpMatrix is \f$2\times 3\f$.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MotionTypes.Affine">
            <summary>
            sets an affine motion model (DEFAULT); six parameters are estimated; warpMatrix is \f$2\times 3\f$.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.MotionTypes.Homography">
            <summary>
            sets a homography as a motion model; eight parameters are estimated;\`warpMatrix\` is \f$3\times 3\f$.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.OpticalFlowFlags">
            <summary>
            cv::calcOpticalFlowPyrLK flags
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.OpticalFlowFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.OpticalFlowFlags.PyrAReady">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.OpticalFlowFlags.PyrBReady">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.OpticalFlowFlags.UseInitialFlow">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.OpticalFlowFlags.LkGetMinEigenvals">
            <summary>
            
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.OpticalFlowFlags.FarnebackGaussian">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.KalmanFilter">
            <summary>
            Kalman filter.
            The class implements standard Kalman filter \url{http://en.wikipedia.org/wiki/Kalman_filter}.
            However, you can modify KalmanFilter::transitionMatrix, KalmanFilter::controlMatrix and
            KalmanFilter::measurementMatrix to get the extended Kalman filter functionality.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.KalmanFilter.#ctor">
            <summary>
            the default constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.KalmanFilter.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            the full constructor taking the dimensionality of the state, of the measurement and of the control vector
            </summary>
            <param name="dynamParams"></param>
            <param name="measureParams"></param>
            <param name="controlParams"></param>
            <param name="type"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.KalmanFilter.DisposeUnmanaged">
            <summary>
            Releases unmanaged resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.StatePre">
            <summary>
            predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.StatePost">
            <summary>
            corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.TransitionMatrix">
            <summary>
            state transition matrix (A)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.ControlMatrix">
            <summary>
            control matrix (B) (not used if there is no control)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.MeasurementMatrix">
            <summary>
            measurement matrix (H)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.ProcessNoiseCov">
            <summary>
            process noise covariance matrix (Q)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.MeasurementNoiseCov">
            <summary>
            measurement noise covariance matrix (R)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.ErrorCovPre">
            <summary>
            priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*/
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.Gain">
            <summary>
            Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.KalmanFilter.ErrorCovPost">
            <summary>
            posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.KalmanFilter.Init(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            re-initializes Kalman filter. The previous content is destroyed.
            </summary>
            <param name="dynamParams"></param>
            <param name="measureParams"></param>
            <param name="controlParams"></param>
            <param name="type"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.KalmanFilter.Predict(ST4IVisionCoreNet.Mat)">
            <summary>
            computes predicted state
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.KalmanFilter.Correct(ST4IVisionCoreNet.Mat)">
            <summary>
            updates the predicted state from the measurement
            </summary>
            <param name="measurement"></param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.Tracker">
            <summary>
            Base abstract class for the long-term tracker
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracker.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            
            </summary>
            <param name="ptrObj"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracker.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracker.Init(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Rect)">
            <summary>
            Initialize the tracker with a know bounding box that surrounding the target
            </summary>
            <param name="image">The initial frame</param>
            <param name="boundingBox">The initial bounding box</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.Tracker.Update(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Rect@)">
            <summary>
            Update the tracker, find the new most likely bounding box for the target
            </summary>
            <param name="image">The current frame</param>
            <param name="boundingBox">The bounding box that represent the new target location, if true was returned, not modified otherwise</param>
            <returns>True means that target was located and false means that tracker cannot locate target in 
            current frame.Note, that latter *does not* imply that tracker has failed, maybe target is indeed 
            missing from the frame (say, out of sight)</returns>
        </member>
        <member name="T:ST4IVisionCoreNet.TrackerGOTURN">
            <inheritdoc />
            <summary>
            GOTURN (@cite GOTURN) is kind of trackers based on Convolutional Neural Networks (CNN). 
            </summary>
            <remarks>
            * While taking all advantages of CNN trackers, GOTURN is much faster due to offline training without online fine-tuning nature.
            * GOTURN tracker addresses the problem of single target tracking: given a bounding box label of an object in the first frame of the video,
            
            * we track that object through the rest of the video.NOTE: Current method of GOTURN does not handle occlusions; however, it is fairly
            * robust to viewpoint changes, lighting changes, and deformations.
            
            * Inputs of GOTURN are two RGB patches representing Target and Search patches resized to 227x227.
            * Outputs of GOTURN are predicted bounding box coordinates, relative to Search patch coordinate system, in format X1, Y1, X2, Y2.
            * Original paper is here: [http://davheld.github.io/GOTURN/GOTURN.pdf]
            * As long as original authors implementation: [https://github.com/davheld/GOTURN#train-the-tracker]
            * Implementation of training algorithm is placed in separately here due to 3d-party dependencies:
            *  [https://github.com/Auron-X/GOTURN_Training_Toolkit]
            * GOTURN architecture goturn.prototxt and trained model goturn.caffemodel are accessible on opencv_extra GitHub repository.
            </remarks>
        </member>
        <member name="M:ST4IVisionCoreNet.TrackerGOTURN.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TrackerGOTURN.Create">
            <summary>
            Constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.TrackerGOTURN.Create(ST4IVisionCoreNet.TrackerGOTURN.Params)">
            <summary>
            Constructor
            </summary>
            <param name="parameters">GOTURN parameters</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.TrackerGOTURN.Params">
            <summary>
            
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.TrackerMIL">
            <inheritdoc />
            <summary>
            The MIL algorithm trains a classifier in an online manner to separate the object from the background.
            Multiple Instance Learning avoids the drift problem for a robust tracking.The implementation is based on @cite MIL.
            Original code can be found here [http://vision.ucsd.edu/~bbabenko/project_miltrack.shtml]
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TrackerMIL.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.TrackerMIL.Create">
            <summary>
            Constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.TrackerMIL.Create(ST4IVisionCoreNet.TrackerMIL.Params)">
            <summary>
            Constructor
            </summary>
            <param name="parameters">MIL parameters</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.TrackerMIL.Params">
            <summary> 
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TrackerMIL.Params.SamplerInitInRadius">
            <summary>
            radius for gathering positive instances during init
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TrackerMIL.Params.SamplerInitMaxNegNum">
            <summary>
            # negative samples to use during init
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TrackerMIL.Params.SamplerSearchWinSize">
            <summary>
            size of search window
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TrackerMIL.Params.SamplerTrackInRadius">
            <summary>
            radius for gathering positive instances during tracking
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TrackerMIL.Params.SamplerTrackMaxPosNum">
            <summary>
            # positive samples to use during tracking
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TrackerMIL.Params.SamplerTrackMaxNegNum">
            <summary>
            # negative samples to use during tracking
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.TrackerMIL.Params.FeatureSetNumFeatures">
            <summary>
            # features  
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.WeChatQRCode">
            <summary>
            WeChat QRCode includes two CNN-based models:
            A object detection model and a super resolution model.
            Object detection model is applied to detect QRCode with the bounding box.
            super resolution model is applied to zoom in QRCode when it is small.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.WeChatQRCode.Create(System.String,System.String,System.String,System.String)">
            <summary>
            Initialize the WeChatQRCode.
            It includes two models, which are packaged with caffe format.
            Therefore, there are prototxt and caffe models (In total, four paramenters).
            </summary>
            <param name="detectorPrototxtPath">prototxt file path for the detector</param>
            <param name="detectorCaffeModelPath">caffe model file path for the detector</param>
            <param name="superResolutionPrototxtPath">prototxt file path for the super resolution model</param>
            <param name="superResolutionCaffeModelPath">caffe file path for the super resolution model</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:ST4IVisionCoreNet.WeChatQRCode.DetectAndDecode(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Mat[]@,System.String[]@)">
            <summary>
            Both detects and decodes QR code.
            To simplify the usage, there is a only API: detectAndDecode
            </summary>
            <param name="inputImage">supports grayscale or color(BGR) image.</param>
            <param name="bbox">optional output array of vertices of the found QR code quadrangle.Will be empty if not found.</param>
            <param name="results">list of decoded string.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.WeChatQRCode.DisposeManaged">
            <inheritdoc />
        </member>
        <member name="T:ST4IVisionCoreNet.XFeatures2D.BriefDescriptorExtractor">
            <summary>
            BRIEF Descriptor
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XFeatures2D.BriefDescriptorExtractor.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.BriefDescriptorExtractor.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.BriefDescriptorExtractor.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.BriefDescriptorExtractor.Create(System.Int32)">
            <summary>
            bytes is a length of descriptor in bytes. It can be equal 16, 32 or 64 bytes.
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.BriefDescriptorExtractor.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XFeatures2D.FREAK">
            <summary>
            FREAK implementation
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.FREAK.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.FREAK.Create(System.Boolean,System.Boolean,System.Single,System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="orientationNormalized">enable orientation normalization</param>
            <param name="scaleNormalized">enable scale normalization</param>
            <param name="patternScale">scaling of the description pattern</param>
            <param name="nOctaves">number of octaves covered by the detected keypoints</param>
            <param name="selectedPairs">(optional) user defined selected pairs</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.FREAK.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XFeatures2D.LATCH">
             <summary>
             LATCH Descriptor. 
             
             latch Class for computing the LATCH descriptor.
             If you find this code useful, please add a reference to the following paper in your work: 
             Gil Levi and Tal Hassner, "LATCH: Learned Arrangements of Three Patch Codes", arXiv preprint arXiv:1501.03719, 15 Jan. 2015.
            
             Note: a complete example can be found under /samples/cpp/tutorial_code/xfeatures2D/latch_match.cpp
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.LATCH.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.LATCH.Create(System.Int32,System.Boolean,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="bytes">the size of the descriptor - can be 64, 32, 16, 8, 4, 2 or 1</param>
            <param name="rotationInvariance">whether or not the descriptor should compansate for orientation changes.</param>
            <param name="halfSsdSize">the size of half of the mini-patches size. For example, if we would like to compare triplets of patches of size 7x7x
            then the half_ssd_size should be (7-1)/2 = 3.</param>
            <param name="sigma">sigma value for GaussianBlur smoothing of the source image. Source image will be used without smoothing in case sigma value is 0.
            Note: the descriptor can be coupled with any keypoint extractor. The only demand is that if you use set rotationInvariance = True then
            you will have to use an extractor which estimates the patch orientation (in degrees). Examples for such extractors are ORB and SIFT.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.LATCH.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XFeatures2D.LUCID">
            <summary>
            Class implementing the locally uniform comparison image descriptor, described in @cite LUCID.
            
            An image descriptor that can be computed very fast, while being 
            about as robust as, for example, SURF or BRIEF.
            @note It requires a color image as input.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.LUCID.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.LUCID.Create(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="lucidKernel">kernel for descriptor construction, where 1=3x3, 2=5x5, 3=7x7 and so forth</param>
            <param name="blurKernel">kernel for blurring image prior to descriptor construction, where 1=3x3, 2=5x5, 3=7x7 and so forth</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.LUCID.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XFeatures2D.StarDetector">
            <summary>
            The "Star" Detector
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.StarDetector.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.StarDetector.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="maxSize"></param>
            <param name="responseThreshold"></param>
            <param name="lineThresholdProjected"></param>
            <param name="lineThresholdBinarized"></param>
            <param name="suppressNonmaxSize"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.StarDetector.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XFeatures2D.SURF">
            <summary>
            Class for extracting Speeded Up Robust Features from an image.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.SURF.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::SURF*
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.SURF.Create(System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            The SURF constructor.
            </summary>
            <param name="hessianThreshold">Only features with keypoint.hessian larger than that are extracted. </param>
            <param name="nOctaves">The number of a gaussian pyramid octaves that the detector uses. It is set to 4 by default. 
            If you want to get very large features, use the larger value. If you want just small features, decrease it.</param>
            <param name="nOctaveLayers">The number of images within each octave of a gaussian pyramid. It is set to 2 by default.</param>
            <param name="extended">false means basic descriptors (64 elements each), true means extended descriptors (128 elements each) </param>
            <param name="upright">false means that detector computes orientation of each feature.
            true means that the orientation is not computed (which is much, much faster).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XFeatures2D.SURF.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XFeatures2D.SURF.HessianThreshold">
            <summary>
            Threshold for the keypoint detector. Only features, whose hessian is larger than hessianThreshold 
            are retained by the detector. Therefore, the larger the value, the less keypoints you will get. 
            A good default value could be from 300 to 500, depending from the image contrast.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XFeatures2D.SURF.NOctaves">
            <summary>
            The number of a gaussian pyramid octaves that the detector uses. It is set to 4 by default. 
            If you want to get very large features, use the larger value. If you want just small features, decrease it.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XFeatures2D.SURF.NOctaveLayers">
            <summary>
            The number of images within each octave of a gaussian pyramid. It is set to 2 by default.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XFeatures2D.SURF.Extended">
            <summary>
            false means that the basic descriptors (64 elements each) shall be computed. 
            true means that the extended descriptors (128 elements each) shall be computed
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XFeatures2D.SURF.Upright">
            <summary>
            false means that detector computes orientation of each feature.
            true means that the orientation is not computed (which is much, much faster). 
            For example, if you match images from a stereo pair, or do image stitching, the matched features 
            likely have very similar angles, and you can speed up feature extraction by setting upright=true.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.CvXImgProc">
            <summary>
            cv::ximgproc functions
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation">
            <summary>
            Strategy for the selective search segmentation algorithm.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategyColor">
            <summary>
            Create a new color-based strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategySize">
            <summary>
            Create a new size-based strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategyTexture">
            <summary>
            Create a new size-based strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategyFill">
            <summary>
            Create a new fill-based strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategyMultiple">
            <summary>
            Create a new multiple strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategyMultiple(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Create a new multiple strategy and set one subtrategy
            </summary>
            <param name="s1">The first strategy</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategyMultiple(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Create a new multiple strategy and set one subtrategy
            </summary>
            <param name="s1">The first strategy</param>
            <param name="s2">The second strategy</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategyMultiple(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Create a new multiple strategy and set one subtrategy
            </summary>
            <param name="s1">The first strategy</param>
            <param name="s2">The second strategy</param>
            <param name="s3">The third strategy</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Segmentation.CreateSelectiveSearchSegmentationStrategyMultiple(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Create a new multiple strategy and set one subtrategy
            </summary>
            <param name="s1">The first strategy</param>
            <param name="s2">The second strategy</param>
            <param name="s3">The third strategy</param>
            <param name="s4">The forth strategy</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL">
            <summary>
            run_length_morphology.hpp
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL.Threshold(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,ST4IVisionCoreNet.ThresholdTypes)">
            <summary>
            Applies a fixed-level threshold to each array element.
            </summary>
            <param name="src">input array (single-channel).</param>
            <param name="rlDest">resulting run length encoded image.</param>
            <param name="thresh">threshold value.</param>
            <param name="type">thresholding type (only cv::THRESH_BINARY and cv::THRESH_BINARY_INV are supported)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL.Dilate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Dilates an run-length encoded binary image by using a specific structuring element.
            </summary>
            <param name="rlSrc">input image</param>
            <param name="rlDest">result</param>
            <param name="rlKernel">kernel</param>
            <param name="anchor">position of the anchor within the element; default value (0, 0) is usually the element center.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL.Erode(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray,System.Boolean,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Erodes an run-length encoded binary image by using a specific structuring element.
            </summary>
            <param name="rlSrc">input image</param>
            <param name="rlDest">result</param>
            <param name="rlKernel">kernel</param>
            <param name="bBoundaryOn">indicates whether pixel outside the image boundary are assumed to be on
            (True: works in the same way as the default of cv::erode, False: is a little faster)</param>
            <param name="anchor">position of the anchor within the element; default value (0, 0)
            is usually the element center.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL.GetStructuringElement(ST4IVisionCoreNet.MorphShapes,ST4IVisionCoreNet.Size)">
            <summary>
            Returns a run length encoded structuring element of the specified size and shape.
            </summary>
            <param name="shape">Element shape that can be one of cv::MorphShapes</param>
            <param name="ksize">Size of the structuring element.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL.Paint(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Scalar)">
            <summary>
            Paint run length encoded binary image into an image.
            </summary>
            <param name="image">image to paint into (currently only single channel images).</param>
            <param name="rlSrc">run length encoded image</param>
            <param name="value">all foreground pixel of the binary image are set to this value</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL.IsRLMorphologyPossible(ST4IVisionCoreNet.InputArray)">
            <summary>
            Check whether a custom made structuring element can be used with run length morphological operations.
            (It must consist of a continuous array of single runs per row)
            </summary>
            <param name="rlStructuringElement"></param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL.CreateRLEImage(System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Point3i},ST4IVisionCoreNet.OutputArray,System.Nullable{ST4IVisionCoreNet.Size})">
            <summary>
            Creates a run-length encoded image from a vector of runs (column begin, column end, row)
            </summary>
            <param name="runs">vector of runs</param>
            <param name="res">result</param>
            <param name="size">image size (to be used if an "on" boundary should be used in erosion, using the default
            means that the size is computed from the extension of the input)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RL.MorphologyEx(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MorphTypes,ST4IVisionCoreNet.InputArray,System.Boolean,System.Nullable{ST4IVisionCoreNet.Point})">
            <summary>
            Applies a morphological operation to a run-length encoded binary image.
            </summary>
            <param name="rlSrc">input image</param>
            <param name="rlDest">result</param>
            <param name="op">all operations supported by cv::morphologyEx (except cv::MORPH_HITMISS)</param>
            <param name="rlKernel">kernel</param>
            <param name="bBoundaryOnForErosion">indicates whether pixel outside the image boundary are assumed
            to be on for erosion operations (True: works in the same way as the default of cv::erode, False: is a little faster)</param>
            <param name="anchor">position of the anchor within the element; default value (0, 0) is usually the element center.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.NiblackThreshold(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,ST4IVisionCoreNet.ThresholdTypes,System.Int32,System.Double,ST4IVisionCoreNet.XImgProc.LocalBinarizationMethods,System.Double)">
            <summary>
            Applies Niblack thresholding to input image.
            </summary> 
            <remarks><![CDATA[
            The function transforms a grayscale image to a binary image according to the formulae:
            -   **THRESH_BINARY**
            \f[dst(x, y) =  \fork{\texttt{maxValue }
            }{if \(src(x, y) > T(x, y)\)}{0}{otherwise}\f]
            -   ** THRESH_BINARY_INV**
            \f[dst(x, y) =  \fork{0}{if \(src(x, y) > T(x, y)\)}{\texttt{maxValue}}{otherwise}\f]
            where \f$T(x, y)\f$ is a threshold calculated individually for each pixel.
            The threshold value \f$T(x, y)\f$ is the mean minus \f$ delta \f$ times standard deviation
            of \f$\texttt{blockSize} \times\texttt{blockSize}\f$ neighborhood of \f$(x, y)\f$.
            The function can't process the image in-place.
            ]]></remarks>
            <param name="src">Source 8-bit single-channel image.</param>
            <param name="dst">Destination image of the same size and the same type as src.</param>
            <param name="maxValue">Non-zero value assigned to the pixels for which the condition is satisfied,
            used with the THRESH_BINARY and THRESH_BINARY_INV thresholding types.</param>
            <param name="type">Thresholding type, see cv::ThresholdTypes.</param>
            <param name="blockSize">Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</param>
            <param name="k">The user-adjustable parameter used by Niblack and inspired techniques.For Niblack,
            this is normally a value between 0 and 1 that is multiplied with the standard deviation and subtracted from the mean.</param>
            <param name="binarizationMethod">Binarization method to use. By default, Niblack's technique is used.
            Other techniques can be specified, see cv::ximgproc::LocalBinarizationMethods.</param>
            <param name="r">The user-adjustable parameter used by Sauvola's technique. This is the dynamic range of standard deviation.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.Thinning(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.XImgProc.ThinningTypes)">
            <summary>
            Applies a binary blob thinning operation, to achieve a skeletization of the input image.
            The function transforms a binary blob image into a skeletized form using the technique of Zhang-Suen.
            </summary>
            <param name="src">Source 8-bit single-channel image, containing binary blobs, with blobs having 255 pixel values.</param>
            <param name="dst">Destination image of the same size and the same type as src. The function can work in-place.</param>
            <param name="thinningType">Value that defines which thinning algorithm should be used. </param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.AnisotropicDiffusion(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single,System.Int32)">
            <summary>
            Performs anisotropic diffusian on an image.
            The function applies Perona-Malik anisotropic diffusion to an image.
            </summary>
            <param name="src">Grayscale Source image.</param>
            <param name="dst">Destination image of the same size and the same number of channels as src.</param>
            <param name="alpha">The amount of time to step forward by on each iteration (normally, it's between 0 and 1).</param>
            <param name="k">sensitivity to the edges</param>
            <param name="niters">The number of iterations</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.BrightEdges(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="original"></param>
            <param name="edgeView"></param>
            <param name="contrast"></param>
            <param name="shortRange"></param>
            <param name="longRange"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateQuaternionImage(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            creates a quaternion image.
            </summary>
            <param name="img">Source 8-bit, 32-bit or 64-bit image, with 3-channel image.</param>
            <param name="qimg">result CV_64FC4 a quaternion image( 4 chanels zero channel and B,G,R).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.QConj(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            calculates conjugate of a quaternion image.
            </summary>
            <param name="qimg">quaternion image.</param>
            <param name="qcimg">conjugate of qimg</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.QUnitary(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            divides each element by its modulus.
            </summary>
            <param name="qimg">quaternion image.</param>
            <param name="qnimg">conjugate of qimg</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.QMultiply(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates the per-element quaternion product of two arrays
            </summary>
            <param name="src1">quaternion image.</param>
            <param name="src2">quaternion image.</param>
            <param name="dst">product dst(I)=src1(I) . src2(I)</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.QDft(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.DftFlags,System.Boolean)">
            <summary>
            Performs a forward or inverse Discrete quaternion Fourier transform of a 2D quaternion array.
            </summary>
            <param name="img">quaternion image.</param>
            <param name="qimg">quaternion image in dual space.</param>
            <param name="flags">quaternion image in dual space. only DFT_INVERSE flags is supported</param>
            <param name="sideLeft">true the hypercomplex exponential is to be multiplied on the left (false on the right ).</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.ColorMatchTemplate(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Compares a color template against overlapped color image regions.
            </summary>
            <param name="img">Image where the search is running. It must be 3 channels image</param>
            <param name="templ">Searched template. It must be not greater than the source image and have 3 channels</param>
            <param name="result">Map of comparison results. It must be single-channel 64-bit floating-point</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.GradientDericheY(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double)">
            <summary>
            Applies Y Deriche filter to an image.
            </summary>
            <param name="op">Source 8-bit or 16bit image, 1-channel or 3-channel image.</param>
            <param name="dst">result CV_32FC image with same number of channel than _op.</param>
            <param name="alpha">double see paper</param>
            <param name="omega">double see paper</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.GradientDericheX(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double)">
            <summary>
            Applies X Deriche filter to an image.
            </summary>
            <param name="op">Source 8-bit or 16bit image, 1-channel or 3-channel image.</param>
            <param name="dst">result CV_32FC image with same number of channel than _op.</param>
            <param name="alpha">double see paper</param>
            <param name="omega">double see paper</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateEdgeBoxes(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a EdgeBoxes
            </summary>
            <param name="alpha">step size of sliding window search.</param>
            <param name="beta">nms threshold for object proposals.</param>
            <param name="eta">adaptation rate for nms threshold.</param>
            <param name="minScore">min score of boxes to detect.</param>
            <param name="maxBoxes">max number of boxes to detect.</param>
            <param name="edgeMinMag">edge min magnitude. Increase to trade off accuracy for speed.</param>
            <param name="edgeMergeThr">edge merge threshold. Increase to trade off accuracy for speed.</param>
            <param name="clusterMinMag">cluster min magnitude. Increase to trade off accuracy for speed.</param>
            <param name="maxAspectRatio">max aspect ratio of boxes.</param>
            <param name="minBoxArea">minimum area of boxes.</param>
            <param name="gamma">affinity sensitivity.</param>
            <param name="kappa">scale sensitivity.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateDTFilter(ST4IVisionCoreNet.InputArray,System.Double,System.Double,ST4IVisionCoreNet.XImgProc.EdgeAwareFiltersList,System.Int32)">
            <summary>
            Factory method, create instance of DTFilter and produce initialization routines.
            </summary>
            <param name="guide">guided image (used to build transformed distance, which describes edge structure of
            guided image).</param>
            <param name="sigmaSpatial">sigma_H parameter in the original article, it's similar to the sigma in the
            coordinate space into bilateralFilter.</param>
            <param name="sigmaColor">sigma_r parameter in the original article, it's similar to the sigma in the
            color space into bilateralFilter.</param>
            <param name="mode">one form three modes DTF_NC, DTF_RF and DTF_IC which corresponds to three modes for
            filtering 2D signals in the article.</param>
            <param name="numIters">optional number of iterations used for filtering, 3 is quite enough.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.DTFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,ST4IVisionCoreNet.XImgProc.EdgeAwareFiltersList,System.Int32)">
            <summary>
            Simple one-line Domain Transform filter call. If you have multiple images to filter with the same
            guided image then use DTFilter interface to avoid extra computations on initialization stage.
            </summary>
            <param name="guide">guided image (also called as joint image) with unsigned 8-bit or floating-point 32-bit
            depth and up to 4 channels.</param>
            <param name="src">filtering image with unsigned 8-bit or floating-point 32-bit depth and up to 4 channels.</param>
            <param name="dst">destination image</param>
            <param name="sigmaSpatial">sigma_H parameter in the original article, it's similar to the sigma in the
            coordinate space into bilateralFilter.</param>
            <param name="sigmaColor">sigma_r parameter in the original article, it's similar to the sigma in the
            color space into bilateralFilter.</param>
            <param name="mode">one form three modes DTF_NC, DTF_RF and DTF_IC which corresponds to three modes for
            filtering 2D signals in the article.</param>
            <param name="numIters">optional number of iterations used for filtering, 3 is quite enough.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateGuidedFilter(ST4IVisionCoreNet.InputArray,System.Int32,System.Double)">
            <summary>
            Factory method, create instance of GuidedFilter and produce initialization routines.
            </summary>
            <param name="guide">guided image (or array of images) with up to 3 channels, if it have more then 3
            channels then only first 3 channels will be used.</param>
            <param name="radius">radius of Guided Filter.</param>
            <param name="eps">regularization term of Guided Filter. eps^2 is similar to the sigma in the color
            space into bilateralFilter.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.GuidedFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Double,System.Int32)">
             <summary>
             Simple one-line Guided Filter call.
            
             If you have multiple images to filter with the same guided image then use GuidedFilter interface to
             avoid extra computations on initialization stage.
             </summary>
             <param name="guide">guided image (or array of images) with up to 3 channels, if it have more then 3
             channels then only first 3 channels will be used.</param>
             <param name="src">filtering image with any numbers of channels.</param>
             <param name="dst">output image.</param>
             <param name="radius">radius of Guided Filter.</param>
             <param name="eps">regularization term of Guided Filter. eps^2 is similar to the sigma in the color
             space into bilateralFilter.</param>
             <param name="dDepth">optional depth of the output image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateAMFilter(System.Double,System.Double,System.Boolean)">
            <summary>
            Factory method, create instance of AdaptiveManifoldFilter and produce some initialization routines.
            </summary>
            <param name="sigmaS">spatial standard deviation.</param>
            <param name="sigmaR">color space standard deviation, it is similar to the sigma in the color space into
            bilateralFilter.</param>
            <param name="adjustOutliers">optional, specify perform outliers adjust operation or not, (Eq. 9) in the
            original paper.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.AMFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,System.Boolean)">
            <summary>
            Simple one-line Adaptive Manifold Filter call.
            </summary>
            <param name="joint">joint (also called as guided) image or array of images with any numbers of channels.</param>
            <param name="src">filtering image with any numbers of channels.</param>
            <param name="dst">output image.</param>
            <param name="sigmaS">spatial standard deviation.</param>
            <param name="sigmaR">color space standard deviation, it is similar to the sigma in the color space into
            bilateralFilter.</param>
            <param name="adjustOutliers">optional, specify perform outliers adjust operation or not, (Eq. 9) in the
            original paper.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.JointBilateralFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Applies the joint bilateral filter to an image.
            </summary>
            <param name="joint">Joint 8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="src">Source 8-bit or floating-point, 1-channel or 3-channel image with the same depth as joint image.</param>
            <param name="dst">Destination image of the same size and type as src.</param>
            <param name="d">Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
            it is computed from sigmaSpace.</param>
            <param name="sigmaColor">Filter sigma in the color space. A larger value of the parameter means that
            farther colors within the pixel neighborhood(see sigmaSpace) will be mixed together, resulting in
            larger areas of semi-equal color.</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. A larger value of the parameter means that
            farther pixels will influence each other as long as their colors are close enough(see sigmaColor).
            When d\>0 , it specifies the neighborhood size regardless of sigmaSpace.Otherwise, d is
            proportional to sigmaSpace.</param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.BilateralTextureFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Applies the bilateral texture filter to an image. It performs structure-preserving texture filter.
            For more details about this filter see @cite Cho2014.
            </summary>
            <param name="src">Source image whose depth is 8-bit UINT or 32-bit FLOAT</param>
            <param name="dst">Destination image of the same size and type as src.</param>
            <param name="fr">Radius of kernel to be used for filtering. It should be positive integer</param>
            <param name="numIter">Number of iterations of algorithm, It should be positive integer</param>
            <param name="sigmaAlpha">Controls the sharpness of the weight transition from edges to smooth/texture regions, where
            a bigger value means sharper transition.When the value is negative, it is automatically calculated.</param>
            <param name="sigmaAvg">Range blur parameter for texture blurring. Larger value makes result to be more blurred. When the
            value is negative, it is automatically calculated as described in the paper.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.RollingGuidanceFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Double,System.Double,System.Int32,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Applies the rolling guidance filter to an image.
            </summary>
            <param name="src">8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="dst">Destination image of the same size and type as src.</param>
            <param name="d">Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
            it is computed from sigmaSpace.</param>
            <param name="sigmaColor">Filter sigma in the color space. A larger value of the parameter means that
            farther colors within the pixel neighborhood(see sigmaSpace) will be mixed together, resulting in
            larger areas of semi-equal color.</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. A larger value of the parameter means that
            farther pixels will influence each other as long as their colors are close enough(see sigmaColor).
            When d\>0 , it specifies the neighborhood size regardless of sigmaSpace.Otherwise, d is
            proportional to sigmaSpace.</param>
            <param name="numOfIter">Number of iterations of joint edge-preserving filtering applied on the source image.</param>
            <param name="borderType"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.FastBilateralSolverFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Simple one-line Fast Bilateral Solver filter call. If you have multiple images to filter with the same
            guide then use FastBilateralSolverFilter interface to avoid extra computations.
            </summary>
            <param name="guide">image serving as guide for filtering. It should have 8-bit depth and either 1 or 3 channels.</param>
            <param name="src">source image for filtering with unsigned 8-bit or signed 16-bit or floating-point 32-bit depth and up to 4 channels.</param>
            <param name="confidence">confidence image with unsigned 8-bit or floating-point 32-bit confidence and 1 channel.</param>
            <param name="dst">destination image.</param>
            <param name="sigmaSpatial">parameter, that is similar to spatial space sigma (bandwidth) in bilateralFilter.</param>
            <param name="sigmaLuma">parameter, that is similar to luma space sigma (bandwidth) in bilateralFilter.</param>
            <param name="sigmaChroma">parameter, that is similar to chroma space sigma (bandwidth) in bilateralFilter.</param>
            <param name="lambda">smoothness strength parameter for solver.</param>
            <param name="numIter">number of iterations used for solver, 25 is usually enough.</param>
            <param name="maxTol">convergence tolerance used for solver.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateFastGlobalSmootherFilter(ST4IVisionCoreNet.InputArray,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Factory method, create instance of FastGlobalSmootherFilter and execute the initialization routines.
            </summary>
            <param name="guide">image serving as guide for filtering. It should have 8-bit depth and either 1 or 3 channels.</param>
            <param name="lambda">parameter defining the amount of regularization</param>
            <param name="sigmaColor">parameter, that is similar to color space sigma in bilateralFilter.</param>
            <param name="lambdaAttenuation">internal parameter, defining how much lambda decreases after each iteration. Normally,
            it should be 0.25. Setting it to 1.0 may lead to streaking artifacts.</param>
            <param name="numIter">number of iterations used for filtering, 3 is usually enough.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.FastGlobalSmootherFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same
            guide then use FastGlobalSmootherFilter interface to avoid extra computations.
            </summary>
            <param name="guide">image serving as guide for filtering. It should have 8-bit depth and either 1 or 3 channels.</param>
            <param name="src">source image for filtering with unsigned 8-bit or signed 16-bit or floating-point 32-bit depth and up to 4 channels.</param>
            <param name="dst">destination image.</param>
            <param name="lambda">parameter defining the amount of regularization</param>
            <param name="sigmaColor">parameter, that is similar to color space sigma in bilateralFilter.</param>
            <param name="lambdaAttenuation">internal parameter, defining how much lambda decreases after each iteration. Normally,
            it should be 0.25. Setting it to 1.0 may lead to streaking artifacts.</param>
            <param name="numIter">number of iterations used for filtering, 3 is usually enough.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.L0Smooth(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double)">
            <summary>
            Global image smoothing via L0 gradient minimization.
            </summary>
            <param name="src">source image for filtering with unsigned 8-bit or signed 16-bit or floating-point depth.</param>
            <param name="dst">destination image.</param>
            <param name="lambda">parameter defining the smooth term weight.</param>
            <param name="kappa">parameter defining the increasing factor of the weight of the gradient data term.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.EdgePreservingFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Double)">
            <summary>
            Smoothes an image using the Edge-Preserving filter.
            </summary>
            <param name="src">Source 8-bit 3-channel image.</param>
            <param name="dst">Destination image of the same size and type as src.</param>
            <param name="d">Diameter of each pixel neighborhood that is used during filtering. Must be greater or equal 3.</param>
            <param name="threshold">Threshold, which distinguishes between noise, outliers, and data.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CovarianceEstimation(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32)">
            <summary>
            Computes the estimated covariance matrix of an image using the sliding window forumlation.
            </summary>
            <remarks>
            The window size parameters control the accuracy of the estimation.
            The sliding window moves over the entire image from the top-left corner 
            to the bottom right corner.Each location of the window represents a sample. 
            If the window is the size of the image, then this gives the exact covariance matrix. 
            For all other cases, the sizes of the window will impact the number of samples 
            and the number of elements in the estimated covariance matrix.
            </remarks>
            <param name="src">The source image. Input image must be of a complex type.</param>
            <param name="dst">The destination estimated covariance matrix. Output matrix will be size (windowRows*windowCols, windowRows*windowCols).</param>
            <param name="windowRows">The number of rows in the window.</param>
            <param name="windowCols">The number of cols in the window.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.FastHoughTransform(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.MatType,ST4IVisionCoreNet.XImgProc.AngleRangeOption,ST4IVisionCoreNet.XImgProc.HoughOP,ST4IVisionCoreNet.XImgProc.HoughDeskewOption)">
            <summary>
            Calculates 2D Fast Hough transform of an image.
            </summary>
            <param name="src">The source (input) image.</param>
            <param name="dst">The destination image, result of transformation.</param>
            <param name="dstMatDepth">The depth of destination image</param>
            <param name="angleRange">The part of Hough space to calculate, see cv::AngleRangeOption</param>
            <param name="op">The operation to be applied, see cv::HoughOp</param>
            <param name="makeSkew">Specifies to do or not to do image skewing, see cv::HoughDeskewOption</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.HoughPoint2Line(ST4IVisionCoreNet.Point,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.XImgProc.AngleRangeOption,ST4IVisionCoreNet.XImgProc.HoughDeskewOption,ST4IVisionCoreNet.XImgProc.RulesOption)">
            <summary>
            Calculates coordinates of line segment corresponded by point in Hough space.
            </summary>
            <remarks>
            If rules parameter set to RO_STRICT then returned line cut along the border of source image.
            If rules parameter set to RO_WEAK then in case of point, which belongs 
            the incorrect part of Hough image, returned line will not intersect source image.
            </remarks>
            <param name="houghPoint">Point in Hough space.</param>
            <param name="srcImgInfo">The source (input) image of Hough transform.</param>
            <param name="angleRange">The part of Hough space where point is situated, see cv::AngleRangeOption</param>
            <param name="makeSkew">Specifies to do or not to do image skewing, see cv::HoughDeskewOption</param>
            <param name="rules">Specifies strictness of line segment calculating, see cv::RulesOption</param>
            <returns>Coordinates of line segment corresponded by point in Hough space.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateFastLineDetector(System.Int32,System.Single,System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Creates a smart pointer to a FastLineDetector object and initializes it
            </summary>
            <param name="lengthThreshold">Segment shorter than this will be discarded</param>
            <param name="distanceThreshold"> A point placed from a hypothesis line segment farther than 
            this will be regarded as an outlier</param>
            <param name="cannyTh1">First threshold for hysteresis procedure in Canny()</param>
            <param name="cannyTh2">Second threshold for hysteresis procedure in Canny()</param>
            <param name="cannyApertureSize">Aperture size for the sobel operator in Canny()</param>
            <param name="doMerge">If true, incremental merging of segments will be performed</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateSuperpixelLSC(ST4IVisionCoreNet.InputArray,System.Int32,System.Single)">
             <summary>
             Class implementing the LSC (Linear Spectral Clustering) superpixels.
            
             The function initializes a SuperpixelLSC object for the input image. It sets the parameters of
             superpixel algorithm, which are: region_size and ruler.It preallocate some buffers for future
             computing iterations over the given image.An example of LSC is illustrated in the following picture.
             For enhanced results it is recommended for color images to preprocess image with little gaussian blur
             with a small 3 x 3 kernel and additional conversion into CieLAB color space.
             </summary>
             <param name="image">image Image to segment</param>
             <param name="regionSize">Chooses an average superpixel size measured in pixels</param>
             <param name="ratio">Chooses the enforcement of superpixel compactness factor of superpixel</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.GradientPaillouY(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double)">
            <summary>
            Applies Paillou filter to an image.
            </summary>
            <param name="op">Source CV_8U(S) or CV_16U(S), 1-channel or 3-channels image.</param>
            <param name="dst">Result CV_32F image with same number of channel than op.</param>
            <param name="alpha">double see paper</param>
            <param name="omega">double see paper</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.GradientPaillouX(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Double,System.Double)">
            <summary>
            Applies Paillou filter to an image.
            </summary>
            <param name="op">Source CV_8U(S) or CV_16U(S), 1-channel or 3-channels image.</param>
            <param name="dst">Result CV_32F image with same number of channel than op.</param>
            <param name="alpha">double see paper</param>
            <param name="omega">double see paper</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.PeiLinNormalization(ST4IVisionCoreNet.InputArray)">
            <summary>
            Calculates an affine transformation that normalize given image using Pei&amp;Lin Normalization.
            </summary>
            <param name="i">Given transformed image.</param>
            <returns>Transformation matrix corresponding to inversed image transformation</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.PeiLinNormalization(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Calculates an affine transformation that normalize given image using Pei&amp;Lin Normalization.
            </summary>
            <param name="i">Given transformed image.</param>
            <param name="t">Inversed image transformation.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateSuperpixelSEEDS(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
             <summary>
             Initializes a SuperpixelSEEDS object.
            
             The function initializes a SuperpixelSEEDS object for the input image. It stores the parameters of
             the image: image_width, image_height and image_channels.It also sets the parameters of the SEEDS
             superpixel algorithm, which are: num_superpixels, num_levels, use_prior, histogram_bins and
             double_step.
            
             The number of levels in num_levels defines the amount of block levels that the algorithm use in the
             optimization.The initialization is a grid, in which the superpixels are equally distributed through
             the width and the height of the image.The larger blocks correspond to the superpixel size, and the
             levels with smaller blocks are formed by dividing the larger blocks into 2 x 2 blocks of pixels,
             recursively until the smaller block level. An example of initialization of 4 block levels is
             illustrated in the following figure.
             </summary>
             <param name="imageWidth">Image width.</param>
             <param name="imageHeight">Image height.</param>
             <param name="imageChannels">Number of channels of the image.</param>
             <param name="numSuperpixels">Desired number of superpixels. Note that the actual number may be smaller
             due to restrictions(depending on the image size and num_levels). Use getNumberOfSuperpixels() to
             get the actual number.</param>
             <param name="numLevels">Number of block levels. The more levels, the more accurate is the segmentation,
             but needs more memory and CPU time.</param>
             <param name="prior">enable 3x3 shape smoothing term if \>0. A larger value leads to smoother shapes. prior
             must be in the range[0, 5].</param>
             <param name="histogramBins">Number of histogram bins.</param>
             <param name="doubleStep">If true, iterate each block level twice for higher accuracy.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateRFFeatureGetter">
            <summary>
            Creates a RFFeatureGetter
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.CreateStructuredEdgeDetection(System.String,ST4IVisionCoreNet.XImgProc.RFFeatureGetter)">
            <summary>
            Creates a StructuredEdgeDetection
            </summary>
            <param name="model">name of the file where the model is stored</param>
            <param name="howToGetFeatures">optional object inheriting from RFFeatureGetter.
            You need it only if you would like to train your own forest, pass null otherwise</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.CvXImgProc.WeightedMedianFilter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Double,ST4IVisionCoreNet.XImgProc.WMFWeightType,ST4IVisionCoreNet.Mat)">
            <summary>
            Applies weighted median filter to an image.
            </summary>
            <remarks>
            For more details about this implementation, please see @cite zhang2014100+
            </remarks>
            <param name="joint">Joint 8-bit, 1-channel or 3-channel image.</param>
            <param name="src">Source 8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="dst">Destination image.</param>
            <param name="r">Radius of filtering kernel, should be a positive integer.</param>
            <param name="sigma">Filter range standard deviation for the joint image.</param>
            <param name="weightType">The type of weight definition, see WMFWeightType</param>
            <param name="mask">A 0-1 mask that has the same size with I. This mask is used to ignore the effect of some pixels. If the pixel value on mask is 0,
            the pixel will be ignored when maintaining the joint-histogram.This is useful for applications like optical flow occlusion handling.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.EdgeBoxes">
            <summary>
            Class implementing EdgeBoxes algorithm from @cite ZitnickECCV14edgeBoxes
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.EdgeBoxes.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.EdgeBoxes.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.EdgeBoxes.Create(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a EdgeBoxes
            </summary>
            <param name="alpha">step size of sliding window search.</param>
            <param name="beta">nms threshold for object proposals.</param>
            <param name="eta">adaptation rate for nms threshold.</param>
            <param name="minScore">min score of boxes to detect.</param>
            <param name="maxBoxes">max number of boxes to detect.</param>
            <param name="edgeMinMag">edge min magnitude. Increase to trade off accuracy for speed.</param>
            <param name="edgeMergeThr">edge merge threshold. Increase to trade off accuracy for speed.</param>
            <param name="clusterMinMag">cluster min magnitude. Increase to trade off accuracy for speed.</param>
            <param name="maxAspectRatio">max aspect ratio of boxes.</param>
            <param name="minBoxArea">minimum area of boxes.</param>
            <param name="gamma">affinity sensitivity.</param>
            <param name="kappa">scale sensitivity.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.Alpha">
            <summary>
            Gets or sets the step size of sliding window search.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.Beta">
            <summary>
            Gets or sets the nms threshold for object proposals.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.Eta">
            <summary>
            Gets or sets adaptation rate for nms threshold.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.MinScore">
            <summary>
            Gets or sets the min score of boxes to detect.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.MaxBoxes">
            <summary>
            Gets or sets the max number of boxes to detect.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.EdgeMinMag">
            <summary>
            Gets or sets the edge min magnitude.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.EdgeMergeThr">
            <summary>
            Gets or sets the edge merge threshold.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.ClusterMinMag">
            <summary>
            Gets or sets the cluster min magnitude.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.MaxAspectRatio">
            <summary>
            Gets or sets the max aspect ratio of boxes.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.MinBoxArea">
            <summary>
            Gets or sets the minimum area of boxes.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.Gamma">
            <summary>
            Gets or sets the affinity sensitivity.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.EdgeBoxes.Kappa">
            <summary>
            Gets or sets the scale sensitivity.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.EdgeBoxes.GetBoundingBoxes(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Rect[]@)">
            <summary>
            Returns array containing proposal boxes.
            </summary>
            <param name="edgeMap">edge image.</param>
            <param name="orientationMap">orientation map.</param>
            <param name="boxes">proposal boxes.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter">
             <summary>
             Interface for Adaptive Manifold Filter realizations.
            
             Below listed optional parameters which may be set up with Algorithm::set function.
             -   member double sigma_s = 16.0
             Spatial standard deviation.
             -   member double sigma_r = 0.2
             Color space standard deviation.
             -   member int tree_height = -1
             Height of the manifold tree (default = -1 : automatically computed).
             -   member int num_pca_iterations = 1
             Number of iterations to computed the eigenvector.
             -   member bool adjust_outliers = false
             Specify adjust outliers using Eq. 9 or not.
             -   member bool use_RNG = true
             Specify use random number generator to compute eigenvector or not.
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.Create(System.Double,System.Double,System.Boolean)">
            <summary>
            Factory method, create instance of AdaptiveManifoldFilter and produce some initialization routines.
            </summary>
            <param name="sigmaS">spatial standard deviation.</param>
            <param name="sigmaR">color space standard deviation, it is similar to the sigma in the color space into
            bilateralFilter.</param>
            <param name="adjustOutliers">optional, specify perform outliers adjust operation or not, (Eq. 9) in the
            original paper.</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.SigmaS">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.SigmaR">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.TreeHeight">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.PCAIterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.AdjustOutliers">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.UseRNG">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.AdaptiveManifoldFilter.Filter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,ST4IVisionCoreNet.InputArray)">
            <summary>
            Apply high-dimensional filtering using adaptive manifolds.
            </summary>
            <param name="src">filtering image with any numbers of channels.</param>
            <param name="dst">output image.</param>
            <param name="joint">optional joint (also called as guided) image with any numbers of channels.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.DTFilter">
            <summary>
            Interface for realizations of Domain Transform filter.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.DTFilter.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.DTFilter.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.DTFilter.Create(ST4IVisionCoreNet.InputArray,System.Double,System.Double,ST4IVisionCoreNet.XImgProc.EdgeAwareFiltersList,System.Int32)">
            <summary>
            Factory method, create instance of DTFilter and produce initialization routines.
            </summary>
            <param name="guide">guided image (used to build transformed distance, which describes edge structure of
            guided image).</param>
            <param name="sigmaSpatial">sigma_H parameter in the original article, it's similar to the sigma in the
            coordinate space into bilateralFilter.</param>
            <param name="sigmaColor">sigma_r parameter in the original article, it's similar to the sigma in the
            color space into bilateralFilter.</param>
            <param name="mode">one form three modes DTF_NC, DTF_RF and DTF_IC which corresponds to three modes for
            filtering 2D signals in the article.</param>
            <param name="numIters">optional number of iterations used for filtering, 3 is quite enough.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.DTFilter.Filter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Simple one-line Domain Transform filter call. If you have multiple images to filter with the same
            guided image then use DTFilter interface to avoid extra computations on initialization stage.
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="dDepth"></param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.FastBilateralSolverFilter">
            <summary>
            Interface for implementations of Fast Bilateral Solver.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastBilateralSolverFilter.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastBilateralSolverFilter.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastBilateralSolverFilter.Create(ST4IVisionCoreNet.InputArray,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Factory method, create instance of FastBilateralSolverFilter and execute the initialization routines.
            </summary>
            <param name="guide">image serving as guide for filtering. It should have 8-bit depth and either 1 or 3 channels.</param>
            <param name="sigmaSpatial">parameter, that is similar to spatial space sigma (bandwidth) in bilateralFilter.</param>
            <param name="sigmaLuma">parameter, that is similar to luma space sigma (bandwidth) in bilateralFilter.</param>
            <param name="sigmaChroma">parameter, that is similar to chroma space sigma (bandwidth) in bilateralFilter.</param>
            <param name="lambda">smoothness strength parameter for solver.</param>
            <param name="numIter">number of iterations used for solver, 25 is usually enough.</param>
            <param name="maxTol">convergence tolerance used for solver.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastBilateralSolverFilter.Filter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Apply smoothing operation to the source image.
            </summary>
            <param name="src">source image for filtering with unsigned 8-bit or signed 16-bit or floating-point 32-bit depth and up to 3 channels.</param>
            <param name="confidence">confidence image with unsigned 8-bit or floating-point 32-bit confidence and 1 channel.</param>
            <param name="dst">destination image.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.FastGlobalSmootherFilter">
            <summary>
            Interface for implementations of Fast Global Smoother filter.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastGlobalSmootherFilter.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastGlobalSmootherFilter.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastGlobalSmootherFilter.Create(ST4IVisionCoreNet.InputArray,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Factory method, create instance of FastGlobalSmootherFilter and execute the initialization routines.
            </summary>
            <param name="guide">image serving as guide for filtering. It should have 8-bit depth and either 1 or 3 channels.</param>
            <param name="lambda">parameter defining the amount of regularization</param>
            <param name="sigmaColor">parameter, that is similar to color space sigma in bilateralFilter.</param>
            <param name="lambdaAttenuation">internal parameter, defining how much lambda decreases after each iteration. Normally,
            it should be 0.25. Setting it to 1.0 may lead to streaking artifacts.</param>
            <param name="numIter">number of iterations used for filtering, 3 is usually enough.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastGlobalSmootherFilter.Filter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Apply smoothing operation to the source image.
            </summary>
            <param name="src">source image for filtering with unsigned 8-bit or signed 16-bit or floating-point 32-bit depth and up to 4 channels.</param>
            <param name="dst">destination image.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.GuidedFilter">
            <summary>
            Interface for realizations of Guided Filter.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.GuidedFilter.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.GuidedFilter.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.GuidedFilter.Create(ST4IVisionCoreNet.InputArray,System.Int32,System.Double)">
            <summary>
            Factory method, create instance of GuidedFilter and produce initialization routines.
            </summary>
            <param name="guide">guided image (or array of images) with up to 3 channels, if it have more then 3
            channels then only first 3 channels will be used.</param>
            <param name="radius">radius of Guided Filter.</param>
            <param name="eps">regularization term of Guided Filter. eps^2 is similar to the sigma in the color
            space into bilateralFilter.</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.GuidedFilter.Filter(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32)">
            <summary>
            Apply Guided Filter to the filtering image.
            </summary>
            <param name="src">filtering image with any numbers of channels.</param>
            <param name="dst">output image.</param>
            <param name="dDepth">optional depth of the output image. dDepth can be set to -1, which will be equivalent to src.depth().</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.AngleRangeOption">
            <summary>
            Specifies the part of Hough space to calculate
            </summary>
            <remarks>
            The enum specifies the part of Hough space to calculate. 
            Each member specifies primarily direction of lines(horizontal or vertical) 
            and the direction of angle changes. 
            Direction of angle changes is from multiples of 90 to odd multiples of 45. 
            The image considered to be written top-down and left-to-right. 
            Angles are started from vertical line and go clockwise. 
            Separate quarters and halves are written in orientation they should be in full Hough space.
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_0_45">
            <summary>
            Vertical primarily direction and clockwise angle changes
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_45_90">
            <summary>
            Horizontal primarily direction and counterclockwise angle changes
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_90_135">
            <summary>
            Horizontal primarily direction and clockwise angle changes
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_315_0">
            <summary>
            Vertical primarily direction and counterclockwise angle changes
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_315_45">
            <summary>
            Vertical primarily direction
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_45_135">
            <summary>
            Horizontal primarily direction
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_315_135">
            <summary>
            Full set of directions
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_CTR_HOR">
            <summary>
            90 +/- atan(0.5), interval approximately from 64.5 to 116.5 degrees.
            It is used for calculating Fast Hough Transform for images skewed by atan(0.5).
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.AngleRangeOption.ARO_CTR_VER">
            <summary>
            +/- atan(0.5), interval approximately from 333.5(-26.5) to 26.5 degrees
            It is used for calculating Fast Hough Transform for images skewed by atan(0.5).
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.EdgeAwareFiltersList">
            <summary>
            one form three modes DTF_NC, DTF_RF and DTF_IC which corresponds to three modes for
            filtering 2D signals in the article.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.HoughDeskewOption">
            <summary>
            Specifies to do or not to do skewing of Hough transform image 
            </summary>
            <remarks>
            The enum specifies to do or not to do skewing of Hough transform image 
            so it would be no cycling in Hough transform image through borders of image.
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.HoughDeskewOption.RAW">
            <summary>
            Use raw cyclic image
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.HoughDeskewOption.DESKEW">
            <summary>
            Prepare deskewed image
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.HoughOP">
            <summary>
            Specifies binary operations.
            </summary>
            <remarks>
            The enum specifies binary operations, that is such ones which involve 
            two operands. Formally, a binary operation @f$ f @f$ on a set @f$ S @f$ 
            is a binary relation that maps elements of the Cartesian product 
            @f$ S \times S @f$ to @f$ S @f$: 
            @f[ f: S \times S \to S @f]
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.HoughOP.FHT_MIN">
            <summary>
            Binary minimum operation. The constant specifies the binary minimum operation
            @f$ f @f$ that is defined as follows: @f[ f(x, y) = \min(x, y) @f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.HoughOP.FHT_MAX">
            <summary>
            Binary maximum operation. The constant specifies the binary maximum operation
            @f$ f @f$ that is defined as follows: @f[ f(x, y) = \max(x, y) @f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.HoughOP.FHT_ADD">
            <summary>
            Binary addition operation. The constant specifies the binary addition operation
            @f$ f @f$ that is defined as follows: @f[ f(x, y) = x + y @f]
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.HoughOP.FHT_AVE">
            <summary>
            Binary average operation. The constant specifies the binary average operation
            @f$ f @f$ that is defined as follows: @f[ f(x, y) = \frac{x + y}{2} @f]
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.LocalBinarizationMethods">
            <summary>
            Specifies the binarization method to use in cv::ximgproc::niBlackThreshold
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.LocalBinarizationMethods.Niblack">
            <summary>
            Classic Niblack binarization. See @cite Niblack1985 .
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.LocalBinarizationMethods.Sauvola">
            <summary>
            Sauvola's technique. See @cite Sauvola1997 .
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.LocalBinarizationMethods.Wolf">
            <summary>
            Wolf's technique. See @cite Wolf2004 .
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.LocalBinarizationMethods.Nick">
            <summary>
            NICK technique. See @cite Khurshid2009 .
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.RulesOption">
            <summary>
            Specifies the degree of rules validation. 
            </summary>
            <remarks>
            The enum specifies the degree of rules validation. This can be used, for example, to choose a proper way of input arguments validation.
            </remarks>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.RulesOption.STRICT">
            <summary>
            Validate each rule in a proper way.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.RulesOption.IGNORE_BORDERS">
            <summary>
            Skip validations of image borders.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.SLICType">
            <summary>
            The algorithm variant to use for SuperpixelSLIC:
            SLIC segments image using a desired region_size, and in addition SLICO will optimize using adaptive compactness factor,
            while MSLIC will optimize using manifold methods resulting in more content-sensitive superpixels.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.SLICType.SLIC">
            <summary>
            SLIC(Simple Linear Iterative Clustering) clusters pixels using pixel channels and image plane space
            to efficiently generate compact, nearly uniform superpixels.The simplicity of approach makes it
            extremely easy to use a lone parameter specifies the number of superpixels and the efficiency of
            the algorithm makes it very practical.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.SLICType.SLICO">
            <summary>
            SLICO stands for "Zero parameter SLIC" and it is an optimization of baseline SLIC described in @cite Achanta2012.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.SLICType.MSLIC">
            <summary>
            MSLIC stands for "Manifold SLIC" and it is an optimization of baseline SLIC described in @cite Liu_2017_IEEE.
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.ThinningTypes">
            <summary>
            thinning algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.ThinningTypes.ZHANGSUEN">
            <summary>
            Thinning technique of Zhang-Suen
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.ThinningTypes.GUOHALL">
            <summary>
            Thinning technique of Guo-Hall
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.WMFWeightType">
            <summary>
            Specifies weight types of weighted median filter.
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.WMFWeightType.EXP">
            <summary>
            \f$exp(-|I1-I2|^2/(2*sigma^2))\f$
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.WMFWeightType.IV1">
            <summary>
            \f$(|I1-I2|+sigma)^-1\f$
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.WMFWeightType.IV2">
            <summary>
            \f$(|I1-I2|^2+sigma^2)^-1\f$
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.WMFWeightType.COS">
            <summary>
             \f$dot(I1,I2)/(|I1|*|I2|)\f$
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.WMFWeightType.JAC">
            <summary>
            \f$(min(r1,r2)+min(g1,g2)+min(b1,b2))/(max(r1,r2)+max(g1,g2)+max(b1,b2))\f$
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XImgProc.WMFWeightType.OFF">
            <summary>
            unweighted
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.FastLineDetector">
            <summary>
            Class implementing the FLD (Fast Line Detector) algorithm described in @cite Lee14.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastLineDetector.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastLineDetector.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastLineDetector.Create(System.Int32,System.Single,System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Creates a smart pointer to a FastLineDetector object and initializes it
            </summary>
            <param name="lengthThreshold">Segment shorter than this will be discarded</param>
            <param name="distanceThreshold"> A point placed from a hypothesis line segment farther than 
            this will be regarded as an outlier</param>
            <param name="cannyTh1">First threshold for hysteresis procedure in Canny()</param>
            <param name="cannyTh2">Second threshold for hysteresis procedure in Canny()</param>
            <param name="cannyApertureSize">Aperturesize for the sobel operator in Canny()</param>
            <param name="doMerge">If true, incremental merging of segments will be perfomred</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastLineDetector.Detect(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Finds lines in the input image.
            This is the output of the default parameters of the algorithm on the above shown image.
            </summary>
            <param name="image">A grayscale (CV_8UC1) input image. If only a roi needs to be
            selected, use: `fld_ptr-\>detect(image(roi), lines, ...);
            lines += Scalar(roi.x, roi.y, roi.x, roi.y);`</param>
            <param name="lines">A vector of Vec4f elements specifying the beginning
            and ending point of a line. Where Vec4f is (x1, y1, x2, y2), 
            point 1 is the start, point 2 - end.Returned lines are directed so that the
            brighter side is on their left.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastLineDetector.Detect(ST4IVisionCoreNet.InputArray)">
            <summary>
            Finds lines in the input image.
            This is the output of the default parameters of the algorithm on the above shown image.
            </summary>
            <param name="image">A grayscale (CV_8UC1) input image. If only a roi needs to be
            selected, use: `fld_ptr-\>detect(image(roi), lines, ...);
            lines += Scalar(roi.x, roi.y, roi.x, roi.y);`</param>
            <returns>A vector of Vec4f elements specifying the beginning
            and ending point of a line. Where Vec4f is (x1, y1, x2, y2), 
            point 1 is the start, point 2 - end.Returned lines are directed so that the
            brighter side is on their left.</returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastLineDetector.DrawSegments(ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.InputArray,System.Boolean)">
            <summary>
            Draws the line segments on a given image.
            </summary>
            <param name="image">The image, where the lines will be drawn. Should be bigger or equal to the image, where the lines were found.</param>
            <param name="lines">A vector of the lines that needed to be drawn.</param>
            <param name="drawArrow">If true, arrow heads will be drawn.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.FastLineDetector.DrawSegments(ST4IVisionCoreNet.InputOutputArray,System.Collections.Generic.IEnumerable{ST4IVisionCoreNet.Vec4f},System.Boolean)">
            <summary>
            Draws the line segments on a given image.
            </summary>
            <param name="image">The image, where the lines will be drawn. Should be bigger or equal to the image, where the lines were found.</param>
            <param name="lines">A vector of the lines that needed to be drawn.</param>
            <param name="drawArrow">If true, arrow heads will be drawn.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.RFFeatureGetter">
            <summary>
            Helper class for training part of [P. Dollar and C. L. Zitnick. Structured Forests for Fast Edge Detection, 2013].
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.RFFeatureGetter.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.RFFeatureGetter.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.RFFeatureGetter.Create">
            <summary>
            Creates a RFFeatureGetter
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.RFFeatureGetter.GetFeatures(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts feature channels from src.
            Than StructureEdgeDetection uses this feature space to detect edges.
            </summary>
            <param name="src">source image to extract features</param>
            <param name="features">output n-channel floating point feature matrix.</param>
            <param name="gnrmRad">gradientNormalizationRadius</param>
            <param name="gsmthRad">gradientSmoothingRadius</param>
            <param name="shrink">shrinkNumber</param>
            <param name="outNum">numberOfOutputChannels</param>
            <param name="gradNum">numberOfGradientOrientations</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation">
            <summary>
            Graph Based Segmentation Algorithm.
            The class implements the algorithm described in @cite PFF2004.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation.Create(System.Double,System.Single,System.Int32)">
            <summary>
            Creates a graph based segmentor
            </summary>
            <param name="sigma">The sigma parameter, used to smooth image</param>
            <param name="k">The k parameter of the algorithm</param>
            <param name="minSize">The minimum size of segments</param>
            <returns></returns>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation.Sigma">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation.K">
            <summary>
            
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation.MinSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation.ProcessImage(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Segment an image and store output in dst
            </summary>
            <param name="src">The input image. Any number of channel (1 (Eg: Gray), 3 (Eg: RGB), 4 (Eg: RGB-D)) can be provided</param>
            <param name="dst">The output segmentation. It's a CV_32SC1 Mat with the same number of cols and rows as input image, with an unique, sequential, id for each pixel.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation">
            <summary>
            Selective search segmentation algorithm.
            The class implements the algorithm described in @cite uijlings2013selective.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.Create">
            <summary>
            Create a new SelectiveSearchSegmentation class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.SetBaseImage(ST4IVisionCoreNet.InputArray)">
            <summary>
            Set a image used by switch* functions to initialize the class
            </summary>
            <param name="img">The image</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.SwitchToSingleStrategy(System.Int32,System.Single)">
            <summary>
            Initialize the class with the 'Single stragegy' parameters describled in @cite uijlings2013selective.
            </summary>
            <param name="k">The k parameter for the graph segmentation</param>
            <param name="sigma">The sigma parameter for the graph segmentation</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.SwitchToSelectiveSearchFast(System.Int32,System.Int32,System.Single)">
            <summary>
            Initialize the class with the 'Selective search fast' parameters describled in @cite uijlings2013selective.
            </summary>
            <param name="baseK">The k parameter for the first graph segmentation</param>
            <param name="incK">The increment of the k parameter for all graph segmentations</param>
            <param name="sigma">The sigma parameter for the graph segmentation</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.SwitchToSelectiveSearchQuality(System.Int32,System.Int32,System.Single)">
            <summary>
            Initialize the class with the 'Selective search fast' parameters describled in @cite uijlings2013selective.
            </summary>
            <param name="baseK">The k parameter for the first graph segmentation</param>
            <param name="incK">The increment of the k parameter for all graph segmentations</param>
            <param name="sigma">The sigma parameter for the graph segmentation</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.AddImage(ST4IVisionCoreNet.InputArray)">
            <summary>
            Add a new image in the list of images to process.
            </summary>
            <param name="img">The image</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.ClearImages">
            <summary>
            Clear the list of images to process
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.AddGraphSegmentation(ST4IVisionCoreNet.XImgProc.Segmentation.GraphSegmentation)">
            <summary>
            Add a new graph segmentation in the list of graph segementations to process.
            </summary>
            <param name="g">The graph segmentation</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.ClearGraphSegmentations">
            <summary>
            Clear the list of graph segmentations to process
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.AddStrategy(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Add a new strategy in the list of strategy to process.
            </summary>
            <param name="s">The strategy</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.ClearStrategies">
            <summary>
            Clear the list of strategy to process;
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentation.Process(ST4IVisionCoreNet.Rect[]@)">
            <summary>
            Based on all images, graph segmentations and stragies, computes all possible rects and return them
            </summary>
            <param name="rects">The list of rects. The first ones are more relevents than the lasts ones.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy">
            <inheritdoc />
            <summary>
            Strategy for the selective search segmentation algorithm.
            The class implements a generic stragery for the algorithm described in @cite uijlings2013selective.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy.PtrObj">
            <summary>
            
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy.#ctor(ST4IVisionCoreNet.Ptr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy.SetImage(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Set a initial image, with a segementation.
            </summary>
            <param name="img">The input image. Any number of channel can be provided</param>
            <param name="regions">A segementation of the image. The parameter must be the same size of img.</param>
            <param name="sizes">The sizes of different regions</param>
            <param name="imageId">If not set to -1, try to cache pre-computations. If the same set og (img, regions, size) is used, the image_id need to be the same.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy.Get(System.Int32,System.Int32)">
            <summary>
            Return the score between two regions (between 0 and 1)
            </summary>
            <param name="r1">The first region</param>
            <param name="r2">The second region</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy.Merge(System.Int32,System.Int32)">
            <summary>
            Inform the strategy that two regions will be merged
            </summary>
            <param name="r1">The first region</param>
            <param name="r2">The second region</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyColor">
            <inheritdoc />
            <summary>
            Color-based strategy for the selective search segmentation algorithm.
            The class is implemented from the algorithm described in @cite uijlings2013selective.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyColor.#ctor(System.IntPtr)">
            <inheritdoc />
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyColor.Create">
            <summary>
            Create a new color-based strategy
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategySize">
            <inheritdoc />
            <summary>
            Size-based strategy for the selective search segmentation algorithm.
            The class is implemented from the algorithm described in @cite uijlings2013selective.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategySize.#ctor(System.IntPtr)">
            <inheritdoc />
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategySize.Create">
            <summary>
            Create a new size-based strategy
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyTexture">
            <summary>
            Texture-based strategy for the selective search segmentation algorithm.
            The class is implemented from the algorithm described in @cite uijlings2013selective.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyTexture.#ctor(System.IntPtr)">
            <inheritdoc />
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyTexture.Create">
            <summary>
            Create a new size-based strategy
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyFill">
            <summary>
            Fill-based strategy for the selective search segmentation algorithm.
            The class is implemented from the algorithm described in @cite uijlings2013selective.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyFill.#ctor(System.IntPtr)">
            <inheritdoc />
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyFill.Create">
            <summary>
            Create a new fill-based strategy
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple">
            <inheritdoc />
            <summary>
            Regroup multiple strategies for the selective search segmentation algorithm
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.SetImage(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Set a initial image, with a segementation.
            </summary>
            <param name="img">The input image. Any number of channel can be provided</param>
            <param name="regions">A segementation of the image. The parameter must be the same size of img.</param>
            <param name="sizes">The sizes of different regions</param>
            <param name="imageId">If not set to -1, try to cache pre-computations. If the same set og (img, regions, size) is used, the image_id need to be the same.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.Get(System.Int32,System.Int32)">
            <summary>
            Return the score between two regions (between 0 and 1)
            </summary>
            <param name="r1">The first region</param>
            <param name="r2">The second region</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.Merge(System.Int32,System.Int32)">
            <summary>
            Inform the strategy that two regions will be merged
            </summary>
            <param name="r1">The first region</param>
            <param name="r2">The second region</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.Create">
            <summary>
            Create a new multiple strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.Create(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Create a new multiple strategy and set one subtrategy
            </summary>
            <param name="s1">The first strategy</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.Create(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Create a new multiple strategy and set one subtrategy
            </summary>
            <param name="s1">The first strategy</param>
            <param name="s2">The second strategy</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.Create(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Create a new multiple strategy and set one subtrategy
            </summary>
            <param name="s1">The first strategy</param>
            <param name="s2">The second strategy</param>
            <param name="s3">The third strategy</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategyMultiple.Create(ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy,ST4IVisionCoreNet.XImgProc.Segmentation.SelectiveSearchSegmentationStrategy)">
            <summary>
            Create a new multiple strategy and set one subtrategy
            </summary>
            <param name="s1">The first strategy</param>
            <param name="s2">The second strategy</param>
            <param name="s3">The third strategy</param>
            <param name="s4">The forth strategy</param>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.StructuredEdgeDetection">
            <summary>
            Class implementing edge detection algorithm from @cite Dollar2013 :
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.StructuredEdgeDetection.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.StructuredEdgeDetection.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.StructuredEdgeDetection.Create(System.String,ST4IVisionCoreNet.XImgProc.RFFeatureGetter)">
            <summary>
            Creates a StructuredEdgeDetection
            </summary>
            <param name="model">name of the file where the model is stored</param>
            <param name="howToGetFeatures">optional object inheriting from RFFeatureGetter.
            You need it only if you would like to train your own forest, pass null otherwise</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.StructuredEdgeDetection.GetBoundingBoxes(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.Rect[]@)">
            <summary>
            Returns array containing proposal boxes.
            </summary>
            <param name="edgeMap">edge image.</param>
            <param name="orientationMap">orientation map.</param>
            <param name="boxes">proposal boxes.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.StructuredEdgeDetection.DetectEdges(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            The function detects edges in src and draw them to dst.
            The algorithm underlies this function is much more robust to texture presence, than common approaches, e.g.Sobel
            </summary>
            <param name="src">source image (RGB, float, in [0;1]) to detect edges</param>
            <param name="dst">destination image (grayscale, float, in [0;1]) where edges are drawn</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.StructuredEdgeDetection.ComputeOrientation(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            The function computes orientation from edge image.
            </summary>
            <param name="src">edge image.</param>
            <param name="dst">orientation image.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.StructuredEdgeDetection.EdgesNms(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Single,System.Boolean)">
            <summary>
            The function edgenms in edge image and suppress edges where edge is stronger in orthogonal direction.
            </summary>
            <param name="edgeImage">edge image from detectEdges function.</param>
            <param name="orientationImage">orientation image from computeOrientation function.</param>
            <param name="dst">suppressed image (grayscale, float, in [0;1])</param>
            <param name="r">radius for NMS suppression.</param>
            <param name="s">radius for boundary suppression.</param>
            <param name="m">multiplier for conservative suppression.</param>
            <param name="isParallel">enables/disables parallel computing.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.SuperpixelLSC">
             <summary>
             Class implementing the LSC (Linear Spectral Clustering) superpixels
             algorithm described in @cite LiCVPR2015LSC.
            
             LSC(Linear Spectral Clustering) produces compact and uniform superpixels with low
             computational costs.Basically, a normalized cuts formulation of the superpixel
             segmentation is adopted based on a similarity metric that measures the color
             similarity and space proximity between image pixels.LSC is of linear computational
             complexity and high memory efficiency and is able to preserve global properties of images.
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelLSC.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelLSC.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelLSC.Create(ST4IVisionCoreNet.InputArray,System.Int32,System.Single)">
             <summary>
             Class implementing the LSC (Linear Spectral Clustering) superpixels.
            
             The function initializes a SuperpixelLSC object for the input image. It sets the parameters of
             superpixel algorithm, which are: region_size and ruler.It preallocate some buffers for future
             computing iterations over the given image.An example of LSC is illustrated in the following picture.
             For enhanced results it is recommended for color images to preprocess image with little gaussian blur
             with a small 3 x 3 kernel and additional conversion into CieLAB color space.
             </summary>
             <param name="image">image Image to segment</param>
             <param name="regionSize">Chooses an average superpixel size measured in pixels</param>
             <param name="ratio">Chooses the enforcement of superpixel compactness factor of superpixel</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelLSC.GetNumberOfSuperpixels">
            <summary>
            Calculates the actual amount of superpixels on a given segmentation computed and stored in SuperpixelLSC object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelLSC.Iterate(System.Int32)">
             <summary>
             Calculates the superpixel segmentation on a given image with the initialized
             parameters in the SuperpixelLSC object.
            
             This function can be called again without the need of initializing the algorithm with
             createSuperpixelLSC(). This save the computational cost of allocating memory for all the
             structures of the algorithm.
            
             The function computes the superpixels segmentation of an image with the parameters initialized
             with the function createSuperpixelLSC(). The algorithms starts from a grid of superpixels and
             then refines the boundaries by proposing updates of edges boundaries.
             </summary>
             <param name="numIterations">Number of iterations. Higher number improves the result.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelLSC.GetLabels(ST4IVisionCoreNet.OutputArray)">
             <summary>
             Returns the segmentation labeling of the image.
             Each label represents a superpixel, and each pixel is assigned to one superpixel label.
            
             The function returns an image with the labels of the superpixel segmentation.The labels are in
             the range [0, getNumberOfSuperpixels()].
             </summary>
             <param name="labelsOut">Return: A CV_32SC1 integer array containing the labels of the superpixel
             segmentation.The labels are in the range[0, getNumberOfSuperpixels()].</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelLSC.GetLabelContourMask(ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            Returns the mask of the superpixel segmentation stored in SuperpixelLSC object.
            The function return the boundaries of the superpixel segmentation.
            </summary>
            <param name="image">Return: CV_8U1 image mask where -1 indicates that the pixel is a superpixel border, and 0 otherwise.</param>
            <param name="thickLine">If false, the border is only one pixel wide, otherwise all pixels at the border are masked.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelLSC.EnforceLabelConnectivity(System.Int32)">
            <summary>
            Enforce label connectivity.
            The function merge component that is too small, assigning the previously found adjacent label
            to this component.Calling this function may change the final number of superpixels.
            </summary>
            <param name="minElementSize">The minimum element size in percents that should be absorbed into a bigger
            superpixel.Given resulted average superpixel size valid value should be in 0-100 range, 25 means
            that less then a quarter sized superpixel should be absorbed, this is default.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.SuperpixelSEEDS">
             <summary>
             Class implementing the SEEDS (Superpixels Extracted via Energy-Driven Sampling) superpixels
             algorithm described in @cite VBRV14.
            
             The algorithm uses an efficient hill-climbing algorithm to optimize the superpixels' energy
             function that is based on color histograms and a boundary term, which is optional.The energy
             function encourages superpixels to be of the same color, and if the boundary term is activated, the
             superpixels have smooth boundaries and are of similar shape. In practice it starts from a regular
             grid of superpixels and moves the pixels or blocks of pixels at the boundaries to refine the
             solution.The algorithm runs in real-time using a single CPU.
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSEEDS.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSEEDS.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSEEDS.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
             <summary>
             Initializes a SuperpixelSEEDS object.
            
             The function initializes a SuperpixelSEEDS object for the input image. It stores the parameters of
             the image: image_width, image_height and image_channels.It also sets the parameters of the SEEDS
             superpixel algorithm, which are: num_superpixels, num_levels, use_prior, histogram_bins and
             double_step.
            
             The number of levels in num_levels defines the amount of block levels that the algorithm use in the
             optimization.The initialization is a grid, in which the superpixels are equally distributed through
             the width and the height of the image.The larger blocks correspond to the superpixel size, and the
             levels with smaller blocks are formed by dividing the larger blocks into 2 x 2 blocks of pixels,
             recursively until the smaller block level. An example of initialization of 4 block levels is
             illustrated in the following figure.
             </summary>
             <param name="imageWidth">Image width.</param>
             <param name="imageHeight">Image height.</param>
             <param name="imageChannels">Number of channels of the image.</param>
             <param name="numSuperpixels">Desired number of superpixels. Note that the actual number may be smaller
             due to restrictions(depending on the image size and num_levels). Use getNumberOfSuperpixels() to
             get the actual number.</param>
             <param name="numLevels">Number of block levels. The more levels, the more accurate is the segmentation,
             but needs more memory and CPU time.</param>
             <param name="prior">enable 3x3 shape smoothing term if \>0. A larger value leads to smoother shapes. prior
             must be in the range[0, 5].</param>
             <param name="histogramBins">Number of histogram bins.</param>
             <param name="doubleStep">If true, iterate each block level twice for higher accuracy.</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSEEDS.GetNumberOfSuperpixels">
             <summary>
             Calculates the superpixel segmentation on a given image stored in SuperpixelSEEDS object.
            
             The function computes the superpixels segmentation of an image with the parameters initialized
             with the function createSuperpixelSEEDS().
             </summary>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSEEDS.Iterate(ST4IVisionCoreNet.InputArray,System.Int32)">
            <summary>
            Input image. Supported formats: CV_8U, CV_16U, CV_32F. Image size &amp; number of
            channels must match with the initialized image size &amp; channels with the function
            createSuperpixelSEEDS(). It should be in HSV or Lab color space.Lab is a bit better, but also slower.
            </summary>
            <param name="img">Supported formats: CV_8U, CV_16U, CV_32F. Image size &amp; number of
            channels must match with the initialized image size &amp; channels with the function
            createSuperpixelSEEDS(). It should be in HSV or Lab color space.Lab is a bit better, but also slower.</param>
            <param name="numIterations">Number of pixel level iterations. Higher number improves the result.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSEEDS.GetLabels(ST4IVisionCoreNet.OutputArray)">
             <summary>
             Returns the segmentation labeling of the image.
             Each label represents a superpixel, and each pixel is assigned to one superpixel label.
            
             The function returns an image with ssthe labels of the superpixel segmentation. The labels are in
             the range[0, getNumberOfSuperpixels()].
             </summary>
             <param name="labelsOut">Return: A CV_32UC1 integer array containing the labels of the superpixel
             segmentation.The labels are in the range[0, getNumberOfSuperpixels()].</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSEEDS.GetLabelContourMask(ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            Returns the mask of the superpixel segmentation stored in SuperpixelSEEDS object.
            The function return the boundaries of the superpixel segmentation.
            </summary>
            <param name="image">Return: CV_8U1 image mask where -1 indicates that the pixel is a superpixel border, and 0 otherwise.</param>
            <param name="thickLine">If false, the border is only one pixel wide, otherwise all pixels at the border are masked.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC">
            <summary>
            Class implementing the SLIC (Simple Linear Iterative Clustering) superpixels
            algorithm described in @cite Achanta2012.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC.Create(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.XImgProc.SLICType,System.Int32,System.Single)">
             <summary>
             Initialize a SuperpixelSLIC object.
            
             The function initializes a SuperpixelSLIC object for the input image. It sets the parameters of chosen
             superpixel algorithm, which are: region_size and ruler.It preallocate some buffers for future
             computing iterations over the given image.For enanched results it is recommended for color images to
             preprocess image with little gaussian blur using a small 3 x 3 kernel and additional conversion into
             CieLAB color space.An example of SLIC versus SLICO and MSLIC is ilustrated in the following picture.
             </summary>
             <param name="image">Image to segment</param>
             <param name="algorithm">Chooses the algorithm variant to use:
             SLIC segments image using a desired region_size, and in addition SLICO will optimize using adaptive compactness factor,
             while MSLIC will optimize using manifold methods resulting in more content-sensitive superpixels.</param>
             <param name="regionSize">Chooses an average superpixel size measured in pixels</param>
             <param name="ruler">Chooses the enforcement of superpixel smoothness factor of superpixel</param>
             <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC.GetNumberOfSuperpixels">
            <summary>
            Calculates the actual amount of superpixels on a given segmentation computed
            and stored in SuperpixelSLIC object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC.Iterate(System.Int32)">
             <summary>
             Calculates the superpixel segmentation on a given image with the initialized
             parameters in the SuperpixelSLIC object.
            
             This function can be called again without the need of initializing the algorithm with
             createSuperpixelSLIC(). This save the computational cost of allocating memory for all the
             structures of the algorithm.
            
             The function computes the superpixels segmentation of an image with the parameters initialized
             with the function createSuperpixelSLIC(). The algorithms starts from a grid of superpixels and
             then refines the boundaries by proposing updates of edges boundaries.
             </summary>
             <param name="numIterations">Number of iterations. Higher number improves the result.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC.GetLabels(ST4IVisionCoreNet.OutputArray)">
             <summary>
             Returns the segmentation labeling of the image.
             Each label represents a superpixel, and each pixel is assigned to one superpixel label.
            
             The function returns an image with the labels of the superpixel segmentation. The labels are in
             the range[0, getNumberOfSuperpixels()].
             </summary>
             <param name="labelsOut"></param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC.GetLabelContourMask(ST4IVisionCoreNet.OutputArray,System.Boolean)">
            <summary>
            Returns the mask of the superpixel segmentation stored in SuperpixelSLIC object.
            The function return the boundaries of the superpixel segmentation.
            </summary>
            <param name="image">Return: CV_8U1 image mask where -1 indicates that the pixel is a superpixel border, and 0 otherwise.</param>
            <param name="thickLine">If false, the border is only one pixel wide, otherwise all pixels at the border are masked.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XImgProc.SuperpixelSLIC.EnforceLabelConnectivity(System.Int32)">
             <summary>
             Enforce label connectivity.
            
             The function merge component that is too small, assigning the previously found adjacent label
             to this component.Calling this function may change the final number of superpixels.
             </summary>
             <param name="minElementSize">The minimum element size in percents that should be absorbed into a bigger
             superpixel.Given resulted average superpixel size valid value should be in 0-100 range, 25 means
             that less then a quarter sized superpixel should be absorbed, this is default.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.RidgeDetectionFilter">
            <summary>
            Applies Ridge Detection Filter to an input image.
            
            Implements Ridge detection similar to the one in [Mathematica](http://reference.wolfram.com/language/ref/RidgeFilter.html)
            using the eigen values from the Hessian Matrix of the input image using Sobel Derivatives.
            Additional refinement can be done using Skeletonization and Binarization. Adapted from @cite segleafvein and @cite M_RF
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.RidgeDetectionFilter.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.RidgeDetectionFilter.Create(System.Nullable{ST4IVisionCoreNet.MatType},System.Int32,System.Int32,System.Int32,System.Nullable{ST4IVisionCoreNet.MatType},System.Double,System.Double,ST4IVisionCoreNet.BorderTypes)">
            <summary>
            Create pointer to the Ridge detection filter.
            </summary>
            <param name="ddepth">Specifies output image depth. Defualt is CV_32FC1</param>
            <param name="dx">Order of derivative x, default is 1</param>
            <param name="dy">Order of derivative y, default is 1</param>
            <param name="ksize">Sobel kernel size , default is 3</param>
            <param name="outDtype">Converted format for output, default is CV_8UC1</param>
            <param name="scale">Optional scale value for derivative values, default is 1</param>
            <param name="delta">Optional bias added to output, default is 0</param>
            <param name="borderType">Pixel extrapolation method, default is BORDER_DEFAULT</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.RidgeDetectionFilter.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.RidgeDetectionFilter.GetRidgeFilteredImage(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Apply Ridge detection filter on input image.
            </summary>
            <param name="src">InputArray as supported by Sobel. img can be 1-Channel or 3-Channels.</param>
            <param name="dst">OutputAray of structure as RidgeDetectionFilter::ddepth. Output image with ridges.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.CvXPhoto">
            <summary>
            cv::xphoto functions
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.Bm3dDenoising(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.InputOutputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,ST4IVisionCoreNet.NormTypes,ST4IVisionCoreNet.XPhoto.Bm3dSteps,ST4IVisionCoreNet.XPhoto.TransformTypes)">
            <summary>
            Performs image denoising using the Block-Matching and 3D-filtering algorithm 
            (http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf) with several computational 
            optimizations.Noise expected to be a gaussian white noise.
            </summary>
            <param name="src">Input 8-bit or 16-bit 1-channel image.</param>
            <param name="dstStep1">Output image of the first step of BM3D with the same size and type as src.</param>
            <param name="dstStep2">Output image of the second step of BM3D with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also 
            removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used for block-matching. Should be power of 2.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to perform block-matching.
             Affect performance linearly: greater searchWindowsSize - greater denoising time. Must be larger than templateWindowSize.</param>
            <param name="blockMatchingStep1">Block matching threshold for the first step of BM3D (hard thresholding),
            i.e.maximum distance for which two blocks are considered similar.Value expressed in euclidean distance.</param>
            <param name="blockMatchingStep2">Block matching threshold for the second step of BM3D (Wiener filtering),
            i.e.maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.</param>
            <param name="groupSize">Maximum size of the 3D group for collaborative filtering.</param>
            <param name="slidingStep">Sliding step to process every next reference block.</param>
            <param name="beta">Kaiser window parameter that affects the sidelobe attenuation of the transform of the 
            window.Kaiser window is used in order to reduce border effects.To prevent usage of the window, set beta to zero.</param>
            <param name="normType">Norm used to calculate distance between blocks. L2 is slower than L1 but yields more accurate results.</param>
            <param name="step">Step of BM3D to be executed. Allowed are only BM3D_STEP1 and BM3D_STEPALL. 
            BM3D_STEP2 is not allowed as it requires basic estimate to be present.</param>
            <param name="transformType">Type of the orthogonal transform used in collaborative filtering step. 
            Currently only Haar transform is supported.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.Bm3dDenoising(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,ST4IVisionCoreNet.NormTypes,ST4IVisionCoreNet.XPhoto.Bm3dSteps,ST4IVisionCoreNet.XPhoto.TransformTypes)">
            <summary>
            Performs image denoising using the Block-Matching and 3D-filtering algorithm 
            (http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf) with several computational optimizations.Noise expected to be a gaussian white noise.
            </summary>
            <param name="src">Input 8-bit or 16-bit 1-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also 
            removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used for block-matching. Should be power of 2.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to perform block-matching.
             Affect performance linearly: greater searchWindowsSize - greater denoising time. Must be larger than templateWindowSize.</param>
            <param name="blockMatchingStep1">Block matching threshold for the first step of BM3D (hard thresholding),
            i.e.maximum distance for which two blocks are considered similar.Value expressed in euclidean distance.</param>
            <param name="blockMatchingStep2">Block matching threshold for the second step of BM3D (Wiener filtering),
            i.e.maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.</param>
            <param name="groupSize">Maximum size of the 3D group for collaborative filtering.</param>
            <param name="slidingStep">Sliding step to process every next reference block.</param>
            <param name="beta">Kaiser window parameter that affects the sidelobe attenuation of the transform of the 
            window.Kaiser window is used in order to reduce border effects.To prevent usage of the window, set beta to zero.</param>
            <param name="normType">Norm used to calculate distance between blocks. L2 is slower than L1 but yields more accurate results.</param>
            <param name="step">Step of BM3D to be executed. Allowed are only BM3D_STEP1 and BM3D_STEPALL. 
            BM3D_STEP2 is not allowed as it requires basic estimate to be present.</param>
            <param name="transformType">Type of the orthogonal transform used in collaborative filtering step. 
            Currently only Haar transform is supported.</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.DctDenoising(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,System.Double,System.Int32)">
            <summary>
            The function implements simple dct-based denoising
            </summary>
            <remarks>
            http://www.ipol.im/pub/art/2011/ys-dct/
            </remarks>
            <param name="src">source image</param>
            <param name="dst">destination image</param>
            <param name="sigma">expected noise standard deviation</param>
            <param name="psize">size of block side where dct is computed</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.Inpaint(ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.Mat,ST4IVisionCoreNet.XPhoto.InpaintTypes)">
            <summary>
            The function implements different single-image inpainting algorithms.
            </summary>
            <param name="src">source image, it could be of any type and any number of channels from 1 to 4. In case of 3- and 4-channels images the function expect them in CIELab colorspace or similar one, where first color component shows intensity, while second and third shows colors. Nonetheless you can try any colorspaces.</param>
            <param name="mask">mask (CV_8UC1), where non-zero pixels indicate valid image area, while zero pixels indicate area to be inpainted</param>
            <param name="dst">destination image</param>
            <param name="algorithm">see ST4IVisionCoreNet.XPhoto.InpaintTypes</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.OilPainting(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Int32,System.Int32,System.Nullable{ST4IVisionCoreNet.ColorConversionCodes})">
            <summary>
            oilPainting.
            See the book @cite Holzmann1988 for details.
            </summary>
            <param name="src">Input three-channel or one channel image (either CV_8UC3 or CV_8UC1)</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="size">neighbouring size is 2-size+1</param>
            <param name="dynRatio">image is divided by dynRatio before histogram processing</param>
            <param name="code">color space conversion code(see ColorConversionCodes). Histogram will used only first plane</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.ApplyChannelGains(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Implements an efficient fixed-point approximation for applying channel gains, 
            which is the last step of multiple white balance algorithms.
            </summary>
            <param name="src">Input three-channel image in the BGR color space (either CV_8UC3 or CV_16UC3)</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="gainB">gain for the B channel</param>
            <param name="gainG">gain for the G channel</param>
            <param name="gainR">gain for the R channel</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.CreateGrayworldWB">
            <summary>
            Creates an instance of GrayworldWB
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.CreateLearningBasedWB(System.String)">
            <summary>
            Creates an instance of LearningBasedWB
            </summary>
            <param name="model">Path to a .yml file with the model. If not specified, the default model is used</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.CvXPhoto.CreateSimpleWB">
            <summary>
            Creates an instance of SimpleWB
            </summary>
            <returns></returns>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.Bm3dSteps">
            <summary>
            BM3D algorithm steps
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XPhoto.Bm3dSteps.STEPALL">
            <summary>
            Execute all steps of the algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XPhoto.Bm3dSteps.STEP1">
            <summary>
            Execute only first step of the algorithm
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XPhoto.Bm3dSteps.STEP2">
            <summary>
            Execute only second step of the algorithm
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.InpaintTypes">
            <summary>
            various inpainting algorithms
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XPhoto.InpaintTypes.SHIFTMAP">
            <summary>
            This algorithm searches for dominant correspondences(transformations) of image patches 
            and tries to seamlessly fill-in the area to be inpainted using this transformations inpaint
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XPhoto.InpaintTypes.FSR_BEST">
             <summary>
             Performs Frequency Selective Reconstruction (FSR).
             One of the two quality profiles BEST and FAST can be chosen, depending on the time available for reconstruction.
             See @cite GenserPCS2018 and @cite SeilerTIP2015 for details.
            
             The algorithm may be utilized for the following areas of application:
             1. %Error Concealment (Inpainting).
             The sampling mask indicates the missing pixels of the distorted input
             image to be reconstructed.
             2. Non-Regular Sampling.
             For more information on how to choose a good sampling mask, please review
             @cite GroscheICIP2018 and @cite GroscheIST2018.
            
             1-channel grayscale or 3-channel BGR image are accepted.
            
             Conventional accepted ranges:
             - 0-255 for CV_8U
             - 0-65535 for CV_16U
             - 0-1 for CV_32F/CV_64F.
             </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XPhoto.InpaintTypes.FSR_FAST">
            <summary>
            See #INPAINT_FSR_BEST
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.TransformTypes">
            <summary>
            BM3D transform types
            </summary>
        </member>
        <member name="F:ST4IVisionCoreNet.XPhoto.TransformTypes.HAAR">
            <summary>
            Un-normalized Haar transform
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.GrayworldWB">
            <summary>
            Gray-world white balance algorithm.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.GrayworldWB.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.GrayworldWB.Create">
            <summary>
            Creates an instance of GrayworldWB
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.GrayworldWB.DisposeManaged">
            <inheritdoc />
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.GrayworldWB.SaturationThreshold">
            <summary>
            Maximum saturation for a pixel to be included in the gray-world assumption.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.GrayworldWB.BalanceWhite(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies white balancing to the input image.
            </summary>
            <param name="src">Input image</param>
            <param name="dst">White balancing result</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.LearningBasedWB">
            <summary>
            More sophisticated learning-based automatic white balance algorithm.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.LearningBasedWB.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.LearningBasedWB.Create(System.String)">
            <summary>
            Creates an instance of LearningBasedWB
            </summary>
            <param name="model">Path to a .yml file with the model. If not specified, the default model is used</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.LearningBasedWB.DisposeManaged">
            <inheritdoc />
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.LearningBasedWB.HistBinNum">
            <summary>
            Defines the size of one dimension of a three-dimensional RGB histogram that is used internally by the algorithm. It often makes sense to increase the number of bins for images with higher bit depth (e.g. 256 bins for a 12 bit image).
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.LearningBasedWB.RangeMaxVal">
            <summary>
            Maximum possible value of the input image (e.g. 255 for 8 bit images, 4095 for 12 bit images)
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.LearningBasedWB.SaturationThreshold">
            <summary>
            Threshold that is used to determine saturated pixels, i.e. pixels where at least one of the channels exceeds 
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.LearningBasedWB.BalanceWhite(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies white balancing to the input image.
            </summary>
            <param name="src">Input image</param>
            <param name="dst">White balancing result</param>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.LearningBasedWB.ExtractSimpleFeatures(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Implements the feature extraction part of the algorithm.
            </summary>
            <param name="src">Input three-channel image (BGR color space is assumed).</param>
            <param name="dst">An array of four (r,g) chromaticity tuples corresponding to the features listed above.</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.SimpleWB">
            <summary>
            A simple white balance algorithm that works by independently stretching each of the input image channels to the specified range. For increased robustness it ignores the top and bottom p% of pixel values.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.SimpleWB.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.SimpleWB.Create">
            <summary>
            Creates an instance of SimpleWB
            </summary>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.SimpleWB.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.SimpleWB.InputMax">
            <summary>
            Input image range maximum value.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.SimpleWB.InputMin">
            <summary>
            Input image range minimum value.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.SimpleWB.OutputMax">
            <summary>
            Output image range maximum value.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.SimpleWB.OutputMin">
            <summary>
            Output image range minimum value.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.SimpleWB.P">
            <summary>
            Percent of top/bottom values to ignore.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.SimpleWB.BalanceWhite(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies white balancing to the input image.
            </summary>
            <param name="src">Input image</param>
            <param name="dst">White balancing result</param>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.TonemapDurand">
             <summary>
             This algorithm decomposes image into two layers: base layer and detail layer using bilateral filter
             and compresses contrast of the base layer thus preserving all the details.
            
             This implementation uses regular bilateral filter from OpenCV.
            
             Saturation enhancement is possible as in cv::TonemapDrago.
            
             For more information see @cite DD02 .
             </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.TonemapDurand.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.TonemapDurand.Create(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapDurand object
            </summary>
            <param name="gamma">positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma
            equal to 2.2f is suitable for most displays.
            Generally gamma &gt; 1 brightens the image and gamma &lt; 1 darkens it.</param>
            <param name="contrast">resulting contrast on logarithmic scale, i. e. log(max / min), where max and min</param>
            <param name="saturation">positive saturation enhancement value. 1.0 preserves saturation, values greater 
            than 1 increase saturation and values less than 1 decrease it.</param>
            <param name="sigmaSpace">bilateral filter sigma in coordinate space</param>
            <param name="sigmaColor">bilateral filter sigma in color space</param>
            <returns></returns>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.TonemapDurand.DisposeManaged">
            <summary>
            Releases managed resources
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.TonemapDurand.Saturation">
            <summary>
            Gets or sets positive saturation enhancement value. 1.0 preserves saturation, values greater 
            than 1 increase saturation and values less than 1 decrease it.
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.TonemapDurand.Contrast">
            <summary>
            Gets or sets resulting contrast on logarithmic scale, i. e. log(max / min), where max and min
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.TonemapDurand.SigmaSpace">
            <summary>
            Gets or sets bilateral filter sigma in coordinate space
            </summary>
        </member>
        <member name="P:ST4IVisionCoreNet.XPhoto.TonemapDurand.SigmaColor">
            <summary>
            Gets or sets bilateral filter sigma in color space
            </summary>
        </member>
        <member name="T:ST4IVisionCoreNet.XPhoto.WhiteBalancer">
            <summary>
            The base class for auto white balance algorithms.
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.XPhoto.WhiteBalancer.BalanceWhite(ST4IVisionCoreNet.InputArray,ST4IVisionCoreNet.OutputArray)">
            <summary>
            Applies white balancing to the input image.
            </summary>
            <param name="src">Input image</param>
            <param name="dst">White balancing result</param>
        </member>
        <member name="T:ST4IVisionCoreNet.IHasExternalVersionOut`1">
            <summary>
            This interface indicates that the type is an internal type (used to pass to the Vision DLL)
            that has a corresponding external type (that we will return to the user), and we know how to
            convert from this to the external version.
            </summary>
            <typeparam name="T">The corresponding external type</typeparam>
        </member>
        <member name="T:ST4IVisionCoreNet.IHasExternalVersionIn`1">
            <summary>
            This interface indicates that the type is an internal type (used to pass to the Vision DLL)
            that has a corresponding external type (that we will return to the user), and we know how to
            convert from this to the external version.
            </summary>
            <typeparam name="T">The corresponding external type</typeparam>
        </member>
        <member name="T:ST4IVisionCoreNet.CppConverter">
            <summary>
            Hỗ trợ chuyển đổi dữ liệu từ c++ sang c# và ngược lại
            </summary>
        </member>
        <member name="M:ST4IVisionCoreNet.CppConverter.ConvertIntPtrToCollection``2(System.IntPtr,System.UInt32,System.Boolean)">
            <summary>
            This method converts an array of items (like a report) that we get from CVI
            to its corresponding external type, and disposes the array.
            </summary>
            <param name="ptr">The array that we get back from CVI.</param>
            <param name="count">The number of elements in the array.</param>
            <param name="dispose">Whether to dispose the pointer after done</param>
            <returns>The collection to return to the user.</returns>
        </member>
    </members>
</doc>
